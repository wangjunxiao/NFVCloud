<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>demo: babel-types</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">demo
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">Vfunc Spring Boot项目概要</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">babel-types </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><blockquote class="doxtable">
<p>This module contains methods for building ASTs manually and for checking the types of AST nodes. </p>
</blockquote>
<h2>Install</h2>
<div class="fragment"><div class="line">npm install --save-dev babel-types</div></div><!-- fragment --><h2>API</h2>
<p>### anyTypeAnnotation </p><div class="fragment"><div class="line">t.anyTypeAnnotation()</div></div><!-- fragment --><p>See also <code>t.isAnyTypeAnnotation(node, opts)</code> and <code>t.assertAnyTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowBaseAnnotation</code></p>
<hr/>
<p>### arrayExpression </p><div class="fragment"><div class="line">t.arrayExpression(elements)</div></div><!-- fragment --><p>See also <code>t.isArrayExpression(node, opts)</code> and <code>t.assertArrayExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>elements</code>: <code>Array&lt;null | Expression | SpreadElement&gt;</code> (default: <code>[]</code>) <hr/>
</li>
</ul>
<p>### arrayPattern </p><div class="fragment"><div class="line">t.arrayPattern(elements, typeAnnotation)</div></div><!-- fragment --><p>See also <code>t.isArrayPattern(node, opts)</code> and <code>t.assertArrayPattern(node, opts)</code>.</p>
<p>Aliases: <code>Pattern</code>, <code>LVal</code></p>
<ul>
<li><code>elements</code>: <code>Array&lt;Identifier | Pattern | RestElement&gt;</code> (required)</li>
<li><code>typeAnnotation</code> (required)</li>
<li><code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>) <hr/>
</li>
</ul>
<p>### arrayTypeAnnotation </p><div class="fragment"><div class="line">t.arrayTypeAnnotation(elementType)</div></div><!-- fragment --><p>See also <code>t.isArrayTypeAnnotation(node, opts)</code> and <code>t.assertArrayTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>elementType</code> (required) <hr/>
</li>
</ul>
<p>### arrowFunctionExpression </p><div class="fragment"><div class="line">t.arrowFunctionExpression(params, body, async)</div></div><!-- fragment --><p>See also <code>t.isArrowFunctionExpression(node, opts)</code> and <code>t.assertArrowFunctionExpression(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>Function</code>, <code>BlockParent</code>, <code>FunctionParent</code>, <code>Expression</code>, <code>Pureish</code></p>
<ul>
<li><code>params</code>: <code>Array&lt;LVal&gt;</code> (required)</li>
<li><code>body</code>: <code>BlockStatement | Expression</code> (required)</li>
<li><code>async</code>: <code>boolean</code> (default: <code>false</code>)</li>
<li><code>returnType</code> (default: <code>null</code>)</li>
<li><code>typeParameters</code> (default: <code>null</code>) <hr/>
</li>
</ul>
<p>### assignmentExpression </p><div class="fragment"><div class="line">t.assignmentExpression(operator, left, right)</div></div><!-- fragment --><p>See also <code>t.isAssignmentExpression(node, opts)</code> and <code>t.assertAssignmentExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>operator</code>: <code>string</code> (required)</li>
<li><code>left</code>: <code>LVal</code> (required)</li>
<li><code>right</code>: <code>Expression</code> (required) <hr/>
</li>
</ul>
<p>### assignmentPattern </p><div class="fragment"><div class="line">t.assignmentPattern(left, right)</div></div><!-- fragment --><p>See also <code>t.isAssignmentPattern(node, opts)</code> and <code>t.assertAssignmentPattern(node, opts)</code>.</p>
<p>Aliases: <code>Pattern</code>, <code>LVal</code></p>
<ul>
<li><code>left</code>: <code>Identifier</code> (required)</li>
<li><code>right</code>: <code>Expression</code> (required)</li>
<li><code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>) <hr/>
</li>
</ul>
<p>### awaitExpression </p><div class="fragment"><div class="line">t.awaitExpression(argument)</div></div><!-- fragment --><p>See also <code>t.isAwaitExpression(node, opts)</code> and <code>t.assertAwaitExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>Terminatorless</code></p>
<ul>
<li><code>argument</code>: <code>Expression</code> (required) <hr/>
</li>
</ul>
<p>### binaryExpression </p><div class="fragment"><div class="line">t.binaryExpression(operator, left, right)</div></div><!-- fragment --><p>See also <code>t.isBinaryExpression(node, opts)</code> and <code>t.assertBinaryExpression(node, opts)</code>.</p>
<p>Aliases: <code>Binary</code>, <code>Expression</code></p>
<ul>
<li><code>operator</code>: &lsquo;&rsquo;+' | '-' | '/' | '' | '*' | '**' | '&amp;' | '|' | '&gt;&gt;' | '&gt;&gt;&gt;' | '&lt;&lt;' | '^' | '==' | '===' | '!=' | '!==' | 'in' | 'instanceof' | '&gt;' | '&lt;' | '&gt;=' | '&lt;='<code>(required) -</code>left<code>:</code>Expression&lt;tt&gt;(required) -right<code>:</code>Expression` (required) <hr/>
</li>
</ul>
<p>### bindExpression </p><div class="fragment"><div class="line">t.bindExpression(object, callee)</div></div><!-- fragment --><p>See also <code>t.isBindExpression(node, opts)</code> and <code>t.assertBindExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>object</code> (required)</li>
<li><code>callee</code> (required) <hr/>
</li>
</ul>
<p>### blockStatement </p><div class="fragment"><div class="line">t.blockStatement(body, directives)</div></div><!-- fragment --><p>See also <code>t.isBlockStatement(node, opts)</code> and <code>t.assertBlockStatement(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>BlockParent</code>, <code>Block</code>, <code>Statement</code></p>
<ul>
<li><code>body</code>: <code>Array&lt;Statement&gt;</code> (required)</li>
<li><code>directives</code>: <code>Array&lt;Directive&gt;</code> (default: <code>[]</code>) <hr/>
</li>
</ul>
<p>### booleanLiteral </p><div class="fragment"><div class="line">t.booleanLiteral(value)</div></div><!-- fragment --><p>See also <code>t.isBooleanLiteral(node, opts)</code> and <code>t.assertBooleanLiteral(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>Pureish</code>, <code>Literal</code>, <code>Immutable</code></p>
<ul>
<li><code>value</code>: <code>boolean</code> (required) <hr/>
</li>
</ul>
<p>### booleanLiteralTypeAnnotation </p><div class="fragment"><div class="line">t.booleanLiteralTypeAnnotation()</div></div><!-- fragment --><p>See also <code>t.isBooleanLiteralTypeAnnotation(node, opts)</code> and <code>t.assertBooleanLiteralTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<hr/>
<p>### booleanTypeAnnotation </p><div class="fragment"><div class="line">t.booleanTypeAnnotation()</div></div><!-- fragment --><p>See also <code>t.isBooleanTypeAnnotation(node, opts)</code> and <code>t.assertBooleanTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowBaseAnnotation</code></p>
<hr/>
<p>### breakStatement </p><div class="fragment"><div class="line">t.breakStatement(label)</div></div><!-- fragment --><p>See also <code>t.isBreakStatement(node, opts)</code> and <code>t.assertBreakStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Terminatorless</code>, <code>CompletionStatement</code></p>
<ul>
<li><code>label</code>: <code>Identifier</code> (default: <code>null</code>) <hr/>
</li>
</ul>
<p>### callExpression </p><div class="fragment"><div class="line">t.callExpression(callee, arguments)</div></div><!-- fragment --><p>See also <code>t.isCallExpression(node, opts)</code> and <code>t.assertCallExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>callee</code>: <code>Expression</code> (required)</li>
<li><code>arguments</code>: <code>Array&lt;Expression | SpreadElement&gt;</code> (required) <hr/>
</li>
</ul>
<p>### catchClause </p><div class="fragment"><div class="line">t.catchClause(param, body)</div></div><!-- fragment --><p>See also <code>t.isCatchClause(node, opts)</code> and <code>t.assertCatchClause(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code></p>
<ul>
<li><code>param</code>: <code>Identifier</code> (required)</li>
<li><code>body</code>: <code>BlockStatement</code> (required) <hr/>
</li>
</ul>
<p>### classBody </p><div class="fragment"><div class="line">t.classBody(body)</div></div><!-- fragment --><p>See also <code>t.isClassBody(node, opts)</code> and <code>t.assertClassBody(node, opts)</code>.</p>
<ul>
<li><code>body</code>: <code>Array&lt;ClassMethod | ClassProperty&gt;</code> (required) <hr/>
</li>
</ul>
<p>### classDeclaration </p><div class="fragment"><div class="line">t.classDeclaration(id, superClass, body, decorators)</div></div><!-- fragment --><p>See also <code>t.isClassDeclaration(node, opts)</code> and <code>t.assertClassDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>Class</code>, <code>Statement</code>, <code>Declaration</code>, <code>Pureish</code></p>
<ul>
<li><code>id</code>: <code>Identifier</code> (required)</li>
<li><code>superClass</code>: <code>Expression</code> (default: <code>null</code>)</li>
<li><code>body</code>: <code>ClassBody</code> (required)</li>
<li><code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (required)</li>
<li><code>implements</code> (default: <code>null</code>)</li>
<li><code>mixins</code> (default: <code>null</code>)</li>
<li><code>superTypeParameters</code> (default: <code>null</code>)</li>
<li><code>typeParameters</code> (default: <code>null</code>) <hr/>
</li>
</ul>
<p>### classExpression </p><div class="fragment"><div class="line">t.classExpression(id, superClass, body, decorators)</div></div><!-- fragment --><p>See also <code>t.isClassExpression(node, opts)</code> and <code>t.assertClassExpression(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>Class</code>, <code>Expression</code>, <code>Pureish</code></p>
<ul>
<li><code>id</code>: <code>Identifier</code> (default: <code>null</code>)</li>
<li><code>superClass</code>: <code>Expression</code> (default: <code>null</code>)</li>
<li><code>body</code>: <code>ClassBody</code> (required)</li>
<li><code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (required)</li>
<li><code>implements</code> (default: <code>null</code>)</li>
<li><code>mixins</code> (default: <code>null</code>)</li>
<li><code>superTypeParameters</code> (default: <code>null</code>)</li>
<li><code>typeParameters</code> (default: <code>null</code>) <hr/>
</li>
</ul>
<p>### classImplements </p><div class="fragment"><div class="line">t.classImplements(id, typeParameters)</div></div><!-- fragment --><p>See also <code>t.isClassImplements(node, opts)</code> and <code>t.assertClassImplements(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>typeParameters</code> (required) <hr/>
</li>
</ul>
<p>### classMethod </p><div class="fragment"><div class="line">t.classMethod(kind, key, params, body, computed, static)</div></div><!-- fragment --><p>See also <code>t.isClassMethod(node, opts)</code> and <code>t.assertClassMethod(node, opts)</code>.</p>
<p>Aliases: <code>Function</code>, <code>Scopable</code>, <code>BlockParent</code>, <code>FunctionParent</code>, <code>Method</code></p>
<ul>
<li><code>kind</code>: <code>"get" | "set" | "method" | "constructor"</code> (default: &lsquo;'method&rsquo;<code>) -</code>key<code>if computed then</code>Expression<code>else</code>Identifier | Literal&lt;tt&gt;(required) -params<code>:</code>Array&lt;LVal&gt;<code>(required) -</code>body<code>:</code>BlockStatement&lt;tt&gt;(required) -computed<code>:</code>boolean<code>(default:</code>false<code>) -</code>static<code>:</code>boolean<code>(default:</code>false<code>) -</code>async<code>:</code>boolean<code>(default:</code>false<code>) -</code>decorators<code>(default:</code>null<code>) -</code>generator<code>:</code>boolean<code>(default:</code>false<code>) -</code>returnType<code>(default:</code>null<code>) -</code>typeParameters<code>(default:</code>null`) <hr/>
</li>
</ul>
<p>### classProperty </p><div class="fragment"><div class="line">t.classProperty(key, value, typeAnnotation, decorators, computed)</div></div><!-- fragment --><p>See also <code>t.isClassProperty(node, opts)</code> and <code>t.assertClassProperty(node, opts)</code>.</p>
<p>Aliases: <code>Property</code></p>
<ul>
<li><code>key</code> (required)</li>
<li><code>value</code> (required)</li>
<li><code>typeAnnotation</code> (required)</li>
<li><code>decorators</code> (required)</li>
<li><code>computed</code>: <code>boolean</code> (default: <code>false</code>) <hr/>
</li>
</ul>
<p>### conditionalExpression </p><div class="fragment"><div class="line">t.conditionalExpression(test, consequent, alternate)</div></div><!-- fragment --><p>See also <code>t.isConditionalExpression(node, opts)</code> and <code>t.assertConditionalExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>Conditional</code></p>
<ul>
<li><code>test</code>: <code>Expression</code> (required)</li>
<li><code>consequent</code>: <code>Expression</code> (required)</li>
<li><code>alternate</code>: <code>Expression</code> (required) <hr/>
</li>
</ul>
<p>### continueStatement </p><div class="fragment"><div class="line">t.continueStatement(label)</div></div><!-- fragment --><p>See also <code>t.isContinueStatement(node, opts)</code> and <code>t.assertContinueStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Terminatorless</code>, <code>CompletionStatement</code></p>
<ul>
<li><code>label</code>: <code>Identifier</code> (default: <code>null</code>) <hr/>
</li>
</ul>
<p>### debuggerStatement </p><div class="fragment"><div class="line">t.debuggerStatement()</div></div><!-- fragment --><p>See also <code>t.isDebuggerStatement(node, opts)</code> and <code>t.assertDebuggerStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code></p>
<hr/>
<p>### declareClass </p><div class="fragment"><div class="line">t.declareClass(id, typeParameters, extends, body)</div></div><!-- fragment --><p>See also <code>t.isDeclareClass(node, opts)</code> and <code>t.assertDeclareClass(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowDeclaration</code>, <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>typeParameters</code> (required)</li>
<li><code>extends</code> (required)</li>
<li><code>body</code> (required) <hr/>
</li>
</ul>
<p>### declareFunction </p><div class="fragment"><div class="line">t.declareFunction(id)</div></div><!-- fragment --><p>See also <code>t.isDeclareFunction(node, opts)</code> and <code>t.assertDeclareFunction(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowDeclaration</code>, <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>id</code> (required) <hr/>
</li>
</ul>
<p>### declareInterface </p><div class="fragment"><div class="line">t.declareInterface(id, typeParameters, extends, body)</div></div><!-- fragment --><p>See also <code>t.isDeclareInterface(node, opts)</code> and <code>t.assertDeclareInterface(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowDeclaration</code>, <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>typeParameters</code> (required)</li>
<li><code>extends</code> (required)</li>
<li><code>body</code> (required) <hr/>
</li>
</ul>
<p>### declareModule </p><div class="fragment"><div class="line">t.declareModule(id, body)</div></div><!-- fragment --><p>See also <code>t.isDeclareModule(node, opts)</code> and <code>t.assertDeclareModule(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowDeclaration</code>, <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>body</code> (required) <hr/>
</li>
</ul>
<p>### declareModuleExports </p><div class="fragment"><div class="line">t.declareModuleExports(typeAnnotation)</div></div><!-- fragment --><p>See also <code>t.isDeclareModuleExports(node, opts)</code> and <code>t.assertDeclareModuleExports(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowDeclaration</code>, <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>typeAnnotation</code> (required) <hr/>
</li>
</ul>
<p>### declareTypeAlias </p><div class="fragment"><div class="line">t.declareTypeAlias(id, typeParameters, right)</div></div><!-- fragment --><p>See also <code>t.isDeclareTypeAlias(node, opts)</code> and <code>t.assertDeclareTypeAlias(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowDeclaration</code>, <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>typeParameters</code> (required)</li>
<li><code>right</code> (required) <hr/>
</li>
</ul>
<p>### declareVariable </p><div class="fragment"><div class="line">t.declareVariable(id)</div></div><!-- fragment --><p>See also <code>t.isDeclareVariable(node, opts)</code> and <code>t.assertDeclareVariable(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowDeclaration</code>, <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>id</code> (required) <hr/>
</li>
</ul>
<p>### decorator </p><div class="fragment"><div class="line">t.decorator(expression)</div></div><!-- fragment --><p>See also <code>t.isDecorator(node, opts)</code> and <code>t.assertDecorator(node, opts)</code>.</p>
<ul>
<li><code>expression</code>: <code>Expression</code> (required) <hr/>
</li>
</ul>
<p>### directive </p><div class="fragment"><div class="line">t.directive(value)</div></div><!-- fragment --><p>See also <code>t.isDirective(node, opts)</code> and <code>t.assertDirective(node, opts)</code>.</p>
<ul>
<li><code>value</code>: <code>DirectiveLiteral</code> (required) <hr/>
</li>
</ul>
<p>### directiveLiteral </p><div class="fragment"><div class="line">t.directiveLiteral(value)</div></div><!-- fragment --><p>See also <code>t.isDirectiveLiteral(node, opts)</code> and <code>t.assertDirectiveLiteral(node, opts)</code>.</p>
<ul>
<li><code>value</code>: <code>string</code> (required) <hr/>
</li>
</ul>
<p>### doExpression </p><div class="fragment"><div class="line">t.doExpression(body)</div></div><!-- fragment --><p>See also <code>t.isDoExpression(node, opts)</code> and <code>t.assertDoExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>body</code>: <code>BlockStatement</code> (required) <hr/>
</li>
</ul>
<p>### doWhileStatement </p><div class="fragment"><div class="line">t.doWhileStatement(test, body)</div></div><!-- fragment --><p>See also <code>t.isDoWhileStatement(node, opts)</code> and <code>t.assertDoWhileStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>BlockParent</code>, <code>Loop</code>, <code>While</code>, <code>Scopable</code></p>
<ul>
<li><code>test</code>: <code>Expression</code> (required)</li>
<li><code>body</code>: <code>Statement</code> (required) <hr/>
</li>
</ul>
<p>### emptyStatement </p><div class="fragment"><div class="line">t.emptyStatement()</div></div><!-- fragment --><p>See also <code>t.isEmptyStatement(node, opts)</code> and <code>t.assertEmptyStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code></p>
<hr/>
<p>### emptyTypeAnnotation </p><div class="fragment"><div class="line">t.emptyTypeAnnotation()</div></div><!-- fragment --><p>See also <code>t.isEmptyTypeAnnotation(node, opts)</code> and <code>t.assertEmptyTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowBaseAnnotation</code></p>
<hr/>
<p>### existentialTypeParam </p><div class="fragment"><div class="line">t.existentialTypeParam()</div></div><!-- fragment --><p>See also <code>t.isExistentialTypeParam(node, opts)</code> and <code>t.assertExistentialTypeParam(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<hr/>
<p>### exportAllDeclaration </p><div class="fragment"><div class="line">t.exportAllDeclaration(source)</div></div><!-- fragment --><p>See also <code>t.isExportAllDeclaration(node, opts)</code> and <code>t.assertExportAllDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Declaration</code>, <code>ModuleDeclaration</code>, <code>ExportDeclaration</code></p>
<ul>
<li><code>source</code>: <code>StringLiteral</code> (required) <hr/>
</li>
</ul>
<p>### exportDefaultDeclaration </p><div class="fragment"><div class="line">t.exportDefaultDeclaration(declaration)</div></div><!-- fragment --><p>See also <code>t.isExportDefaultDeclaration(node, opts)</code> and <code>t.assertExportDefaultDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Declaration</code>, <code>ModuleDeclaration</code>, <code>ExportDeclaration</code></p>
<ul>
<li><code>declaration</code>: <code>FunctionDeclaration | ClassDeclaration | Expression</code> (required) <hr/>
</li>
</ul>
<p>### exportDefaultSpecifier </p><div class="fragment"><div class="line">t.exportDefaultSpecifier(exported)</div></div><!-- fragment --><p>See also <code>t.isExportDefaultSpecifier(node, opts)</code> and <code>t.assertExportDefaultSpecifier(node, opts)</code>.</p>
<p>Aliases: <code>ModuleSpecifier</code></p>
<ul>
<li><code>exported</code>: <code>Identifier</code> (required) <hr/>
</li>
</ul>
<p>### exportNamedDeclaration </p><div class="fragment"><div class="line">t.exportNamedDeclaration(declaration, specifiers, source)</div></div><!-- fragment --><p>See also <code>t.isExportNamedDeclaration(node, opts)</code> and <code>t.assertExportNamedDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Declaration</code>, <code>ModuleDeclaration</code>, <code>ExportDeclaration</code></p>
<ul>
<li><code>declaration</code>: <code>Declaration</code> (default: <code>null</code>)</li>
<li><code>specifiers</code>: <code>Array&lt;ExportSpecifier&gt;</code> (required)</li>
<li><code>source</code>: <code>StringLiteral</code> (default: <code>null</code>) <hr/>
</li>
</ul>
<p>### exportNamespaceSpecifier </p><div class="fragment"><div class="line">t.exportNamespaceSpecifier(exported)</div></div><!-- fragment --><p>See also <code>t.isExportNamespaceSpecifier(node, opts)</code> and <code>t.assertExportNamespaceSpecifier(node, opts)</code>.</p>
<p>Aliases: <code>ModuleSpecifier</code></p>
<ul>
<li><code>exported</code>: <code>Identifier</code> (required) <hr/>
</li>
</ul>
<p>### exportSpecifier </p><div class="fragment"><div class="line">t.exportSpecifier(local, exported)</div></div><!-- fragment --><p>See also <code>t.isExportSpecifier(node, opts)</code> and <code>t.assertExportSpecifier(node, opts)</code>.</p>
<p>Aliases: <code>ModuleSpecifier</code></p>
<ul>
<li><code>local</code>: <code>Identifier</code> (required)</li>
<li><code>exported</code>: <code>Identifier</code> (required) <hr/>
</li>
</ul>
<p>### expressionStatement </p><div class="fragment"><div class="line">t.expressionStatement(expression)</div></div><!-- fragment --><p>See also <code>t.isExpressionStatement(node, opts)</code> and <code>t.assertExpressionStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>ExpressionWrapper</code></p>
<ul>
<li><code>expression</code>: <code>Expression</code> (required) <hr/>
</li>
</ul>
<p>### file </p><div class="fragment"><div class="line">t.file(program, comments, tokens)</div></div><!-- fragment --><p>See also <code>t.isFile(node, opts)</code> and <code>t.assertFile(node, opts)</code>.</p>
<ul>
<li><code>program</code>: <code>Program</code> (required)</li>
<li><code>comments</code> (required)</li>
<li><code>tokens</code> (required) <hr/>
</li>
</ul>
<p>### forAwaitStatement </p><div class="fragment"><div class="line">t.forAwaitStatement(left, right, body)</div></div><!-- fragment --><p>See also <code>t.isForAwaitStatement(node, opts)</code> and <code>t.assertForAwaitStatement(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>Statement</code>, <code>For</code>, <code>BlockParent</code>, <code>Loop</code>, <code>ForXStatement</code></p>
<ul>
<li><code>left</code>: <code>VariableDeclaration | LVal</code> (required)</li>
<li><code>right</code>: <code>Expression</code> (required)</li>
<li><code>body</code>: <code>Statement</code> (required) <hr/>
</li>
</ul>
<p>### forInStatement </p><div class="fragment"><div class="line">t.forInStatement(left, right, body)</div></div><!-- fragment --><p>See also <code>t.isForInStatement(node, opts)</code> and <code>t.assertForInStatement(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>Statement</code>, <code>For</code>, <code>BlockParent</code>, <code>Loop</code>, <code>ForXStatement</code></p>
<ul>
<li><code>left</code>: <code>VariableDeclaration | LVal</code> (required)</li>
<li><code>right</code>: <code>Expression</code> (required)</li>
<li><code>body</code>: <code>Statement</code> (required) <hr/>
</li>
</ul>
<p>### forOfStatement </p><div class="fragment"><div class="line">t.forOfStatement(left, right, body)</div></div><!-- fragment --><p>See also <code>t.isForOfStatement(node, opts)</code> and <code>t.assertForOfStatement(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>Statement</code>, <code>For</code>, <code>BlockParent</code>, <code>Loop</code>, <code>ForXStatement</code></p>
<ul>
<li><code>left</code>: <code>VariableDeclaration | LVal</code> (required)</li>
<li><code>right</code>: <code>Expression</code> (required)</li>
<li><code>body</code>: <code>Statement</code> (required) <hr/>
</li>
</ul>
<p>### forStatement </p><div class="fragment"><div class="line">t.forStatement(init, test, update, body)</div></div><!-- fragment --><p>See also <code>t.isForStatement(node, opts)</code> and <code>t.assertForStatement(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>Statement</code>, <code>For</code>, <code>BlockParent</code>, <code>Loop</code></p>
<ul>
<li><code>init</code>: <code>VariableDeclaration | Expression</code> (default: <code>null</code>)</li>
<li><code>test</code>: <code>Expression</code> (default: <code>null</code>)</li>
<li><code>update</code>: <code>Expression</code> (default: <code>null</code>)</li>
<li><code>body</code>: <code>Statement</code> (required) <hr/>
</li>
</ul>
<p>### functionDeclaration </p><div class="fragment"><div class="line">t.functionDeclaration(id, params, body, generator, async)</div></div><!-- fragment --><p>See also <code>t.isFunctionDeclaration(node, opts)</code> and <code>t.assertFunctionDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>Function</code>, <code>BlockParent</code>, <code>FunctionParent</code>, <code>Statement</code>, <code>Pureish</code>, <code>Declaration</code></p>
<ul>
<li><code>id</code>: <code>Identifier</code> (required)</li>
<li><code>params</code>: <code>Array&lt;LVal&gt;</code> (required)</li>
<li><code>body</code>: <code>BlockStatement</code> (required)</li>
<li><code>generator</code>: <code>boolean</code> (default: <code>false</code>)</li>
<li><code>async</code>: <code>boolean</code> (default: <code>false</code>)</li>
<li><code>returnType</code> (default: <code>null</code>)</li>
<li><code>typeParameters</code> (default: <code>null</code>) <hr/>
</li>
</ul>
<p>### functionExpression </p><div class="fragment"><div class="line">t.functionExpression(id, params, body, generator, async)</div></div><!-- fragment --><p>See also <code>t.isFunctionExpression(node, opts)</code> and <code>t.assertFunctionExpression(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>Function</code>, <code>BlockParent</code>, <code>FunctionParent</code>, <code>Expression</code>, <code>Pureish</code></p>
<ul>
<li><code>id</code>: <code>Identifier</code> (default: <code>null</code>)</li>
<li><code>params</code>: <code>Array&lt;LVal&gt;</code> (required)</li>
<li><code>body</code>: <code>BlockStatement</code> (required)</li>
<li><code>generator</code>: <code>boolean</code> (default: <code>false</code>)</li>
<li><code>async</code>: <code>boolean</code> (default: <code>false</code>)</li>
<li><code>returnType</code> (default: <code>null</code>)</li>
<li><code>typeParameters</code> (default: <code>null</code>) <hr/>
</li>
</ul>
<p>### functionTypeAnnotation </p><div class="fragment"><div class="line">t.functionTypeAnnotation(typeParameters, params, rest, returnType)</div></div><!-- fragment --><p>See also <code>t.isFunctionTypeAnnotation(node, opts)</code> and <code>t.assertFunctionTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>typeParameters</code> (required)</li>
<li><code>params</code> (required)</li>
<li><code>rest</code> (required)</li>
<li><code>returnType</code> (required) <hr/>
</li>
</ul>
<p>### functionTypeParam </p><div class="fragment"><div class="line">t.functionTypeParam(name, typeAnnotation)</div></div><!-- fragment --><p>See also <code>t.isFunctionTypeParam(node, opts)</code> and <code>t.assertFunctionTypeParam(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>name</code> (required)</li>
<li><code>typeAnnotation</code> (required) <hr/>
</li>
</ul>
<p>### genericTypeAnnotation </p><div class="fragment"><div class="line">t.genericTypeAnnotation(id, typeParameters)</div></div><!-- fragment --><p>See also <code>t.isGenericTypeAnnotation(node, opts)</code> and <code>t.assertGenericTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>typeParameters</code> (required) <hr/>
</li>
</ul>
<p>### identifier </p><div class="fragment"><div class="line">t.identifier(name)</div></div><!-- fragment --><p>See also <code>t.isIdentifier(node, opts)</code> and <code>t.assertIdentifier(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>LVal</code></p>
<ul>
<li><code>name</code><code>string</code> (required)</li>
<li><code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>)</li>
<li><code>typeAnnotation</code> (default: <code>null</code>) <hr/>
</li>
</ul>
<p>### ifStatement </p><div class="fragment"><div class="line">t.ifStatement(test, consequent, alternate)</div></div><!-- fragment --><p>See also <code>t.isIfStatement(node, opts)</code> and <code>t.assertIfStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Conditional</code></p>
<ul>
<li><code>test</code>: <code>Expression</code> (required)</li>
<li><code>consequent</code>: <code>Statement</code> (required)</li>
<li><code>alternate</code>: <code>Statement</code> (default: <code>null</code>) <hr/>
</li>
</ul>
<p>### import </p><div class="fragment"><div class="line">t.import()</div></div><!-- fragment --><p>See also <code>t.isImport(node, opts)</code> and <code>t.assertImport(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<hr/>
<p>### importDeclaration </p><div class="fragment"><div class="line">t.importDeclaration(specifiers, source)</div></div><!-- fragment --><p>See also <code>t.isImportDeclaration(node, opts)</code> and <code>t.assertImportDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Declaration</code>, <code>ModuleDeclaration</code></p>
<ul>
<li><code>specifiers</code>: <code>Array&lt;ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier&gt;</code> (required)</li>
<li><code>source</code>: <code>StringLiteral</code> (required) <hr/>
</li>
</ul>
<p>### importDefaultSpecifier </p><div class="fragment"><div class="line">t.importDefaultSpecifier(local)</div></div><!-- fragment --><p>See also <code>t.isImportDefaultSpecifier(node, opts)</code> and <code>t.assertImportDefaultSpecifier(node, opts)</code>.</p>
<p>Aliases: <code>ModuleSpecifier</code></p>
<ul>
<li><code>local</code>: <code>Identifier</code> (required) <hr/>
</li>
</ul>
<p>### importNamespaceSpecifier </p><div class="fragment"><div class="line">t.importNamespaceSpecifier(local)</div></div><!-- fragment --><p>See also <code>t.isImportNamespaceSpecifier(node, opts)</code> and <code>t.assertImportNamespaceSpecifier(node, opts)</code>.</p>
<p>Aliases: <code>ModuleSpecifier</code></p>
<ul>
<li><code>local</code>: <code>Identifier</code> (required) <hr/>
</li>
</ul>
<p>### importSpecifier </p><div class="fragment"><div class="line">t.importSpecifier(local, imported)</div></div><!-- fragment --><p>See also <code>t.isImportSpecifier(node, opts)</code> and <code>t.assertImportSpecifier(node, opts)</code>.</p>
<p>Aliases: <code>ModuleSpecifier</code></p>
<ul>
<li><code>local</code>: <code>Identifier</code> (required)</li>
<li><code>imported</code>: <code>Identifier</code> (required)</li>
<li><code>importKind</code>: &lsquo;null | 'type&rsquo; | 'typeof'<code>(default:</code>null`) <hr/>
</li>
</ul>
<p>### interfaceDeclaration </p><div class="fragment"><div class="line">t.interfaceDeclaration(id, typeParameters, extends, body)</div></div><!-- fragment --><p>See also <code>t.isInterfaceDeclaration(node, opts)</code> and <code>t.assertInterfaceDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowDeclaration</code>, <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>typeParameters</code> (required)</li>
<li><code>extends</code> (required)</li>
<li><code>body</code> (required) <hr/>
</li>
</ul>
<p>### interfaceExtends </p><div class="fragment"><div class="line">t.interfaceExtends(id, typeParameters)</div></div><!-- fragment --><p>See also <code>t.isInterfaceExtends(node, opts)</code> and <code>t.assertInterfaceExtends(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>typeParameters</code> (required) <hr/>
</li>
</ul>
<p>### intersectionTypeAnnotation </p><div class="fragment"><div class="line">t.intersectionTypeAnnotation(types)</div></div><!-- fragment --><p>See also <code>t.isIntersectionTypeAnnotation(node, opts)</code> and <code>t.assertIntersectionTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>types</code> (required) <hr/>
</li>
</ul>
<p>### jSXAttribute </p><div class="fragment"><div class="line">t.jSXAttribute(name, value)</div></div><!-- fragment --><p>See also <code>t.isJSXAttribute(node, opts)</code> and <code>t.assertJSXAttribute(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Immutable</code></p>
<ul>
<li><code>name</code>: <code>JSXIdentifier | JSXNamespacedName</code> (required)</li>
<li><code>value</code>: <code>JSXElement | StringLiteral | JSXExpressionContainer</code> (default: <code>null</code>) <hr/>
</li>
</ul>
<p>### jSXClosingElement </p><div class="fragment"><div class="line">t.jSXClosingElement(name)</div></div><!-- fragment --><p>See also <code>t.isJSXClosingElement(node, opts)</code> and <code>t.assertJSXClosingElement(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Immutable</code></p>
<ul>
<li><code>name</code>: <code>JSXIdentifier | JSXMemberExpression</code> (required) <hr/>
</li>
</ul>
<p>### jSXElement </p><div class="fragment"><div class="line">t.jSXElement(openingElement, closingElement, children, selfClosing)</div></div><!-- fragment --><p>See also <code>t.isJSXElement(node, opts)</code> and <code>t.assertJSXElement(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Immutable</code>, <code>Expression</code></p>
<ul>
<li><code>openingElement</code>: <code>JSXOpeningElement</code> (required)</li>
<li><code>closingElement</code>: <code>JSXClosingElement</code> (default: <code>null</code>)</li>
<li><code>children</code>: <code>Array&lt;JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement&gt;</code> (required)</li>
<li><code>selfClosing</code> (required) <hr/>
</li>
</ul>
<p>### jSXEmptyExpression </p><div class="fragment"><div class="line">t.jSXEmptyExpression()</div></div><!-- fragment --><p>See also <code>t.isJSXEmptyExpression(node, opts)</code> and <code>t.assertJSXEmptyExpression(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Expression</code></p>
<hr/>
<p>### jSXExpressionContainer </p><div class="fragment"><div class="line">t.jSXExpressionContainer(expression)</div></div><!-- fragment --><p>See also <code>t.isJSXExpressionContainer(node, opts)</code> and <code>t.assertJSXExpressionContainer(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Immutable</code></p>
<ul>
<li><code>expression</code>: <code>Expression</code> (required) <hr/>
</li>
</ul>
<p>### jSXIdentifier </p><div class="fragment"><div class="line">t.jSXIdentifier(name)</div></div><!-- fragment --><p>See also <code>t.isJSXIdentifier(node, opts)</code> and <code>t.assertJSXIdentifier(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Expression</code></p>
<ul>
<li><code>name</code>: <code>string</code> (required) <hr/>
</li>
</ul>
<p>### jSXMemberExpression </p><div class="fragment"><div class="line">t.jSXMemberExpression(object, property)</div></div><!-- fragment --><p>See also <code>t.isJSXMemberExpression(node, opts)</code> and <code>t.assertJSXMemberExpression(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Expression</code></p>
<ul>
<li><code>object</code>: <code>JSXMemberExpression | JSXIdentifier</code> (required)</li>
<li><code>property</code>: <code>JSXIdentifier</code> (required) <hr/>
</li>
</ul>
<p>### jSXNamespacedName </p><div class="fragment"><div class="line">t.jSXNamespacedName(namespace, name)</div></div><!-- fragment --><p>See also <code>t.isJSXNamespacedName(node, opts)</code> and <code>t.assertJSXNamespacedName(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code></p>
<ul>
<li><code>namespace</code>: <code>JSXIdentifier</code> (required)</li>
<li><code>name</code>: <code>JSXIdentifier</code> (required) <hr/>
</li>
</ul>
<p>### jSXOpeningElement </p><div class="fragment"><div class="line">t.jSXOpeningElement(name, attributes, selfClosing)</div></div><!-- fragment --><p>See also <code>t.isJSXOpeningElement(node, opts)</code> and <code>t.assertJSXOpeningElement(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Immutable</code></p>
<ul>
<li><code>name</code>: <code>JSXIdentifier | JSXMemberExpression</code> (required)</li>
<li><code>attributes</code>: <code>Array&lt;JSXAttribute | JSXSpreadAttribute&gt;</code> (required)</li>
<li><code>selfClosing</code>: <code>boolean</code> (default: <code>false</code>) <hr/>
</li>
</ul>
<p>### jSXSpreadAttribute </p><div class="fragment"><div class="line">t.jSXSpreadAttribute(argument)</div></div><!-- fragment --><p>See also <code>t.isJSXSpreadAttribute(node, opts)</code> and <code>t.assertJSXSpreadAttribute(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code></p>
<ul>
<li><code>argument</code>: <code>Expression</code> (required) <hr/>
</li>
</ul>
<p>### jSXSpreadChild </p><div class="fragment"><div class="line">t.jSXSpreadChild(expression)</div></div><!-- fragment --><p>See also <code>t.isJSXSpreadChild(node, opts)</code> and <code>t.assertJSXSpreadChild(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Immutable</code></p>
<ul>
<li><code>expression</code>: <code>Expression</code> (required) <hr/>
</li>
</ul>
<p>### jSXText </p><div class="fragment"><div class="line">t.jSXText(value)</div></div><!-- fragment --><p>See also <code>t.isJSXText(node, opts)</code> and <code>t.assertJSXText(node, opts)</code>.</p>
<p>Aliases: <code>JSX</code>, <code>Immutable</code></p>
<ul>
<li><code>value</code>: <code>string</code> (required) <hr/>
</li>
</ul>
<p>### labeledStatement </p><div class="fragment"><div class="line">t.labeledStatement(label, body)</div></div><!-- fragment --><p>See also <code>t.isLabeledStatement(node, opts)</code> and <code>t.assertLabeledStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code></p>
<ul>
<li><code>label</code>: <code>Identifier</code> (required)</li>
<li><code>body</code>: <code>Statement</code> (required) <hr/>
</li>
</ul>
<p>### logicalExpression </p><div class="fragment"><div class="line">t.logicalExpression(operator, left, right)</div></div><!-- fragment --><p>See also <code>t.isLogicalExpression(node, opts)</code> and <code>t.assertLogicalExpression(node, opts)</code>.</p>
<p>Aliases: <code>Binary</code>, <code>Expression</code></p>
<ul>
<li><code>operator</code>: &lsquo;&rsquo;||' | '&amp;&amp;'<code>(required) -</code>left<code>:</code>Expression&lt;tt&gt;(required) -right<code>:</code>Expression` (required) <hr/>
</li>
</ul>
<p>### memberExpression </p><div class="fragment"><div class="line">t.memberExpression(object, property, computed)</div></div><!-- fragment --><p>See also <code>t.isMemberExpression(node, opts)</code> and <code>t.assertMemberExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>LVal</code></p>
<ul>
<li><code>object</code>: <code>Expression</code> (required)</li>
<li><code>property</code>if computed then <code>Expression</code> else <code>Identifier</code> (required)</li>
<li><code>computed</code>: <code>boolean</code> (default: <code>false</code>) <hr/>
</li>
</ul>
<p>### metaProperty </p><div class="fragment"><div class="line">t.metaProperty(meta, property)</div></div><!-- fragment --><p>See also <code>t.isMetaProperty(node, opts)</code> and <code>t.assertMetaProperty(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>meta</code>: <code>string</code> (required)</li>
<li><code>property</code>: <code>string</code> (required) <hr/>
</li>
</ul>
<p>### mixedTypeAnnotation </p><div class="fragment"><div class="line">t.mixedTypeAnnotation()</div></div><!-- fragment --><p>See also <code>t.isMixedTypeAnnotation(node, opts)</code> and <code>t.assertMixedTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowBaseAnnotation</code></p>
<hr/>
<p>### newExpression </p><div class="fragment"><div class="line">t.newExpression(callee, arguments)</div></div><!-- fragment --><p>See also <code>t.isNewExpression(node, opts)</code> and <code>t.assertNewExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>callee</code>: <code>Expression</code> (required)</li>
<li><code>arguments</code>: <code>Array&lt;Expression | SpreadElement&gt;</code> (required) <hr/>
</li>
</ul>
<p>### noop </p><div class="fragment"><div class="line">t.noop()</div></div><!-- fragment --><p>See also <code>t.isNoop(node, opts)</code> and <code>t.assertNoop(node, opts)</code>.</p>
<hr/>
<p>### nullLiteral </p><div class="fragment"><div class="line">t.nullLiteral()</div></div><!-- fragment --><p>See also <code>t.isNullLiteral(node, opts)</code> and <code>t.assertNullLiteral(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>Pureish</code>, <code>Literal</code>, <code>Immutable</code></p>
<hr/>
<p>### nullLiteralTypeAnnotation </p><div class="fragment"><div class="line">t.nullLiteralTypeAnnotation()</div></div><!-- fragment --><p>See also <code>t.isNullLiteralTypeAnnotation(node, opts)</code> and <code>t.assertNullLiteralTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowBaseAnnotation</code></p>
<hr/>
<p>### nullableTypeAnnotation </p><div class="fragment"><div class="line">t.nullableTypeAnnotation(typeAnnotation)</div></div><!-- fragment --><p>See also <code>t.isNullableTypeAnnotation(node, opts)</code> and <code>t.assertNullableTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>typeAnnotation</code> (required) <hr/>
</li>
</ul>
<p>### numberTypeAnnotation </p><div class="fragment"><div class="line">t.numberTypeAnnotation()</div></div><!-- fragment --><p>See also <code>t.isNumberTypeAnnotation(node, opts)</code> and <code>t.assertNumberTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowBaseAnnotation</code></p>
<hr/>
<p>### numericLiteral </p><div class="fragment"><div class="line">t.numericLiteral(value)</div></div><!-- fragment --><p>See also <code>t.isNumericLiteral(node, opts)</code> and <code>t.assertNumericLiteral(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>Pureish</code>, <code>Literal</code>, <code>Immutable</code></p>
<ul>
<li><code>value</code>: <code>number</code> (required) <hr/>
</li>
</ul>
<p>### numericLiteralTypeAnnotation </p><div class="fragment"><div class="line">t.numericLiteralTypeAnnotation()</div></div><!-- fragment --><p>See also <code>t.isNumericLiteralTypeAnnotation(node, opts)</code> and <code>t.assertNumericLiteralTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<hr/>
<p>### objectExpression </p><div class="fragment"><div class="line">t.objectExpression(properties)</div></div><!-- fragment --><p>See also <code>t.isObjectExpression(node, opts)</code> and <code>t.assertObjectExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>properties</code>: <code>Array&lt;ObjectMethod | ObjectProperty | SpreadProperty&gt;</code> (required) <hr/>
</li>
</ul>
<p>### objectMethod </p><div class="fragment"><div class="line">t.objectMethod(kind, key, params, body, computed)</div></div><!-- fragment --><p>See also <code>t.isObjectMethod(node, opts)</code> and <code>t.assertObjectMethod(node, opts)</code>.</p>
<p>Aliases: <code>UserWhitespacable</code>, <code>Function</code>, <code>Scopable</code>, <code>BlockParent</code>, <code>FunctionParent</code>, <code>Method</code>, <code>ObjectMember</code></p>
<ul>
<li><code>kind</code>: <code>"method" | "get" | "set"</code> (default: &lsquo;'method&rsquo;<code>) -</code>key<code>if computed then</code>Expression<code>else</code>Identifier | Literal&lt;tt&gt;(required) -params&lt;tt&gt;(required) -body<code>:</code>BlockStatement&lt;tt&gt;(required) -computed<code>:</code>boolean<code>(default:</code>false<code>) -</code>async<code>:</code>boolean<code>(default:</code>false<code>) -</code>decorators<code>:</code>Array&lt;Decorator&gt;<code>(default:</code>null<code>) -</code>generator<code>:</code>boolean<code>(default:</code>false<code>) -</code>returnType<code>(default:</code>null<code>) -</code>typeParameters<code>(default:</code>null`) <hr/>
</li>
</ul>
<p>### objectPattern </p><div class="fragment"><div class="line">t.objectPattern(properties, typeAnnotation)</div></div><!-- fragment --><p>See also <code>t.isObjectPattern(node, opts)</code> and <code>t.assertObjectPattern(node, opts)</code>.</p>
<p>Aliases: <code>Pattern</code>, <code>LVal</code></p>
<ul>
<li><code>properties</code>: <code>Array&lt;RestProperty | Property&gt;</code> (required)</li>
<li><code>typeAnnotation</code> (required)</li>
<li><code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>) <hr/>
</li>
</ul>
<p>### objectProperty </p><div class="fragment"><div class="line">t.objectProperty(key, value, computed, shorthand, decorators)</div></div><!-- fragment --><p>See also <code>t.isObjectProperty(node, opts)</code> and <code>t.assertObjectProperty(node, opts)</code>.</p>
<p>Aliases: <code>UserWhitespacable</code>, <code>Property</code>, <code>ObjectMember</code></p>
<ul>
<li><code>key</code>if computed then <code>Expression</code> else <code>Identifier | Literal</code> (required)</li>
<li><code>value</code>: <code>Expression | Pattern | RestElement</code> (required)</li>
<li><code>computed</code>: <code>boolean</code> (default: <code>false</code>)</li>
<li><code>shorthand</code>: <code>boolean</code> (default: <code>false</code>)</li>
<li><code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>) <hr/>
</li>
</ul>
<p>### objectTypeAnnotation </p><div class="fragment"><div class="line">t.objectTypeAnnotation(properties, indexers, callProperties)</div></div><!-- fragment --><p>See also <code>t.isObjectTypeAnnotation(node, opts)</code> and <code>t.assertObjectTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>properties</code> (required)</li>
<li><code>indexers</code> (required)</li>
<li><code>callProperties</code> (required) <hr/>
</li>
</ul>
<p>### objectTypeCallProperty </p><div class="fragment"><div class="line">t.objectTypeCallProperty(value)</div></div><!-- fragment --><p>See also <code>t.isObjectTypeCallProperty(node, opts)</code> and <code>t.assertObjectTypeCallProperty(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>UserWhitespacable</code></p>
<ul>
<li><code>value</code> (required) <hr/>
</li>
</ul>
<p>### objectTypeIndexer </p><div class="fragment"><div class="line">t.objectTypeIndexer(id, key, value)</div></div><!-- fragment --><p>See also <code>t.isObjectTypeIndexer(node, opts)</code> and <code>t.assertObjectTypeIndexer(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>UserWhitespacable</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>key</code> (required)</li>
<li><code>value</code> (required) <hr/>
</li>
</ul>
<p>### objectTypeProperty </p><div class="fragment"><div class="line">t.objectTypeProperty(key, value)</div></div><!-- fragment --><p>See also <code>t.isObjectTypeProperty(node, opts)</code> and <code>t.assertObjectTypeProperty(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>UserWhitespacable</code></p>
<ul>
<li><code>key</code> (required)</li>
<li><code>value</code> (required) <hr/>
</li>
</ul>
<p>### objectTypeSpreadProperty </p><div class="fragment"><div class="line">t.objectTypeSpreadProperty(argument)</div></div><!-- fragment --><p>See also <code>t.isObjectTypeSpreadProperty(node, opts)</code> and <code>t.assertObjectTypeSpreadProperty(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>UserWhitespacable</code></p>
<ul>
<li><code>argument</code> (required) <hr/>
</li>
</ul>
<p>### parenthesizedExpression </p><div class="fragment"><div class="line">t.parenthesizedExpression(expression)</div></div><!-- fragment --><p>See also <code>t.isParenthesizedExpression(node, opts)</code> and <code>t.assertParenthesizedExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>ExpressionWrapper</code></p>
<ul>
<li><code>expression</code>: <code>Expression</code> (required) <hr/>
</li>
</ul>
<p>### program </p><div class="fragment"><div class="line">t.program(body, directives)</div></div><!-- fragment --><p>See also <code>t.isProgram(node, opts)</code> and <code>t.assertProgram(node, opts)</code>.</p>
<p>Aliases: <code>Scopable</code>, <code>BlockParent</code>, <code>Block</code>, <code>FunctionParent</code></p>
<ul>
<li><code>body</code>: <code>Array&lt;Statement&gt;</code> (required)</li>
<li><code>directives</code>: <code>Array&lt;Directive&gt;</code> (default: <code>[]</code>) <hr/>
</li>
</ul>
<p>### qualifiedTypeIdentifier </p><div class="fragment"><div class="line">t.qualifiedTypeIdentifier(id, qualification)</div></div><!-- fragment --><p>See also <code>t.isQualifiedTypeIdentifier(node, opts)</code> and <code>t.assertQualifiedTypeIdentifier(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>qualification</code> (required) <hr/>
</li>
</ul>
<p>### regExpLiteral </p><div class="fragment"><div class="line">t.regExpLiteral(pattern, flags)</div></div><!-- fragment --><p>See also <code>t.isRegExpLiteral(node, opts)</code> and <code>t.assertRegExpLiteral(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>Literal</code></p>
<ul>
<li><code>pattern</code>: <code>string</code> (required)</li>
<li><code>flags</code>: <code>string</code> (default: &lsquo;&rsquo;'`) <hr/>
</li>
</ul>
<p>### restElement </p><div class="fragment"><div class="line">t.restElement(argument, typeAnnotation)</div></div><!-- fragment --><p>See also <code>t.isRestElement(node, opts)</code> and <code>t.assertRestElement(node, opts)</code>.</p>
<p>Aliases: <code>LVal</code></p>
<ul>
<li><code>argument</code>: <code>LVal</code> (required)</li>
<li><code>typeAnnotation</code> (required)</li>
<li><code>decorators</code>: <code>Array&lt;Decorator&gt;</code> (default: <code>null</code>) <hr/>
</li>
</ul>
<p>### restProperty </p><div class="fragment"><div class="line">t.restProperty(argument)</div></div><!-- fragment --><p>See also <code>t.isRestProperty(node, opts)</code> and <code>t.assertRestProperty(node, opts)</code>.</p>
<p>Aliases: <code>UnaryLike</code></p>
<ul>
<li><code>argument</code>: <code>LVal</code> (required) <hr/>
</li>
</ul>
<p>### returnStatement </p><div class="fragment"><div class="line">t.returnStatement(argument)</div></div><!-- fragment --><p>See also <code>t.isReturnStatement(node, opts)</code> and <code>t.assertReturnStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Terminatorless</code>, <code>CompletionStatement</code></p>
<ul>
<li><code>argument</code>: <code>Expression</code> (default: <code>null</code>) <hr/>
</li>
</ul>
<p>### sequenceExpression </p><div class="fragment"><div class="line">t.sequenceExpression(expressions)</div></div><!-- fragment --><p>See also <code>t.isSequenceExpression(node, opts)</code> and <code>t.assertSequenceExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>expressions</code>: <code>Array&lt;Expression&gt;</code> (required) <hr/>
</li>
</ul>
<p>### spreadElement </p><div class="fragment"><div class="line">t.spreadElement(argument)</div></div><!-- fragment --><p>See also <code>t.isSpreadElement(node, opts)</code> and <code>t.assertSpreadElement(node, opts)</code>.</p>
<p>Aliases: <code>UnaryLike</code></p>
<ul>
<li><code>argument</code>: <code>Expression</code> (required) <hr/>
</li>
</ul>
<p>### spreadProperty </p><div class="fragment"><div class="line">t.spreadProperty(argument)</div></div><!-- fragment --><p>See also <code>t.isSpreadProperty(node, opts)</code> and <code>t.assertSpreadProperty(node, opts)</code>.</p>
<p>Aliases: <code>UnaryLike</code></p>
<ul>
<li><code>argument</code>: <code>Expression</code> (required) <hr/>
</li>
</ul>
<p>### stringLiteral </p><div class="fragment"><div class="line">t.stringLiteral(value)</div></div><!-- fragment --><p>See also <code>t.isStringLiteral(node, opts)</code> and <code>t.assertStringLiteral(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>Pureish</code>, <code>Literal</code>, <code>Immutable</code></p>
<ul>
<li><code>value</code>: <code>string</code> (required) <hr/>
</li>
</ul>
<p>### stringLiteralTypeAnnotation </p><div class="fragment"><div class="line">t.stringLiteralTypeAnnotation()</div></div><!-- fragment --><p>See also <code>t.isStringLiteralTypeAnnotation(node, opts)</code> and <code>t.assertStringLiteralTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<hr/>
<p>### stringTypeAnnotation </p><div class="fragment"><div class="line">t.stringTypeAnnotation()</div></div><!-- fragment --><p>See also <code>t.isStringTypeAnnotation(node, opts)</code> and <code>t.assertStringTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowBaseAnnotation</code></p>
<hr/>
<p>### super </p><div class="fragment"><div class="line">t.super()</div></div><!-- fragment --><p>See also <code>t.isSuper(node, opts)</code> and <code>t.assertSuper(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<hr/>
<p>### switchCase </p><div class="fragment"><div class="line">t.switchCase(test, consequent)</div></div><!-- fragment --><p>See also <code>t.isSwitchCase(node, opts)</code> and <code>t.assertSwitchCase(node, opts)</code>.</p>
<ul>
<li><code>test</code>: <code>Expression</code> (default: <code>null</code>)</li>
<li><code>consequent</code>: <code>Array&lt;Statement&gt;</code> (required) <hr/>
</li>
</ul>
<p>### switchStatement </p><div class="fragment"><div class="line">t.switchStatement(discriminant, cases)</div></div><!-- fragment --><p>See also <code>t.isSwitchStatement(node, opts)</code> and <code>t.assertSwitchStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>BlockParent</code>, <code>Scopable</code></p>
<ul>
<li><code>discriminant</code>: <code>Expression</code> (required)</li>
<li><code>cases</code>: <code>Array&lt;SwitchCase&gt;</code> (required) <hr/>
</li>
</ul>
<p>### taggedTemplateExpression </p><div class="fragment"><div class="line">t.taggedTemplateExpression(tag, quasi)</div></div><!-- fragment --><p>See also <code>t.isTaggedTemplateExpression(node, opts)</code> and <code>t.assertTaggedTemplateExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>tag</code>: <code>Expression</code> (required)</li>
<li><code>quasi</code>: <code>TemplateLiteral</code> (required) <hr/>
</li>
</ul>
<p>### templateElement </p><div class="fragment"><div class="line">t.templateElement(value, tail)</div></div><!-- fragment --><p>See also <code>t.isTemplateElement(node, opts)</code> and <code>t.assertTemplateElement(node, opts)</code>.</p>
<ul>
<li><code>value</code> (required)</li>
<li><code>tail</code>: <code>boolean</code> (default: <code>false</code>) <hr/>
</li>
</ul>
<p>### templateLiteral </p><div class="fragment"><div class="line">t.templateLiteral(quasis, expressions)</div></div><!-- fragment --><p>See also <code>t.isTemplateLiteral(node, opts)</code> and <code>t.assertTemplateLiteral(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>Literal</code></p>
<ul>
<li><code>quasis</code>: <code>Array&lt;TemplateElement&gt;</code> (required)</li>
<li><code>expressions</code>: <code>Array&lt;Expression&gt;</code> (required) <hr/>
</li>
</ul>
<p>### thisExpression </p><div class="fragment"><div class="line">t.thisExpression()</div></div><!-- fragment --><p>See also <code>t.isThisExpression(node, opts)</code> and <code>t.assertThisExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<hr/>
<p>### thisTypeAnnotation </p><div class="fragment"><div class="line">t.thisTypeAnnotation()</div></div><!-- fragment --><p>See also <code>t.isThisTypeAnnotation(node, opts)</code> and <code>t.assertThisTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowBaseAnnotation</code></p>
<hr/>
<p>### throwStatement </p><div class="fragment"><div class="line">t.throwStatement(argument)</div></div><!-- fragment --><p>See also <code>t.isThrowStatement(node, opts)</code> and <code>t.assertThrowStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Terminatorless</code>, <code>CompletionStatement</code></p>
<ul>
<li><code>argument</code>: <code>Expression</code> (required) <hr/>
</li>
</ul>
<p>### tryStatement </p><div class="fragment"><div class="line">t.tryStatement(block, handler, finalizer)</div></div><!-- fragment --><p>See also <code>t.isTryStatement(node, opts)</code> and <code>t.assertTryStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code></p>
<ul>
<li><code>block</code> (required)</li>
<li><code>handler</code> (default: <code>null</code>)</li>
<li><code>finalizer</code>: <code>BlockStatement</code> (default: <code>null</code>)</li>
<li><code>body</code>: <code>BlockStatement</code> (default: <code>null</code>) <hr/>
</li>
</ul>
<p>### tupleTypeAnnotation </p><div class="fragment"><div class="line">t.tupleTypeAnnotation(types)</div></div><!-- fragment --><p>See also <code>t.isTupleTypeAnnotation(node, opts)</code> and <code>t.assertTupleTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>types</code> (required) <hr/>
</li>
</ul>
<p>### typeAlias </p><div class="fragment"><div class="line">t.typeAlias(id, typeParameters, right)</div></div><!-- fragment --><p>See also <code>t.isTypeAlias(node, opts)</code> and <code>t.assertTypeAlias(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowDeclaration</code>, <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>id</code> (required)</li>
<li><code>typeParameters</code> (required)</li>
<li><code>right</code> (required) <hr/>
</li>
</ul>
<p>### typeAnnotation </p><div class="fragment"><div class="line">t.typeAnnotation(typeAnnotation)</div></div><!-- fragment --><p>See also <code>t.isTypeAnnotation(node, opts)</code> and <code>t.assertTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>typeAnnotation</code> (required) <hr/>
</li>
</ul>
<p>### typeCastExpression </p><div class="fragment"><div class="line">t.typeCastExpression(expression, typeAnnotation)</div></div><!-- fragment --><p>See also <code>t.isTypeCastExpression(node, opts)</code> and <code>t.assertTypeCastExpression(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>ExpressionWrapper</code>, <code>Expression</code></p>
<ul>
<li><code>expression</code> (required)</li>
<li><code>typeAnnotation</code> (required) <hr/>
</li>
</ul>
<p>### typeParameter </p><div class="fragment"><div class="line">t.typeParameter(bound)</div></div><!-- fragment --><p>See also <code>t.isTypeParameter(node, opts)</code> and <code>t.assertTypeParameter(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>bound</code> (required) <hr/>
</li>
</ul>
<p>### typeParameterDeclaration </p><div class="fragment"><div class="line">t.typeParameterDeclaration(params)</div></div><!-- fragment --><p>See also <code>t.isTypeParameterDeclaration(node, opts)</code> and <code>t.assertTypeParameterDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>params</code> (required) <hr/>
</li>
</ul>
<p>### typeParameterInstantiation </p><div class="fragment"><div class="line">t.typeParameterInstantiation(params)</div></div><!-- fragment --><p>See also <code>t.isTypeParameterInstantiation(node, opts)</code> and <code>t.assertTypeParameterInstantiation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>params</code> (required) <hr/>
</li>
</ul>
<p>### typeofTypeAnnotation </p><div class="fragment"><div class="line">t.typeofTypeAnnotation(argument)</div></div><!-- fragment --><p>See also <code>t.isTypeofTypeAnnotation(node, opts)</code> and <code>t.assertTypeofTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>argument</code> (required) <hr/>
</li>
</ul>
<p>### unaryExpression </p><div class="fragment"><div class="line">t.unaryExpression(operator, argument, prefix)</div></div><!-- fragment --><p>See also <code>t.isUnaryExpression(node, opts)</code> and <code>t.assertUnaryExpression(node, opts)</code>.</p>
<p>Aliases: <code>UnaryLike</code>, <code>Expression</code></p>
<ul>
<li><code>operator</code>: &lsquo;'void&rsquo; | 'delete' | '!' | '+' | '-' | '++' | '&ndash;' | '~' | 'typeof'<code>(required) -</code>argument<code>:</code>Expression&lt;tt&gt;(required) -prefix<code>:</code>boolean<code>(default:</code>true`) <hr/>
</li>
</ul>
<p>### unionTypeAnnotation </p><div class="fragment"><div class="line">t.unionTypeAnnotation(types)</div></div><!-- fragment --><p>See also <code>t.isUnionTypeAnnotation(node, opts)</code> and <code>t.assertUnionTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code></p>
<ul>
<li><code>types</code> (required) <hr/>
</li>
</ul>
<p>### updateExpression </p><div class="fragment"><div class="line">t.updateExpression(operator, argument, prefix)</div></div><!-- fragment --><p>See also <code>t.isUpdateExpression(node, opts)</code> and <code>t.assertUpdateExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code></p>
<ul>
<li><code>operator</code>: &lsquo;&rsquo;++' | '&ndash;'<code>(required) -</code>argument<code>:</code>Expression&lt;tt&gt;(required) -prefix<code>:</code>boolean<code>(default:</code>false`) <hr/>
</li>
</ul>
<p>### variableDeclaration </p><div class="fragment"><div class="line">t.variableDeclaration(kind, declarations)</div></div><!-- fragment --><p>See also <code>t.isVariableDeclaration(node, opts)</code> and <code>t.assertVariableDeclaration(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>Declaration</code></p>
<ul>
<li><code>kind</code>: <code>"var" | "let" | "const"</code> (required)</li>
<li><code>declarations</code>: <code>Array&lt;VariableDeclarator&gt;</code> (required) <hr/>
</li>
</ul>
<p>### variableDeclarator </p><div class="fragment"><div class="line">t.variableDeclarator(id, init)</div></div><!-- fragment --><p>See also <code>t.isVariableDeclarator(node, opts)</code> and <code>t.assertVariableDeclarator(node, opts)</code>.</p>
<ul>
<li><code>id</code>: <code>LVal</code> (required)</li>
<li><code>init</code>: <code>Expression</code> (default: <code>null</code>) <hr/>
</li>
</ul>
<p>### voidTypeAnnotation </p><div class="fragment"><div class="line">t.voidTypeAnnotation()</div></div><!-- fragment --><p>See also <code>t.isVoidTypeAnnotation(node, opts)</code> and <code>t.assertVoidTypeAnnotation(node, opts)</code>.</p>
<p>Aliases: <code>Flow</code>, <code>FlowBaseAnnotation</code></p>
<hr/>
<p>### whileStatement </p><div class="fragment"><div class="line">t.whileStatement(test, body)</div></div><!-- fragment --><p>See also <code>t.isWhileStatement(node, opts)</code> and <code>t.assertWhileStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code>, <code>BlockParent</code>, <code>Loop</code>, <code>While</code>, <code>Scopable</code></p>
<ul>
<li><code>test</code>: <code>Expression</code> (required)</li>
<li><code>body</code>: <code>BlockStatement | Statement</code> (required) <hr/>
</li>
</ul>
<p>### withStatement </p><div class="fragment"><div class="line">t.withStatement(object, body)</div></div><!-- fragment --><p>See also <code>t.isWithStatement(node, opts)</code> and <code>t.assertWithStatement(node, opts)</code>.</p>
<p>Aliases: <code>Statement</code></p>
<ul>
<li><code>object</code> (required)</li>
<li><code>body</code>: <code>BlockStatement | Statement</code> (required) <hr/>
</li>
</ul>
<p>### yieldExpression </p><div class="fragment"><div class="line">t.yieldExpression(argument, delegate)</div></div><!-- fragment --><p>See also <code>t.isYieldExpression(node, opts)</code> and <code>t.assertYieldExpression(node, opts)</code>.</p>
<p>Aliases: <code>Expression</code>, <code>Terminatorless</code></p>
<ul>
<li><code>argument</code>: <code>Expression</code> (default: <code>null</code>)</li>
<li><code>delegate</code>: <code>boolean</code> (default: <code>false</code>) <hr/>
 </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者 &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
