<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>demo: ipaddr.js — an IPv6 and IPv4 address manipulation library [![Build Status](https://travis-ci.org/whitequark/ipaddr.js.svg)](https://travis-ci.org/whitequark/ipaddr.js)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">demo
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">Vfunc Spring Boot项目概要</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">ipaddr.js — an IPv6 and IPv4 address manipulation library [![Build Status](<a href="https://travis-ci.org/whitequark/ipaddr.js.svg">https://travis-ci.org/whitequark/ipaddr.js.svg</a>)](<a href="https://travis-ci.org/whitequark/ipaddr.js">https://travis-ci.org/whitequark/ipaddr.js</a>) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>ipaddr.js is a small (1.9K minified and gzipped) library for manipulating IP addresses in JavaScript environments. It runs on both CommonJS runtimes (e.g. <a href="http://nodejs.org">nodejs</a>) and in a web browser.</p>
<p>ipaddr.js allows you to verify and parse string representation of an IP address, match it against a CIDR range or range list, determine if it falls into some reserved ranges (examples include loopback and private ranges), and convert between IPv4 and IPv4-mapped IPv6 addresses.</p>
<h2>Installation</h2>
<p><code>npm install ipaddr.js</code></p>
<p>or</p>
<p><code>bower install ipaddr.js</code></p>
<h2>API</h2>
<p>ipaddr.js defines one object in the global scope: <code>ipaddr</code>. In CommonJS, it is exported from the module:</p>
<div class="fragment"><div class="line">var ipaddr = require(&#39;ipaddr.js&#39;);</div></div><!-- fragment --><p>The API consists of several global methods and two classes: ipaddr.IPv6 and ipaddr.IPv4.</p>
<h3>Global methods</h3>
<p>There are three global methods defined: <code>ipaddr.isValid</code>, <code>ipaddr.parse</code> and <code>ipaddr.process</code>. All of them receive a string as a single parameter.</p>
<p>The <code>ipaddr.isValid</code> method returns <code>true</code> if the address is a valid IPv4 or IPv6 address, and <code>false</code> otherwise. It does not throw any exceptions.</p>
<p>The <code>ipaddr.parse</code> method returns an object representing the IP address, or throws an <code>Error</code> if the passed string is not a valid representation of an IP address.</p>
<p>The <code>ipaddr.process</code> method works just like the <code>ipaddr.parse</code> one, but it automatically converts IPv4-mapped IPv6 addresses to their IPv4 couterparts before returning. It is useful when you have a Node.js instance listening on an IPv6 socket, and the <code>net.ivp6.bindv6only</code> sysctl parameter (or its equivalent on non-Linux OS) is set to 0. In this case, you can accept IPv4 connections on your IPv6-only socket, but the remote address will be mangled. Use <code>ipaddr.process</code> method to automatically demangle it.</p>
<h3>Object representation</h3>
<p>Parsing methods return an object which descends from <code>ipaddr.IPv6</code> or <code>ipaddr.IPv4</code>. These objects share some properties, but most of them differ.</p>
<h4>Shared properties</h4>
<p>One can determine the type of address by calling <code>addr.kind()</code>. It will return either <code>"ipv6"</code> or <code>"ipv4"</code>.</p>
<p>An address can be converted back to its string representation with <code>addr.toString()</code>. Note that this method:</p><ul>
<li>does not return the original string used to create the object (in fact, there is no way of getting that string)</li>
<li>returns a compact representation (when it is applicable)</li>
</ul>
<p>A <code>match(range, bits)</code> method can be used to check if the address falls into a certain CIDR range. Note that an address can be (obviously) matched only against an address of the same type.</p>
<p>For example:</p>
<div class="fragment"><div class="line">var addr = ipaddr.parse(&quot;2001:db8:1234::1&quot;);</div><div class="line">var range = ipaddr.parse(&quot;2001:db8::&quot;);</div><div class="line"></div><div class="line">addr.match(range, 32); // =&gt; true</div></div><!-- fragment --><p>Alternatively, <code>match</code> can also be called as <code>match([range, bits])</code>. In this way, it can be used together with the <code>parseCIDR(string)</code> method, which parses an IP address together with a CIDR range.</p>
<p>For example:</p>
<div class="fragment"><div class="line">var addr = ipaddr.parse(&quot;2001:db8:1234::1&quot;);</div><div class="line"></div><div class="line">addr.match(ipaddr.parseCIDR(&quot;2001:db8::/32&quot;)); // =&gt; true</div></div><!-- fragment --><p>A <code>range()</code> method returns one of predefined names for several special ranges defined by IP protocols. The exact names (and their respective CIDR ranges) can be looked up in the source: <a href="https://github.com/whitequark/ipaddr.js/blob/master/src/ipaddr.coffee#L186">IPv6 ranges</a> and <a href="https://github.com/whitequark/ipaddr.js/blob/master/src/ipaddr.coffee#L71">IPv4 ranges</a>. Some common ones include <code>"unicast"</code> (the default one) and <code>"reserved"</code>.</p>
<p>You can match against your own range list by using <code>ipaddr.subnetMatch(address, rangeList, defaultName)</code> method. It can work with both IPv6 and IPv4 addresses, and accepts a name-to-subnet map as the range list. For example:</p>
<div class="fragment"><div class="line">var rangeList = {</div><div class="line">  documentationOnly: [ ipaddr.parse(&#39;2001:db8::&#39;), 32 ],</div><div class="line">  tunnelProviders: [</div><div class="line">    [ ipaddr.parse(&#39;2001:470::&#39;), 32 ], // he.net</div><div class="line">    [ ipaddr.parse(&#39;2001:5c0::&#39;), 32 ]  // freenet6</div><div class="line">  ]</div><div class="line">};</div><div class="line">ipaddr.subnetMatch(ipaddr.parse(&#39;2001:470:8:66::1&#39;), rangeList, &#39;unknown&#39;); // =&gt; &quot;he.net&quot;</div></div><!-- fragment --><p>The addresses can be converted to their byte representation with <code>toByteArray()</code>. (Actually, JavaScript mostly does not know about byte buffers. They are emulated with arrays of numbers, each in range of 0..255.)</p>
<div class="fragment"><div class="line">var bytes = ipaddr.parse(&#39;2a00:1450:8007::68&#39;).toByteArray(); // ipv6.google.com</div><div class="line">bytes // =&gt; [42, 0x00, 0x14, 0x50, 0x80, 0x07, 0x00, &lt;zeroes...&gt;, 0x00, 0x68 ]</div></div><!-- fragment --><p>The <code>ipaddr.IPv4</code> and <code>ipaddr.IPv6</code> objects have some methods defined, too. All of them have the same interface for both protocols, and are similar to global methods.</p>
<p><code>ipaddr.IPvX.isValid(string)</code> can be used to check if the string is a valid address for particular protocol, and <code>ipaddr.IPvX.parse(string)</code> is the error-throwing parser.</p>
<p><code>ipaddr.IPvX.isValid(string)</code> uses the same format for parsing as the POSIX <code>inet_ntoa</code> function, which accepts unusual formats like <code>0xc0.168.1.1</code> or <code>0x10000000</code>. The function <code>ipaddr.IPv4.isValidFourPartDecimal(string)</code> validates the IPv4 address and also ensures that it is written in four-part decimal format.</p>
<h4>IPv6 properties</h4>
<p>Sometimes you will want to convert IPv6 not to a compact string representation (with the <code>::</code> substitution); the <code>toNormalizedString()</code> method will return an address where all zeroes are explicit.</p>
<p>For example:</p>
<div class="fragment"><div class="line">var addr = ipaddr.parse(&quot;2001:0db8::0001&quot;);</div><div class="line">addr.toString(); // =&gt; &quot;2001:db8::1&quot;</div><div class="line">addr.toNormalizedString(); // =&gt; &quot;2001:db8:0:0:0:0:0:1&quot;</div></div><!-- fragment --><p>The <code>isIPv4MappedAddress()</code> method will return <code>true</code> if this address is an IPv4-mapped one, and <code>toIPv4Address()</code> will return an IPv4 object address.</p>
<p>To access the underlying binary representation of the address, use <code>addr.parts</code>.</p>
<div class="fragment"><div class="line">var addr = ipaddr.parse(&quot;2001:db8:10::1234:DEAD&quot;);</div><div class="line">addr.parts // =&gt; [0x2001, 0xdb8, 0x10, 0, 0, 0, 0x1234, 0xdead]</div></div><!-- fragment --><h4>IPv4 properties</h4>
<p><code>toIPv4MappedAddress()</code> will return a corresponding IPv4-mapped IPv6 address.</p>
<p>To access the underlying representation of the address, use <code>addr.octets</code>.</p>
<div class="fragment"><div class="line">var addr = ipaddr.parse(&quot;192.168.1.1&quot;);</div><div class="line">addr.octets // =&gt; [192, 168, 1, 1]</div></div><!-- fragment --><p><code>prefixLengthFromSubnetMask()</code> will return a CIDR prefix length for a valid IPv4 netmask or false if the netmask is not valid.</p>
<div class="fragment"><div class="line">ipaddr.IPv4.parse(&#39;255.255.255.240&#39;).prefixLengthFromSubnetMask() == 28</div><div class="line">ipaddr.IPv4.parse(&#39;255.192.164.0&#39;).prefixLengthFromSubnetMask()  == null</div></div><!-- fragment --><h4>Conversion</h4>
<p>IPv4 and IPv6 can be converted bidirectionally to and from network byte order (MSB) byte arrays.</p>
<p>The <code>fromByteArray()</code> method will take an array and create an appropriate IPv4 or IPv6 object if the input satisfies the requirements. For IPv4 it has to be an array of four 8-bit values, while for IPv6 it has to be an array of sixteen 8-bit values.</p>
<p>For example: </p><div class="fragment"><div class="line">var addr = ipaddr.fromByteArray([0x7f, 0, 0, 1]);</div><div class="line">addr.toString(); // =&gt; &quot;127.0.0.1&quot;</div></div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line">var addr = ipaddr.fromByteArray([0x20, 1, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])</div><div class="line">addr.toString(); // =&gt; &quot;2001:db8::1&quot;</div></div><!-- fragment --><p>Both objects also offer a <code>toByteArray()</code> method, which returns an array in network byte order (MSB).</p>
<p>For example: </p><div class="fragment"><div class="line">var addr = ipaddr.parse(&quot;127.0.0.1&quot;);</div><div class="line">addr.toByteArray(); // =&gt; [0x7f, 0, 0, 1]</div></div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line">var addr = ipaddr.parse(&quot;2001:db8::1&quot;);</div><div class="line">addr.toByteArray(); // =&gt; [0x20, 1, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者 &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
