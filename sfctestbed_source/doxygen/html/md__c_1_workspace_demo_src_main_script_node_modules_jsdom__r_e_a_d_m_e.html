<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>demo: jsdom</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">demo
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">Vfunc Spring Boot项目概要</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">jsdom </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A JavaScript implementation of the WHATWG DOM and HTML standards, for use with <a href="https://nodejs.org/">Node.js</a>.</p>
<h2>Install</h2>
<div class="fragment"><div class="line">$ npm install jsdom</div></div><!-- fragment --><p>Note that as of our 7.0.0 release, jsdom requires Node.js 4 or newer (<a href="https://github.com/tmpvar/jsdom/blob/master/Changelog.md#700">why?</a>). In the meantime you are still welcome to install a release in <a href="https://github.com/tmpvar/jsdom/tree/3.x">the 3.x series</a> if you use legacy Node.js versions like 0.10 or 0.12. There are also various releases between 3.x and 7.0.0 that work with various io.js versions.</p>
<h2>Human contact</h2>
<ul>
<li><a href="http://groups.google.com/group/jsdom">Mailing list</a></li>
<li>IRC channel: <a href="irc://irc.freenode.net/jsdom">#jsdom on freenode</a></li>
</ul>
<h2>Easymode: <code>jsdom.env</code></h2>
<p><code>jsdom.env</code> is an API that allows you to throw a bunch of stuff at it, and it will generally do the right thing.</p>
<p>You can use it with a <a class="el" href="namespace_u_r_l.html">URL</a></p>
<div class="fragment"><div class="line">// Count all of the links from the io.js build page</div><div class="line">var jsdom = require(&quot;jsdom&quot;);</div><div class="line"></div><div class="line">jsdom.env(</div><div class="line">  &quot;https://iojs.org/dist/&quot;,</div><div class="line">  [&quot;http://code.jquery.com/jquery.js&quot;],</div><div class="line">  function (err, window) {</div><div class="line">    console.log(&quot;there have been&quot;, window.$(&quot;a&quot;).length - 4, &quot;io.js releases!&quot;);</div><div class="line">  }</div><div class="line">);</div></div><!-- fragment --><p>or with raw HTML</p>
<div class="fragment"><div class="line">// Run some jQuery on a html fragment</div><div class="line">var jsdom = require(&quot;jsdom&quot;);</div><div class="line"></div><div class="line">jsdom.env(</div><div class="line">  &#39;&lt;p&gt;&lt;a class=&quot;the-link&quot; href=&quot;https://github.com/tmpvar/jsdom&quot;&gt;jsdom!&lt;/a&gt;&lt;/p&gt;&#39;,</div><div class="line">  [&quot;http://code.jquery.com/jquery.js&quot;],</div><div class="line">  function (err, window) {</div><div class="line">    console.log(&quot;contents of a.the-link:&quot;, window.$(&quot;a.the-link&quot;).text());</div><div class="line">  }</div><div class="line">);</div></div><!-- fragment --><p>or with a configuration object</p>
<div class="fragment"><div class="line">// Print all of the news items on Hacker News</div><div class="line">var jsdom = require(&quot;jsdom&quot;);</div><div class="line"></div><div class="line">jsdom.env({</div><div class="line">  url: &quot;http://news.ycombinator.com/&quot;,</div><div class="line">  scripts: [&quot;http://code.jquery.com/jquery.js&quot;],</div><div class="line">  done: function (err, window) {</div><div class="line">    var $ = window.$;</div><div class="line">    console.log(&quot;HN Links&quot;);</div><div class="line">    $(&quot;td.title:not(:last) a&quot;).each(function() {</div><div class="line">      console.log(&quot; -&quot;, $(this).text());</div><div class="line">    });</div><div class="line">  }</div><div class="line">});</div></div><!-- fragment --><p>or with raw JavaScript source</p>
<div class="fragment"><div class="line">// Print all of the news items on Hacker News</div><div class="line">var jsdom = require(&quot;jsdom&quot;);</div><div class="line">var fs = require(&quot;fs&quot;);</div><div class="line">var jquery = fs.readFileSync(&quot;./path/to/jquery.js&quot;, &quot;utf-8&quot;);</div><div class="line"></div><div class="line">jsdom.env({</div><div class="line">  url: &quot;http://news.ycombinator.com/&quot;,</div><div class="line">  src: [jquery],</div><div class="line">  done: function (err, window) {</div><div class="line">    var $ = window.$;</div><div class="line">    console.log(&quot;HN Links&quot;);</div><div class="line">    $(&quot;td.title:not(:last) a&quot;).each(function () {</div><div class="line">      console.log(&quot; -&quot;, $(this).text());</div><div class="line">    });</div><div class="line">  }</div><div class="line">});</div></div><!-- fragment --><h3>How it works</h3>
<p>The do-what-I-mean API is used like so:</p>
<div class="fragment"><div class="line">jsdom.env(string, [scripts], [config], callback);</div></div><!-- fragment --><ul>
<li><code>string</code>: may be a <a class="el" href="namespace_u_r_l.html">URL</a>, file name, or HTML fragment</li>
<li><code>scripts</code>: a string or array of strings, containing file names or URLs that will be inserted as <code>&lt;script&gt;</code> tags</li>
<li><code>config</code>: see below</li>
<li><code>callback</code>: takes two arguments<ul>
<li><code>err</code>: either <code>null</code>, if nothing goes wrong, or an error, if the window could not be created</li>
<li><code>window</code>: a brand new <code>window</code>, if there wasn't an error</li>
</ul>
</li>
</ul>
<p><em>Example:</em></p>
<div class="fragment"><div class="line">jsdom.env(html, function (err, window) {</div><div class="line">  // free memory associated with the window</div><div class="line">  window.close();</div><div class="line">});</div></div><!-- fragment --><p>If you would like to specify a configuration object only:</p>
<div class="fragment"><div class="line">jsdom.env(config);</div></div><!-- fragment --><ul>
<li><code>config.html</code>: a HTML fragment</li>
<li><code>config.file</code>: a file which jsdom will load HTML from; the resulting document's <a class="el" href="namespace_u_r_l.html">URL</a> will be a <code><a href="file://">file://</a></code> <a class="el" href="namespace_u_r_l.html">URL</a>.</li>
<li><code>config.url</code>: sets the resulting document's <a class="el" href="namespace_u_r_l.html">URL</a>, which is reflected in various properties like <code>document.URL</code> and <code>location.href</code>, and is also used for cross-origin request restrictions. If <code>config.html</code> and <code>config.file</code> are not provided, jsdom will load HTML from this <a class="el" href="namespace_u_r_l.html">URL</a>.</li>
<li><code>config.scripts</code>: see <code>scripts</code> above.</li>
<li><code>config.src</code>: an array of JavaScript strings that will be evaluated against the resulting document. Similar to <code>scripts</code>, but it accepts JavaScript instead of paths/URLs.</li>
<li><code>config.cookieJar</code>: cookie jar which will be used by document and related resource requests. Can be created by <code>jsdom.createCookieJar()</code> method. Useful to share cookie state among different documents as browsers does.</li>
<li><code>config.parsingMode</code>: either <code>"auto"</code>, <code>"html"</code>, or <code>"xml"</code>. The default is <code>"auto"</code>, which uses HTML behavior unless <code>config.url</code> responds with an XML <code>Content-Type</code>, or <code>config.file</code> contains a filename ending in <code>.xml</code> or <code>.xhtml</code>. Setting to <code>"xml"</code> will attempt to parse the document as an XHTML document. (jsdom is <a href="https://github.com/tmpvar/jsdom/labels/x%28ht%29ml">currently only OK at doing that</a>.)</li>
<li><code>config.referrer</code>: the new document will have this referrer.</li>
<li><code>config.cookie</code>: manually set a cookie value, e.g. &lsquo;'key=value; expires=Wed, Sep 21 2011 12:00:00 GMT; path=/&rsquo;<code>. Accepts cookie string or array of cookie strings. -</code>config.headers&lt;tt&gt;: an object giving any headers that will be used while loading the HTML fromconfig.url&lt;tt&gt;, if applicable. -config.userAgent&lt;tt&gt;: the user agent string used in requests; defaults toNode.js (#process.platform#; U; rv:#process.version#)<code> -</code>config.features&lt;tt&gt;: see Flexibility section below. **Note**: the default feature set forjsdom.env&lt;tt&gt;does _not_ include fetching remote JavaScript and executing it. This is something that you will need to _carefully_ enable yourself. -config.resourceLoader&lt;tt&gt;: a function that intercepts subresource requests and allows you to re-route them, modify, or outright replace them with your own content. More below. -config.done&lt;tt&gt;,config.onload&lt;tt&gt;,config.created&lt;tt&gt;: see below. -config.concurrentNodeIterators&lt;tt&gt;: the maximum amount ofNodeIterator<code>s that you can use at the same time. The default is</code>10<code>; setting this to a high value will hurt performance. -</code>config.virtualConsole&lt;tt&gt;: a virtual console instance that can capture the window’s console output; see the "Capturing Console Output" examples. -config.pool&lt;tt&gt;: an object describing which agents to use for the requests; defaults to{ maxSockets: 6 }<code>, see [request module](<a href="https://github.com/request/request#requestoptions-callback">https://github.com/request/request#requestoptions-callback</a>) for more details. -</code>config.agent&lt;tt&gt;:http(s).Agent<code>instance to use -</code>config.agentClass&lt;tt&gt;: alternatively specify your agent's class name -config.agentOptions&lt;tt&gt;: the agent options; defaults to{ keepAlive: true, keepAliveMsecs: 115000 }<code>, see [http api](<a href="https://nodejs.org/api/http.html">https://nodejs.org/api/http.html</a>) for more details. -</code>config.strictSSL&lt;tt&gt;: iftrue<code>, requires SSL certificates be valid; defaults to</code>true<code>, see [request module](<a href="https://github.com/request/request#requestoptions-callback">https://github.com/request/request#requestoptions-callback</a>) for more details. -</code>config.proxy`: a <a class="el" href="namespace_u_r_l.html">URL</a> for a HTTP proxy to use for the requests.</li>
</ul>
<p>Note that at least one of the callbacks (<code>done</code>, <code>onload</code>, or <code>created</code>) is required, as is one of <code>html</code>, <code>file</code>, or <code>url</code>.</p>
<h3>Initialization lifecycle</h3>
<p>If you just want to load the document and execute it, the <code>done</code> callback shown above is the simplest. If anything goes wrong while loading the document and creating the window, the problem will show up in the <code>error</code> passed as the first argument.</p>
<p>However, if you want more control over or insight into the initialization lifecycle, you'll want to use the <code>created</code> and/or <code>onload</code> callbacks:</p>
<h4><code>created(error, window)</code></h4>
<p>The <code>created</code> callback is called as soon as the window is created, or if that process fails. You may access all <code>window</code> properties here; however, <code>window.document</code> is not ready for use yet, as the HTML has not been parsed.</p>
<p>The primary use-case for <code>created</code> is to modify the window object (e.g. add new functions on built-in prototypes) before any scripts execute.</p>
<p>You can also set an event handler for &lsquo;'load&rsquo;` or other events on the window if you wish.</p>
<p>If the <code>error</code> argument is non-<code>null</code>, it will contain whatever loading or initialization error caused the window creation to fail; in that case <code>window</code> will not be passed.</p>
<h4><code>onload(window)</code></h4>
<p>The <code>onload</code> callback is called along with the window's &lsquo;'load&rsquo;<code>event. This means it will only be called if creation succeeds without error. Note that by the time it has called, any external resources will have been downloaded, and any</code>&lt;script&gt;`s will have finished executing.</p>
<h4><code>done(error, window)</code></h4>
<p>Now that you know about <code>created</code> and <code>onload</code>, you can see that <code>done</code> is essentially both of them smashed together:</p>
<ul>
<li>If window creation fails, then <code>error</code> will be the creation error.</li>
<li>Otherwise, <code>window</code> will be a fully-loaded window, with all external resources downloaded and <code>&lt;script&gt;</code>s executed.</li>
</ul>
<h4>Dealing with asynchronous script loading</h4>
<p>If you load scripts asynchronously, e.g. with a module loader like RequireJS, none of the above hooks will really give you what you want. There's nothing, either in jsdom or in browsers, to say "notify me after all asynchronous loads have completed." The solution is to use the mechanisms of the framework you are using to notify about this finishing up. E.g., with RequireJS, you could do</p>
<div class="fragment"><div class="line">// On the Node.js side:</div><div class="line">var window = jsdom.jsdom(...).defaultView;</div><div class="line">window.onModulesLoaded = function () {</div><div class="line">  console.log(&quot;ready to roll!&quot;);</div><div class="line">};</div></div><!-- fragment --><div class="fragment"><div class="line">&lt;script&gt;</div><div class="line">requirejs([&quot;entry-module&quot;], function () {</div><div class="line">  window.onModulesLoaded();</div><div class="line">});</div><div class="line">&lt;/script&gt;</div></div><!-- fragment --><p>For more details, see the discussion in <a href="https://github.com/tmpvar/jsdom/issues/640">#640</a>, especially <a href="https://github.com/matthewkastor"></a>'s <a href="https://github.com/tmpvar/jsdom/issues/640#issuecomment-22216965">insightful comment</a>.</p>
<h4>Listening for script errors during initialization</h4>
<p>Although it is easy to listen for script errors after initialization, via code like</p>
<div class="fragment"><div class="line">var window = jsdom.jsdom(...).defaultView;</div><div class="line">window.addEventListener(&quot;error&quot;, function (event) {</div><div class="line">  console.error(&quot;script error!!&quot;, event.error);</div><div class="line">});</div></div><!-- fragment --><p>it is often also desirable to listen for any script errors during initialization, or errors loading scripts passed to <code>jsdom.env</code>. To do this, use the virtual console feature, described in more detail later:</p>
<div class="fragment"><div class="line">var virtualConsole = jsdom.createVirtualConsole();</div><div class="line">virtualConsole.on(&quot;jsdomError&quot;, function (error) {</div><div class="line">  console.error(error.stack, error.detail);</div><div class="line">});</div><div class="line"></div><div class="line">var window = jsdom.jsdom(..., { virtualConsole }).defaultView;</div></div><!-- fragment --><p>You also get this functionality for free by default if you use <code>virtualConsole.sendTo</code>; again, see more below:</p>
<div class="fragment"><div class="line">var virtualConsole = jsdom.createVirtualConsole().sendTo(console);</div><div class="line">var window = jsdom.jsdom(..., { virtualConsole }).defaultView;</div></div><!-- fragment --><h3>On running scripts and being safe</h3>
<p>By default, <code>jsdom.env</code> will not process and run external JavaScript, since our sandbox is not foolproof. That is, code running inside the DOM's <code>&lt;script&gt;</code>s can, if it tries hard enough, get access to the Node environment, and thus to your machine. If you want to (carefully!) enable running JavaScript, you can use <code>jsdom.jsdom</code>, <code>jsdom.jQueryify</code>, or modify the defaults passed to <code>jsdom.env</code>.</p>
<h3>On timers and process lifetime</h3>
<p>Timers in the page (set by <code>window.setTimeout</code> or <code>window.setInterval</code>) will, by definition, execute code in the future in the context of the <code>window</code>. Since there is no way to execute code in the future without keeping the process alive, note that outstanding jsdom timers will keep your Node.js process alive. Similarly, since there is no way to execute code in the context of an object without keeping that object alive, outstanding jsdom timers will prevent garbage collection of the <code>window</code> on which they are scheduled. If you want to be sure to shut down a jsdom window, use <code>window.close()</code>, which will terminate all running timers (and also remove any event listeners on the <code>window</code> and <code>document</code>).</p>
<h2>For the hardcore: <code>jsdom.jsdom</code></h2>
<p>The <code>jsdom.jsdom</code> method does fewer things automatically; it takes in only HTML source, and it does not allow you to separately supply scripts that it will inject and execute. It just gives you back a <code>document</code> object, with usable <code>document.defaultView</code>, and starts asynchronously executing any <code>&lt;script&gt;</code>s included in the HTML source. You can listen for the &lsquo;'load&rsquo;` event to wait until scripts are done loading and executing, just like you would in a normal HTML page.</p>
<p>Usage of the API generally looks like this:</p>
<div class="fragment"><div class="line">var jsdom = require(&quot;jsdom&quot;).jsdom;</div><div class="line">var doc = jsdom(markup, options);</div><div class="line">var window = doc.defaultView;</div></div><!-- fragment --><ul>
<li><code>markup</code> is a HTML document to be parsed. You can also pass <code>undefined</code> to get the basic document, equivalent to what a browser will give if you open up an empty <code>.html</code> file.</li>
<li><code>options</code>: see the explanation of the <code>config</code> object above.</li>
</ul>
<h3>Flexibility</h3>
<p>One of the goals of jsdom is to be as minimal and light as possible. This section details how someone can change the behavior of <code>Document</code>s before they are created. These features are baked into the <code>DOMImplementation</code> that every <code>Document</code> has, and may be tweaked in two ways:</p>
<ol type="1">
<li>When you create a new <code>Document</code>, by overriding the configuration:</li>
</ol>
<div class="fragment"><div class="line">var jsdom = require(&quot;jsdom&quot;).jsdom;</div><div class="line">var doc = jsdom(&quot;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;, {</div><div class="line">    features: {</div><div class="line">      FetchExternalResources : [&quot;link&quot;]</div><div class="line">    }</div><div class="line">});</div></div><!-- fragment --><p>Do note, that this will only affect the document that is currently being created. All other documents will use the defaults specified below (see: Default Features).</p>
<ol type="1">
<li>Before creating any documents, you can modify the defaults for all future documents:</li>
</ol>
<div class="fragment"><div class="line">require(&quot;jsdom&quot;).defaultDocumentFeatures = {</div><div class="line">    FetchExternalResources: [&quot;script&quot;],</div><div class="line">    ProcessExternalResources: false</div><div class="line">};</div></div><!-- fragment --><h4>External Resources</h4>
<p>Default features are extremely important for jsdom as they lower the configuration requirement and present developers a set of consistent default behaviors. The following sections detail the available features, their defaults, and the values that jsdom uses.</p>
<p><code>FetchExternalResources</code></p>
<ul>
<li><em>Default</em>: <code>["script", "link"]</code></li>
<li><em>Allowed</em>: <code>["script", "frame", "iframe", "link", "img"]</code> or <code>false</code></li>
<li><em>Default for <code>jsdom.env</code></em>: <code>false</code></li>
</ul>
<p>Enables/disables fetching files over the file system/HTTP</p>
<p><code>ProcessExternalResources</code></p>
<ul>
<li><em>Default</em>: <code>["script"]</code></li>
<li><em>Allowed</em>: <code>["script"]</code> or <code>false</code></li>
<li><em>Default for <code>jsdom.env</code></em>: <code>false</code></li>
</ul>
<p>Enables/disables JavaScript execution</p>
<p><code>SkipExternalResources</code></p>
<ul>
<li><em>Default</em>: <code>false</code> (allow all)</li>
<li><em>Allowed</em>: <code>/url to be skipped/</code> or <code>false</code></li>
<li><em>Example</em>: <code>/http:\/\/example.org/js/bad\.js/</code></li>
</ul>
<p>Filters resource downloading and processing to disallow those matching the given regular expression</p>
<h4>Custom External Resource Loader</h4>
<p>jsdom lets you intercept subresource requests using <code>config.resourceLoader</code>. <code>config.resourceLoader</code> expects a function which is called for each subresource request with the following arguments:</p>
<ul>
<li><code>resource</code>: a vanilla JavaScript object with the following properties<ul>
<li><code>element</code>: the element that requested the resource.</li>
<li><code>url</code>: a parsed <a class="el" href="namespace_u_r_l.html">URL</a> object.</li>
<li><code>cookie</code>: the content of the HTTP cookie header (<code>key=value</code> pairs separated by semicolons).</li>
<li><code>baseUrl</code>: the base <a class="el" href="namespace_u_r_l.html">URL</a> used to resolve relative URLs.</li>
<li><code>defaultFetch(callback)</code>: a convenience method to fetch the resource online.</li>
</ul>
</li>
<li><code>callback</code>: a function to be called with two arguments<ul>
<li><code>error</code>: either <code>null</code>, if nothing goes wrong, or an <code>Error</code> object.</li>
<li><code>body</code>: a string representing the body of the resource.</li>
</ul>
</li>
</ul>
<p>For example, fetching all JS files from a different directory and running them in strict mode:</p>
<div class="fragment"><div class="line">var jsdom = require(&quot;jsdom&quot;);</div><div class="line"></div><div class="line">jsdom.env({</div><div class="line">  url: &quot;http://example.com/&quot;,</div><div class="line">  resourceLoader: function (resource, callback) {</div><div class="line">    var pathname = resource.url.pathname;</div><div class="line">    if (/\.js$/.test(pathname)) {</div><div class="line">      resource.url.pathname = pathname.replace(&quot;/js/&quot;, &quot;/js/raw/&quot;);</div><div class="line">      return resource.defaultFetch(function (err, body) {</div><div class="line">        if (err) return callback(err);</div><div class="line">        callback(null, &#39;&quot;use strict&quot;;\n&#39; + body);</div><div class="line">      });</div><div class="line">    } else {</div><div class="line">      return resource.defaultFetch(callback);</div><div class="line">    }</div><div class="line">  },</div><div class="line">  features: {</div><div class="line">    FetchExternalResources: [&quot;script&quot;],</div><div class="line">    ProcessExternalResources: [&quot;script&quot;],</div><div class="line">    SkipExternalResources: false</div><div class="line">  }</div><div class="line">});</div></div><!-- fragment --><p>You can return an object containing an <code>abort()</code> function which will be called if the window is closed or stopped before the request ends. The <code>abort()</code> function should stop the request and call the callback with an error.</p>
<p>For example, simulating a long request:</p>
<div class="fragment"><div class="line">var jsdom = require(&quot;jsdom&quot;);</div><div class="line"></div><div class="line">jsdom.env({</div><div class="line">  url: &quot;http://example.com/&quot;,</div><div class="line">  resourceLoader: function (resource, callback) {</div><div class="line">    var pathname = resource.url.pathname;</div><div class="line">    if (/\.json$/.test(pathname)) {</div><div class="line">      var timeout = setTimeout(function() {</div><div class="line">        callback(null, &quot;{\&quot;test\&quot;:\&quot;test\&quot;}&quot;);</div><div class="line">      }, 10000);</div><div class="line">      return {</div><div class="line">        abort: function() {</div><div class="line">          clearTimeout(timeout);</div><div class="line">          callback(new Error(&quot;request canceled by user&quot;));</div><div class="line">        }</div><div class="line">      };</div><div class="line">    } else {</div><div class="line">      return resource.defaultFetch(callback);</div><div class="line">    }</div><div class="line">  },</div><div class="line">  features: {</div><div class="line">    FetchExternalResources: [&quot;script&quot;],</div><div class="line">    ProcessExternalResources: [&quot;script&quot;],</div><div class="line">    SkipExternalResources: false</div><div class="line">  }</div><div class="line">});</div></div><!-- fragment --><h2>Canvas</h2>
<p>jsdom includes support for using the <a href="https://npmjs.org/package/canvas">canvas</a> or <a href="https://npmjs.org/package/canvas-prebuilt">canvas-prebuilt</a> package to extend any <code>&lt;canvas&gt;</code> elements with the canvas API. To make this work, you need to include canvas as a dependency in your project, as a peer of jsdom. If jsdom can find the canvas package, it will use it, but if it's not present, then <code>&lt;canvas&gt;</code> elements will behave like <code>&lt;div&gt;</code>s.</p>
<h2>More Examples</h2>
<h3>Creating a browser-like window object</h3>
<div class="fragment"><div class="line">var jsdom = require(&quot;jsdom&quot;).jsdom;</div><div class="line">var document = jsdom(&quot;hello world&quot;);</div><div class="line">var window = document.defaultView;</div><div class="line"></div><div class="line">console.log(window.document.documentElement.outerHTML);</div><div class="line">// output: &quot;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;hello world&lt;/body&gt;&lt;/html&gt;&quot;</div><div class="line"></div><div class="line">console.log(window.innerWidth);</div><div class="line">// output: 1024</div><div class="line"></div><div class="line">console.log(typeof window.document.getElementsByClassName);</div><div class="line">// outputs: function</div></div><!-- fragment --><h3>jQueryify</h3>
<div class="fragment"><div class="line">var jsdom = require(&quot;jsdom&quot;);</div><div class="line">var window = jsdom.jsdom().defaultView;</div><div class="line"></div><div class="line">jsdom.jQueryify(window, &quot;http://code.jquery.com/jquery-2.1.1.js&quot;, function () {</div><div class="line">  window.$(&quot;body&quot;).append(&#39;&lt;div class=&quot;testing&quot;&gt;Hello World, It works&lt;/div&gt;&#39;);</div><div class="line"></div><div class="line">  console.log(window.$(&quot;.testing&quot;).text());</div><div class="line">});</div></div><!-- fragment --><h3>Passing objects to scripts inside the page</h3>
<div class="fragment"><div class="line">var jsdom = require(&quot;jsdom&quot;).jsdom;</div><div class="line">var window = jsdom().defaultView;</div><div class="line"></div><div class="line">window.__myObject = { foo: &quot;bar&quot; };</div><div class="line"></div><div class="line">var scriptEl = window.document.createElement(&quot;script&quot;);</div><div class="line">scriptEl.src = &quot;anotherScript.js&quot;;</div><div class="line">window.document.body.appendChild(scriptEl);</div><div class="line"></div><div class="line">// anotherScript.js will have the ability to read `window.__myObject`, even</div><div class="line">// though it originated in Node.js!</div></div><!-- fragment --><h3>Shimming unimplemented APIs</h3>
<div class="fragment"><div class="line">var jsdom = require(&quot;jsdom&quot;);</div><div class="line">var document = jsdom(&quot;&quot;, {</div><div class="line">  created(err, window) {</div><div class="line">    window.alert = () =&gt; {</div><div class="line">      // Do something different than jsdom&#39;s default &quot;not implemented&quot; virtual console error</div><div class="line">    };</div><div class="line"></div><div class="line">    Object.defineProperty(window, &quot;outerWidth&quot;, {</div><div class="line">      get() { return 400; },</div><div class="line">      enumerable: true,</div><div class="line">      configurable: true</div><div class="line">    });</div><div class="line">  }</div><div class="line">});</div></div><!-- fragment --><h3>Serializing a document</h3>
<div class="fragment"><div class="line">var jsdom = require(&quot;jsdom&quot;).jsdom;</div><div class="line">var serializeDocument = require(&quot;jsdom&quot;).serializeDocument;</div><div class="line"></div><div class="line">var doc = jsdom(&quot;&lt;!DOCTYPE html&gt;hello&quot;);</div><div class="line"></div><div class="line">serializeDocument(doc) === &quot;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;hello&lt;/body&gt;&lt;/html&gt;&quot;;</div><div class="line">doc.documentElement.outerHTML === &quot;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;hello&lt;/body&gt;&lt;/html&gt;&quot;;</div></div><!-- fragment --><h3>Sharing cookie state among pages</h3>
<div class="fragment"><div class="line">var jsdom = require(&quot;jsdom&quot;);</div><div class="line">var cookieJar = jsdom.createCookieJar();</div><div class="line"></div><div class="line">jsdom.env({</div><div class="line">    url: &#39;http://google.com&#39;,</div><div class="line">    cookieJar: cookieJar,</div><div class="line">    done: function (err1, window1) {</div><div class="line">        //...</div><div class="line"></div><div class="line">        jsdom.env({</div><div class="line">            url: &#39;http://code.google.com&#39;,</div><div class="line">            cookieJar: cookieJar,</div><div class="line">            done: function (err2, window2) {</div><div class="line">                //...</div><div class="line">            }</div><div class="line">        });</div><div class="line">    }</div><div class="line">});</div></div><!-- fragment --><h3>Capturing Console Output</h3>
<h4>Forward a window's console output to the Node.js console</h4>
<div class="fragment"><div class="line">var jsdom = require(&quot;jsdom&quot;);</div><div class="line"></div><div class="line">var document = jsdom.jsdom(undefined, {</div><div class="line">  virtualConsole: jsdom.createVirtualConsole().sendTo(console)</div><div class="line">});</div></div><!-- fragment --><p>By default this will forward all <code>"jsdomError"</code> events to <code>console.error</code>. If you want to maintain only a strict one-to-one mapping of events to method calls, and perhaps handle <code>"jsdomErrors"</code> yourself, then you can do <code>sendTo(console, { omitJsdomErrors: true })</code>.</p>
<h4>Create an event emitter for a window's console</h4>
<div class="fragment"><div class="line">var jsdom = require(&quot;jsdom&quot;);</div><div class="line"></div><div class="line">var virtualConsole = jsdom.createVirtualConsole();</div><div class="line"></div><div class="line">virtualConsole.on(&quot;log&quot;, function (message) {</div><div class="line">  console.log(&quot;console.log called -&gt;&quot;, message);</div><div class="line">});</div><div class="line"></div><div class="line">var document = jsdom.jsdom(undefined, {</div><div class="line">  virtualConsole: virtualConsole</div><div class="line">});</div></div><!-- fragment --><p>Post-initialization, if you didn't pass in a <code>virtualConsole</code> or no longer have a reference to it, you can retrieve the <code>virtualConsole</code> by using:</p>
<div class="fragment"><div class="line">var virtualConsole = jsdom.getVirtualConsole(window);</div></div><!-- fragment --><h4>Virtual console <code>jsdomError</code> error reporting</h4>
<p>Besides the usual events, corresponding to <code>console</code> methods, the virtual console is also used for reporting errors from jsdom itself. This is similar to how error messages often show up in web browser consoles, even if they are not initiated by <code>console.error</code>. So far, the following errors are output this way:</p>
<ul>
<li>Errors loading or parsing external resources (scripts, stylesheets, frames, and iframes)</li>
<li>Script execution errors that are not handled by a window <code>onerror</code> event handler that returns <code>true</code> or calls <code>event.preventDefault()</code></li>
<li>Calls to methods, like <code>window.alert</code>, which jsdom does not implement, but installs anyway for web compatibility</li>
</ul>
<h3>Getting a node's location within the source</h3>
<p>To find where a DOM node is within the source document, we provide the <code>jsdom.nodeLocation</code> function:</p>
<div class="fragment"><div class="line">var jsdom = require(&quot;jsdom&quot;);</div><div class="line"></div><div class="line">var document = jsdom.jsdom(`&lt;p&gt;Hello</div><div class="line">    &lt;img src=&quot;foo.jpg&quot;&gt;</div><div class="line">  &lt;/p&gt;`);</div><div class="line"></div><div class="line">var bodyEl = document.body; // implicitly created</div><div class="line">var pEl = document.querySelector(&quot;p&quot;);</div><div class="line">var textNode = pEl.firstChild;</div><div class="line">var imgEl = document.querySelector(&quot;img&quot;);</div><div class="line"></div><div class="line">console.log(jsdom.nodeLocation(bodyEl));   // null; it&#39;s not in the source</div><div class="line">console.log(jsdom.nodeLocation(pEl));      // { start: 0, end: 39, startTag: ..., endTag: ... }</div><div class="line">console.log(jsdom.nodeLocation(textNode)); // { start: 3, end: 13 }</div><div class="line">console.log(jsdom.nodeLocation(imgEl));    // { start: 13, end: 32 }</div></div><!-- fragment --><p>This returns the <a href="https://www.npmjs.com/package/parse5#options-locationinfo">parse5 location info</a> for the node.</p>
<h4>Overriding <code>window.top</code></h4>
<p>The <code>top</code> property on <code>window</code> is marked <code>[Unforgeable]</code> in the spec, meaning it is a non-configurable own property and thus cannot be overridden or shadowed by normal code running inside the jsdom window, even using <code>Object.defineProperty</code>. However, if you're acting from outside the window, e.g. in some test framework that creates jsdom instances, you can override it using the special <code>jsdom.reconfigureWindow</code> function:</p>
<div class="fragment"><div class="line">jsdom.reconfigureWindow(window, { top: myFakeTopForTesting });</div></div><!-- fragment --><p>In the future we may expand <code>reconfigureWindow</code> to allow overriding other <code>[Unforgeable]</code> properties. Let us know if you need this capability.</p>
<h4>Changing the <a class="el" href="namespace_u_r_l.html">URL</a> of an existing jsdom <code>Window</code> instance</h4>
<p>At present jsdom does not handle navigation (such as setting <code>window.location.href === "https://example.com/"</code>). However, if you'd like to change the <a class="el" href="namespace_u_r_l.html">URL</a> of an existing <code>Window</code> instance (such as for testing purposes), you can use the <code>jsdom.changeURL</code> method:</p>
<div class="fragment"><div class="line">jsdom.changeURL(window, &quot;https://example.com/&quot;);</div></div><!-- fragment --><h4>Running vm scripts</h4>
<p>Although in most cases it's simplest to just insert a <code>&lt;script&gt;</code> element or call <code>window.eval</code>, in some cases you want access to the raw <a href="https://nodejs.org/api/vm.html">vm context</a> underlying jsdom to run scripts. You can do that like so:</p>
<div class="fragment"><div class="line">const script = new vm.Script(&quot;globalVariable = 5;&quot;, { filename: &quot;test.js&quot; });</div><div class="line">jsdom.evalVMScript(window, script);</div></div><!-- fragment --><h2>jsdom vs. PhantomJS</h2>
<p>Some people wonder what the differences are between jsdom and <a href="http://phantomjs.org/">PhantomJS</a>, and when you would use one over the other. Here we attempt to explain some of the differences, and why we find jsdom to be a pleasure to use for testing and scraping use cases.</p>
<p>PhantomJS is a complete browser (although it uses a very old and rare rendering engine). It even performs layout and rendering, allowing you to query element positions or take a screenshot. jsdom is not a full browser: it does not perform layout or rendering, and it does not support navigation between pages. It <em>does</em> support the DOM, HTML, canvas, many other web platform APIs, and running scripts.</p>
<p>So you could use jsdom to fetch the HTML of your web application (while also executing the JavaScript code within that HTML). And then you could examine and modify the resulting DOM tree. Or you could trigger event listeners to test how the web application reacts. You could also use jsdom to build up your own DOM tree from scratch, and then serialize it to a HTML string.</p>
<p>You need an executable to run PhantomJS. It is written in native code, and has to be compiled for each platform. jsdom is pure JavaScript, and runs wherever Node.js runs. It even has experimental support for running within browsers, giving you the ability to create a whole DOM Document inside a web worker.</p>
<p>One of the reasons jsdom is used a lot for testing is that creating a new document instance has very little overhead in jsdom. Opening a new page in PhantomJS takes a lot of time, so running a lot of small tests in fresh documents could take minutes in PhantomJS, but only seconds in jsdom.</p>
<p>Another important benefit jsdom has for testing is a bit more complicated: it is easy to suffer race conditions using an external process like PhantomJS (or Selenium). For example if you create a script to test something using PhantomJS, that script will live in a different process than the web application. If you perform multiple steps in your test that are dependent on each other (for example, step 1: find the element; step 2: click on the element), the application might change the DOM during those steps (step 1.5: the page's JavaScript removes the element). This is not an issue in jsdom, since your tests live in exactly the same thread and event loop as the web application, so if your test is executing JavaScript code, the web application cannot run its code until your test releases control of the event loop.</p>
<p>In general the same reasons that make jsdom pleasant for testing also make it pleasant for web scraping. In both cases, the extra power of a full browser is not as important as getting things done easily and quickly.</p>
<h2>What Standards Does jsdom Support, Exactly?</h2>
<p>Our mission is to get something very close to a headless browser, with emphasis more on the DOM/HTML side of things than the CSS side. As such, our primary goals are supporting <a href="http://dom.spec.whatwg.org/">The DOM Standard</a> and <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/">The HTML Standard</a>. We only support some subset of these so far; in particular we have the subset covered by the outdated DOM 2 spec family down pretty well. We're slowly including more and more from the modern DOM and HTML specs, including some <code>Node</code> APIs, <code>querySelector(All)</code>, attribute semantics, the history and <a class="el" href="namespace_u_r_l.html">URL</a> APIs, and the HTML parsing algorithm.</p>
<p>We also support some subset of the <a href="http://dev.w3.org/csswg/cssom/">CSSOM</a>, largely via <a href="https://github.com/chad3814"></a>'s excellent <a href="https://www.npmjs.org/package/cssstyle">cssstyle</a> package. In general we want to make webpages run headlessly as best we can, and if there are other specs we should be incorporating, let us know.</p>
<h3>Supported encodings</h3>
<p>The supported encodings are the ones listed <a href="https://encoding.spec.whatwg.org/#names-and-labels">in the Encoding Standard</a> excluding these:</p>
<ul>
<li>ISO-8859-8-I</li>
<li>x-mac-cyrillic</li>
<li>ISO-2022-JP</li>
<li>replacement</li>
<li>x-user-defined </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者 &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
