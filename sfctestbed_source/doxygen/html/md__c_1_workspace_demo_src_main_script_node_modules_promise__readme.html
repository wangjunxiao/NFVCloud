<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>demo: Readme</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">demo
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">Vfunc Spring Boot项目概要</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Readme </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://promisesaplus.com/"></a> </p><h1>promise</h1>
<p>This is a simple implementation of Promises. It is a super set of ES6 Promises designed to have readable, performant code and to provide just the extensions that are absolutely necessary for using promises today.</p>
<p>For detailed tutorials on its use, see www.promisejs.org</p>
<p><b>N.B.</b> This promise exposes internals via underscore (<code>_</code>) prefixed properties. If you use these, your code will break with each new release.</p>
<p><a href="https://travis-ci.org/then/promise"></a> <a href="https://gemnasium.com/then/promise"></a> <a href="https://npmjs.org/package/promise"></a> <a href="https://npmjs.org/package/promise"></a></p>
<h2>Installation</h2>
<p><b>Server:</b> </p><pre class="fragment">$ npm install promise
</pre><p><b>Client:</b></p>
<p>You can use browserify on the client, or use the pre-compiled script that acts as a polyfill.</p>
<div class="fragment"><div class="line">&lt;script src=&quot;https://www.promisejs.org/polyfills/promise-6.1.0.js&quot;&gt;&lt;/script&gt;</div></div><!-- fragment --><p>Note that the <a href="https://github.com/es-shims/es5-shim">es5-shim</a> must be loaded before this library to support browsers pre IE9.</p>
<div class="fragment"><div class="line">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/es5-shim/3.4.0/es5-shim.min.js&quot;&gt;&lt;/script&gt;</div></div><!-- fragment --><h2>Usage</h2>
<p>The example below shows how you can load the promise library (in a way that works on both client and server using node or browserify). It then demonstrates creating a promise from scratch. You simply call <code>new Promise(fn)</code>. There is a complete specification for what is returned by this method in <a href="http://promises-aplus.github.com/promises-spec/">Promises/A+</a>.</p>
<div class="fragment"><div class="line">var Promise = require(&#39;promise&#39;);</div><div class="line"></div><div class="line">var promise = new Promise(function (resolve, reject) {</div><div class="line">  get(&#39;http://www.google.com&#39;, function (err, res) {</div><div class="line">    if (err) reject(err);</div><div class="line">    else resolve(res);</div><div class="line">  });</div><div class="line">});</div></div><!-- fragment --><p>If you need <a href="https://iojs.org/api/domain.html">domains</a> support, you should instead use:</p>
<div class="fragment"><div class="line">var Promise = require(&#39;promise/domains&#39;);</div></div><!-- fragment --><p>If you are in an environment that implements <code>setImmediate</code> and don't want the optimisations provided by asap, you can use:</p>
<div class="fragment"><div class="line">var Promise = require(&#39;promise/setimmediate&#39;);</div></div><!-- fragment --><p>If you only want part of the features, e.g. just a pure ES6 polyfill:</p>
<div class="fragment"><div class="line">var Promise = require(&#39;promise/lib/es6-extensions&#39;);</div><div class="line">// or require(&#39;promise/domains/es6-extensions&#39;);</div><div class="line">// or require(&#39;promise/setimmediate/es6-extensions&#39;);</div></div><!-- fragment --><h2>Unhandled Rejections</h2>
<p>By default, promises silence any unhandled rejections.</p>
<p>You can enable logging of unhandled ReferenceErrors and TypeErrors via:</p>
<div class="fragment"><div class="line">require(&#39;promise/lib/rejection-tracking&#39;).enable();</div></div><!-- fragment --><p>Due to the performance cost, you should only do this during development.</p>
<p>You can enable logging of all unhandled rejections if you need to debug an exception you think is being swallowed by promises:</p>
<div class="fragment"><div class="line">require(&#39;promise/lib/rejection-tracking&#39;).enable(</div><div class="line">  {allRejections: true}</div><div class="line">);</div></div><!-- fragment --><p>Due to the high probability of false positives, I only recommend using this when debugging specific issues that you think may be being swallowed. For the preferred debugging method, see <code>Promise::done(onFulfilled, onRejected)</code>.</p>
<p><code>rejection-tracking.enable(options)</code> takes the following options:</p>
<ul>
<li>allRejections (<code>boolean</code>) - track all exceptions, not just reference errors and type errors. Note that this has a high probability of resulting in false positives if your code loads data optimisticly</li>
<li>whitelist (<code>Array&lt;ErrorConstructor&gt;</code>) - this defaults to <code>[ReferenceError, TypeError]</code> but you can override it with your own list of error constructors to track.</li>
<li><code>onUnhandled(id, error)</code> and <code>onHandled(id, error)</code> - you can use these to provide your own customised display for errors. Note that if possible you should indicate that the error was a false positive if <code>onHandled</code> is called. <code>onHandled</code> is only called if <code>onUnhandled</code> has already been called.</li>
</ul>
<p>To reduce the chance of false-positives there is a delay of up to 2 seconds before errors are logged. This means that if you attach an error handler within 2 seconds, it won't be logged as a false positive. ReferenceErrors and TypeErrors are only subject to a 100ms delay due to the higher likelihood that the error is due to programmer error.</p>
<h2>API</h2>
<p>Before all examples, you will need:</p>
<div class="fragment"><div class="line">var Promise = require(&#39;promise&#39;);</div></div><!-- fragment --><h3>new Promise(resolver)</h3>
<p>This creates and returns a new promise. <code>resolver</code> must be a function. The <code>resolver</code> function is passed two arguments:</p>
<ol type="1">
<li><code>resolve</code> should be called with a single argument. If it is called with a non-promise value then the promise is fulfilled with that value. If it is called with a promise (A) then the returned promise takes on the state of that new promise (A).</li>
<li><code>reject</code> should be called with a single argument. The returned promise will be rejected with that argument.</li>
</ol>
<h3>Static Functions</h3>
<p>These methods are invoked by calling <code>Promise.methodName</code>.</p>
<h4>Promise.resolve(value)</h4>
<p>(deprecated aliases: <code>Promise.from(value)</code>, <code>Promise.cast(value)</code>)</p>
<p>Converts values and foreign promises into Promises/A+ promises. If you pass it a value then it returns a Promise for that value. If you pass it something that is close to a promise (such as a jQuery attempt at a promise) it returns a Promise that takes on the state of <code>value</code> (rejected or fulfilled).</p>
<h4>Promise.reject(value)</h4>
<p>Returns a rejected promise with the given value.</p>
<h4>Promise.all(array)</h4>
<p>Returns a promise for an array. If it is called with a single argument that <code>Array.isArray</code> then this returns a promise for a copy of that array with any promises replaced by their fulfilled values. e.g.</p>
<div class="fragment"><div class="line">Promise.all([Promise.resolve(&#39;a&#39;), &#39;b&#39;, Promise.resolve(&#39;c&#39;)])</div><div class="line">  .then(function (res) {</div><div class="line">    assert(res[0] === &#39;a&#39;)</div><div class="line">    assert(res[1] === &#39;b&#39;)</div><div class="line">    assert(res[2] === &#39;c&#39;)</div><div class="line">  })</div></div><!-- fragment --><h4>Promise.denodeify(fn)</h4>
<p><em>Non Standard</em></p>
<p>Takes a function which accepts a node style callback and returns a new function that returns a promise instead.</p>
<p>e.g.</p>
<div class="fragment"><div class="line">var fs = require(&#39;fs&#39;)</div><div class="line"></div><div class="line">var read = Promise.denodeify(fs.readFile)</div><div class="line">var write = Promise.denodeify(fs.writeFile)</div><div class="line"></div><div class="line">var p = read(&#39;foo.json&#39;, &#39;utf8&#39;)</div><div class="line">  .then(function (str) {</div><div class="line">    return write(&#39;foo.json&#39;, JSON.stringify(JSON.parse(str), null, &#39;  &#39;), &#39;utf8&#39;)</div><div class="line">  })</div></div><!-- fragment --><h4>Promise.nodeify(fn)</h4>
<p><em>Non Standard</em></p>
<p>The twin to <code>denodeify</code> is useful when you want to export an API that can be used by people who haven't learnt about the brilliance of promises yet.</p>
<div class="fragment"><div class="line">module.exports = Promise.nodeify(awesomeAPI)</div><div class="line">function awesomeAPI(a, b) {</div><div class="line">  return download(a, b)</div><div class="line">}</div></div><!-- fragment --><p>If the last argument passed to <code>module.exports</code> is a function, then it will be treated like a node.js callback and not parsed on to the child function, otherwise the API will just return a promise.</p>
<h3>Prototype Methods</h3>
<p>These methods are invoked on a promise instance by calling <code>myPromise.methodName</code></p>
<h3>Promise::then(onFulfilled, onRejected)</h3>
<p>This method follows the <a href="http://promises-aplus.github.io/promises-spec/">Promises/A+ spec</a>. It explains things very clearly so I recommend you read it.</p>
<p>Either <code>onFulfilled</code> or <code>onRejected</code> will be called and they will not be called more than once. They will be passed a single argument and will always be called asynchronously (in the next turn of the event loop).</p>
<p>If the promise is fulfilled then <code>onFulfilled</code> is called. If the promise is rejected then <code>onRejected</code> is called.</p>
<p>The call to <code>.then</code> also returns a promise. If the handler that is called returns a promise, the promise returned by <code>.then</code> takes on the state of that returned promise. If the handler that is called returns a value that is not a promise, the promise returned by <code>.then</code> will be fulfilled with that value. If the handler that is called throws an exception then the promise returned by <code>.then</code> is rejected with that exception.</p>
<h4>Promise::catch(onRejected)</h4>
<p>Sugar for <code>Promise::then(null, onRejected)</code>, to mirror <code>catch</code> in synchronous code.</p>
<h4>Promise::done(onFulfilled, onRejected)</h4>
<p><em>Non Standard</em></p>
<p>The same semantics as <code>.then</code> except that it does not return a promise and any exceptions are re-thrown so that they can be logged (crashing the application in non-browser environments)</p>
<h4>Promise::nodeify(callback)</h4>
<p><em>Non Standard</em></p>
<p>If <code>callback</code> is <code>null</code> or <code>undefined</code> it just returns <code>this</code>. If <code>callback</code> is a function it is called with rejection reason as the first argument and result as the second argument (as per the node.js convention).</p>
<p>This lets you write API functions that look like:</p>
<div class="fragment"><div class="line">function awesomeAPI(foo, bar, callback) {</div><div class="line">  return internalAPI(foo, bar)</div><div class="line">    .then(parseResult)</div><div class="line">    .then(null, retryErrors)</div><div class="line">    .nodeify(callback)</div><div class="line">}</div></div><!-- fragment --><p>People who use typical node.js style callbacks will be able to just pass a callback and get the expected behavior. The enlightened people can not pass a callback and will get awesome promises.</p>
<h2>License</h2>
<p>MIT </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者 &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
