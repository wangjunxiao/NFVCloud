<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>demo: private [![Build Status](https://travis-ci.org/benjamn/private.png?branch=master)](https://travis-ci.org/benjamn/private)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">demo
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">Vfunc Spring Boot项目概要</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">private [![Build Status](<a href="https://travis-ci.org/benjamn/private.png?branch=master">https://travis-ci.org/benjamn/private.png?branch=master</a>)](<a href="https://travis-ci.org/benjamn/private">https://travis-ci.org/benjamn/private</a>) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A general-purpose utility for associating truly private state with any JavaScript object.</p>
<h2>Installation </h2>
<p>From NPM: </p><pre class="fragment">npm install private
</pre><p>From GitHub: </p><pre class="fragment">cd path/to/node_modules
git clone git://github.com/benjamn/private.git
cd private
npm install .
</pre><h2>Usage </h2>
<p><b>Get or create a secret object associated with any (non-frozen) object:</b> </p><div class="fragment"><div class="line">var getSecret = require(&quot;private&quot;).makeAccessor();</div><div class="line">var obj = Object.create(null); // any kind of object works</div><div class="line">getSecret(obj).totallySafeProperty = &quot;p455w0rd&quot;;</div><div class="line"></div><div class="line">console.log(Object.keys(obj)); // []</div><div class="line">console.log(Object.getOwnPropertyNames(obj)); // []</div><div class="line">console.log(getSecret(obj)); // { totallySafeProperty: &quot;p455w0rd&quot; }</div></div><!-- fragment --><p> Now, only code that has a reference to both <code>getSecret</code> and <code>obj</code> can possibly access <code>.totallySafeProperty</code>.</p>
<p><em>Importantly, no global references to the secret object are retained by the <code>private</code> package, so as soon as <code>obj</code> gets garbage collected, the secret will be reclaimed as well. In other words, you don't have to worry about memory leaks.</em></p>
<p><b>Create a unique property name that cannot be enumerated or guessed:</b> </p><div class="fragment"><div class="line">var secretKey = require(&quot;private&quot;).makeUniqueKey();</div><div class="line">var obj = Object.create(null); // any kind of object works</div><div class="line"></div><div class="line">Object.defineProperty(obj, secretKey, {</div><div class="line">  value: { totallySafeProperty: &quot;p455w0rd&quot; },</div><div class="line">  enumerable: false // optional; non-enumerability is the default</div><div class="line">});</div><div class="line"></div><div class="line">Object.defineProperty(obj, &quot;nonEnumerableProperty&quot;, {</div><div class="line">  value: &quot;anyone can guess my name&quot;,</div><div class="line">  enumerable: false</div><div class="line">});</div><div class="line"></div><div class="line">console.log(obj[secretKey].totallySafeProperty); // p455w0rd</div><div class="line">console.log(obj.nonEnumerableProperty); // &quot;anyone can guess my name&quot;</div><div class="line">console.log(Object.keys(obj)); // []</div><div class="line">console.log(Object.getOwnPropertyNames(obj)); // [&quot;nonEnumerableProperty&quot;]</div><div class="line"></div><div class="line">for (var key in obj) {</div><div class="line">  console.log(key); // never called</div><div class="line">}</div></div><!-- fragment --><p> Because these keys are non-enumerable, you can't discover them using a <code>for</code>-<code>in</code> loop. Because <code>secretKey</code> is a long string of random characters, you would have a lot of trouble guessing it. And because the <code>private</code> module wraps <code>Object.getOwnPropertyNames</code> to exclude the keys it generates, you can't even use that interface to discover it.</p>
<p>Unless you have access to the value of the <code>secretKey</code> property name, there is no way to access the value associated with it. So your only responsibility as secret-keeper is to avoid handing out the value of <code>secretKey</code> to untrusted code.</p>
<p>Think of this style as a home-grown version of the first style. Note, however, that it requires a full implementation of ES5's <code>Object.defineProperty</code> method in order to make any safety guarantees, whereas the first example will provide safety even in environments that do not support <code>Object.defineProperty</code>.</p>
<h2>Rationale </h2>
<p>In JavaScript, the only data that are truly private are local variables whose values do not <em>leak</em> from the scope in which they were defined.</p>
<p>This notion of <em>closure privacy</em> is powerful, and it readily provides some of the benefits of traditional data privacy, a la Java or C++: </p><div class="fragment"><div class="line">function MyClass(secret) {</div><div class="line">    this.increment = function() {</div><div class="line">        return ++secret;</div><div class="line">    };</div><div class="line">}</div><div class="line"></div><div class="line">var mc = new MyClass(3);</div><div class="line">console.log(mc.increment()); // 4</div></div><!-- fragment --><p> You can learn something about <code>secret</code> by calling <code>.increment()</code>, and you can increase its value by one as many times as you like, but you can never decrease its value, because it is completely inaccessible except through the <code>.increment</code> method. And if the <code>.increment</code> method were not available, it would be as if no <code>secret</code> variable had ever been declared, as far as you could tell.</p>
<p>This style breaks down as soon as you want to inherit methods from the prototype of a class: </p><div class="fragment"><div class="line">function MyClass(secret) {</div><div class="line">    this.secret = secret;</div><div class="line">}</div><div class="line"></div><div class="line">MyClass.prototype.increment = function() {</div><div class="line">    return ++this.secret;</div><div class="line">};</div></div><!-- fragment --><p> The only way to communicate between the <code>MyClass</code> constructor and the <code>.increment</code> method in this example is to manipulate shared properties of <code>this</code>. Unfortunately <code>this.secret</code> is now exposed to unlicensed modification: </p><div class="fragment"><div class="line">var mc = new MyClass(6);</div><div class="line">console.log(mc.increment()); // 7</div><div class="line">mc.secret -= Infinity;</div><div class="line">console.log(mc.increment()); // -Infinity</div><div class="line">mc.secret = &quot;Go home JavaScript, you&#39;re drunk.&quot;;</div><div class="line">mc.increment(); // NaN</div></div><!-- fragment --><p> Another problem with closure privacy is that it only lends itself to per-instance privacy, whereas the <code>private</code> keyword in most object-oriented languages indicates that the data member in question is visible to all instances of the same class.</p>
<p>Suppose you have a <code>Node</code> class with a notion of parents and children: </p><div class="fragment"><div class="line">function Node() {</div><div class="line">    var parent;</div><div class="line">    var children = [];</div><div class="line"></div><div class="line">    this.getParent = function() {</div><div class="line">        return parent;</div><div class="line">    };</div><div class="line"></div><div class="line">    this.appendChild = function(child) {</div><div class="line">        children.push(child);</div><div class="line">        child.parent = this; // Can this be made to work?</div><div class="line">    };</div><div class="line">}</div></div><!-- fragment --><p> The desire here is to allow other <code>Node</code> objects to manipulate the value returned by <code>.getParent()</code>, but otherwise disallow any modification of the <code>parent</code> variable. You could expose a <code>.setParent</code> function, but then anyone could call it, and you might as well give up on the getter/setter pattern.</p>
<p>This module solves both of these problems.</p>
<h2>Usage </h2>
<p>Let's revisit the <code>Node</code> example from above: </p><div class="fragment"><div class="line">var p = require(&quot;private&quot;).makeAccessor();</div><div class="line"></div><div class="line">function Node() {</div><div class="line">    var privates = p(this);</div><div class="line">    var children = [];</div><div class="line"></div><div class="line">    this.getParent = function() {</div><div class="line">        return privates.parent;</div><div class="line">    };</div><div class="line"></div><div class="line">    this.appendChild = function(child) {</div><div class="line">        children.push(child);</div><div class="line">        var cp = p(child);</div><div class="line">        if (cp.parent)</div><div class="line">            cp.parent.removeChild(child);</div><div class="line">        cp.parent = this;</div><div class="line">        return child;</div><div class="line">    };</div><div class="line">}</div></div><!-- fragment --><p> Now, in order to access the private data of a <code>Node</code> object, you need to have access to the unique <code>p</code> function that is being used here. This is already an improvement over the previous example, because it allows restricted access by other <code>Node</code> instances, but can it help with the <code>Node.prototype</code> problem too?</p>
<p>Yes it can! </p><div class="fragment"><div class="line">var p = require(&quot;private&quot;).makeAccessor();</div><div class="line"></div><div class="line">function Node() {</div><div class="line">    p(this).children = [];</div><div class="line">}</div><div class="line"></div><div class="line">var Np = Node.prototype;</div><div class="line"></div><div class="line">Np.getParent = function() {</div><div class="line">    return p(this).parent;</div><div class="line">};</div><div class="line"></div><div class="line">Np.appendChild = function(child) {</div><div class="line">    p(this).children.push(child);</div><div class="line">    var cp = p(child);</div><div class="line">    if (cp.parent)</div><div class="line">        cp.parent.removeChild(child);</div><div class="line">    cp.parent = this;</div><div class="line">    return child;</div><div class="line">};</div></div><!-- fragment --><p> Because <code>p</code> is in scope not only within the <code>Node</code> constructor but also within <code>Node</code> methods, we can finally avoid redefining methods every time the <code>Node</code> constructor is called.</p>
<p>Now, you might be wondering how you can restrict access to <code>p</code> so that no untrusted code is able to call it. The answer is to use your favorite module pattern, be it CommonJS, AMD <code>define</code>, or even the old Immediately-Invoked Function Expression: </p><div class="fragment"><div class="line">var Node = (function() {</div><div class="line">    var p = require(&quot;private&quot;).makeAccessor();</div><div class="line"></div><div class="line">    function Node() {</div><div class="line">        p(this).children = [];</div><div class="line">    }</div><div class="line"></div><div class="line">    var Np = Node.prototype;</div><div class="line"></div><div class="line">    Np.getParent = function() {</div><div class="line">        return p(this).parent;</div><div class="line">    };</div><div class="line"></div><div class="line">    Np.appendChild = function(child) {</div><div class="line">        p(this).children.push(child);</div><div class="line">        var cp = p(child);</div><div class="line">        if (cp.parent)</div><div class="line">            cp.parent.removeChild(child);</div><div class="line">        cp.parent = this;</div><div class="line">        return child;</div><div class="line">    };</div><div class="line"></div><div class="line">    return Node;</div><div class="line">}());</div><div class="line"></div><div class="line">var parent = new Node;</div><div class="line">var child = new Node;</div><div class="line">parent.appendChild(child);</div><div class="line">assert.strictEqual(child.getParent(), parent);</div></div><!-- fragment --><p> Because this version of <code>p</code> never leaks from the enclosing function scope, only <code>Node</code> objects have access to it.</p>
<p>So, you see, the claim I made at the beginning of this README remains true:</p>
<blockquote class="doxtable">
<p>In JavaScript, the only data that are truly private are local variables whose values do not <em>leak</em> from the scope in which they were defined. </p>
</blockquote>
<p>It just so happens that closure privacy is sufficient to implement a privacy model similar to that provided by other languages. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者 &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
