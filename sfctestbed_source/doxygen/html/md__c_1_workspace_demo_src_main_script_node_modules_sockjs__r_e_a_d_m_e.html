<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>demo: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">demo
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">Vfunc Spring Boot项目概要</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">README </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="http://badge.fury.io/js/sockjs"></a></p>
<p>SockJS family:</p>
<ul>
<li><a href="https://github.com/sockjs/sockjs-client">SockJS-client</a> JavaScript client library</li>
<li><a href="https://github.com/sockjs/sockjs-node">SockJS-node</a> Node.js server</li>
<li><a href="https://github.com/sockjs/sockjs-erlang">SockJS-erlang</a> Erlang server</li>
<li><a href="https://github.com/MrJoes/sockjs-tornado">SockJS-tornado</a> Python/Tornado server</li>
<li><a href="https://github.com/eclipse/vert.x">vert.x</a> Java/vert.x server</li>
</ul>
<p>Work in progress:</p>
<ul>
<li><a href="https://github.com/nyarly/sockjs-ruby">SockJS-ruby</a></li>
<li><a href="https://github.com/cgbystrom/sockjs-netty">SockJS-netty</a></li>
<li><a href="https://github.com/sdiehl/sockjs-gevent">SockJS-gevent</a> (<a href="https://github.com/njoyce/sockjs-gevent">and a fork</a>)</li>
<li><a href="https://github.com/fafhrd91/pyramid_sockjs">pyramid-SockJS</a></li>
<li><a href="https://github.com/wildcloud/wildcloud-websockets">wildcloud-websockets</a></li>
<li><a href="https://github.com/flaviogrossi/sockjs-cyclone">SockJS-cyclone</a></li>
<li><a href="https://github.com/Fugiman/sockjs-twisted/">SockJS-twisted</a></li>
<li><a href="https://github.com/Palmik/wai-sockjs">wai-SockJS</a></li>
<li><a href="https://github.com/vti/sockjs-perl">SockJS-perl</a></li>
<li><a href="https://github.com/igm/sockjs-go/">SockJS-go</a></li>
</ul>
<h1>What is SockJS? </h1>
<p>SockJS is a JavaScript library (for browsers) that provides a WebSocket-like object. SockJS gives you a coherent, cross-browser, Javascript API which creates a low latency, full duplex, cross-domain communication channel between the browser and the web server, with WebSockets or without. This necessitates the use of a server, which this is one version of, for Node.js.</p>
<h1>SockJS-node server </h1>
<p>SockJS-node is a Node.js server side counterpart of <a href="https://github.com/sockjs/sockjs-client">SockJS-client browser library</a> written in CoffeeScript.</p>
<p>To install <code>sockjs-node</code> run: </p><pre class="fragment">npm install sockjs
</pre><p>A simplified echo SockJS server could look more or less like:</p>
<div class="fragment"><div class="line">var http = require(&#39;http&#39;);</div><div class="line">var sockjs = require(&#39;sockjs&#39;);</div><div class="line"></div><div class="line">var echo = sockjs.createServer({ sockjs_url: &#39;http://cdn.jsdelivr.net/sockjs/1.0.1/sockjs.min.js&#39; });</div><div class="line">echo.on(&#39;connection&#39;, function(conn) {</div><div class="line">    conn.on(&#39;data&#39;, function(message) {</div><div class="line">        conn.write(message);</div><div class="line">    });</div><div class="line">    conn.on(&#39;close&#39;, function() {});</div><div class="line">});</div><div class="line"></div><div class="line">var server = http.createServer();</div><div class="line">echo.installHandlers(server, {prefix:&#39;/echo&#39;});</div><div class="line">server.listen(9999, &#39;0.0.0.0&#39;);</div></div><!-- fragment --><p>(Take look at <a href="https://github.com/sockjs/sockjs-node/tree/master/examples/echo">examples</a> directory for a complete version.)</p>
<p>Subscribe to <a href="https://groups.google.com/forum/#!forum/sockjs">SockJS mailing list</a> for discussions and support.</p>
<h2>SockJS-node API </h2>
<p>The API design is based on the common Node API's like <a href="http://nodejs.org/docs/v0.5.8/api/streams.html">Streams API</a> or <a href="http://nodejs.org/docs/v0.5.8/api/http.html#http.Server">Http.Server API</a>.</p>
<h3>Server class</h3>
<p>SockJS module is generating a <code>Server</code> class, similar to <a href="http://nodejs.org/docs/v0.5.8/api/http.html#http.createServer">Node.js http.createServer</a> module.</p>
<div class="fragment"><div class="line">var sockjs_server = sockjs.createServer(options);</div></div><!-- fragment --><p>Where <code>options</code> is a hash which can contain:</p>
<dl>
<dt>sockjs_url (string, required) </dt>
<dd><p class="startdd">Transports which don't support cross-domain communication natively ('eventsource' to name one) use an iframe trick. A simple page is served from the SockJS server (using its foreign domain) and is placed in an invisible iframe. Code run from this iframe doesn't need to worry about cross-domain issues, as it's being run from domain local to the SockJS server. This iframe also does need to load SockJS javascript client library, and this option lets you specify its url (if you're unsure, point it to <a href="http://cdn.jsdelivr.net/sockjs/1.0.1/sockjs.min.js">the latest minified SockJS client release</a>, this is the default). You must explicitly specify this url on the server side for security reasons - we don't want the possibility of running any foreign javascript within the SockJS domain (aka cross site scripting attack). Also, sockjs javascript library is probably already cached by the browser - it makes sense to reuse the sockjs url you're using in normally.</p>
<p class="enddd"></p>
</dd>
<dt>prefix (string regex) </dt>
<dd><p class="startdd">A url prefix for the server. All http requests which paths begins with selected prefix will be handled by SockJS. All other requests will be passed through, to previously registered handlers.</p>
<p class="enddd"></p>
</dd>
<dt>response_limit (integer) </dt>
<dd><p class="startdd">Most streaming transports save responses on the client side and don't free memory used by delivered messages. Such transports need to be garbage-collected once in a while. <code>response_limit</code> sets a minimum number of bytes that can be send over a single http streaming request before it will be closed. After that client needs to open new request. Setting this value to one effectively disables streaming and will make streaming transports to behave like polling transports. The default value is 128K.</p>
<p class="enddd"></p>
</dd>
<dt>websocket (boolean) </dt>
<dd><p class="startdd">Some load balancers don't support websockets. This option can be used to disable websockets support by the server. By default websockets are enabled.</p>
<p class="enddd"></p>
</dd>
<dt>jsessionid (boolean or function) </dt>
<dd><p class="startdd">Some hosting providers enable sticky sessions only to requests that have JSESSIONID cookie set. This setting controls if the server should set this cookie to a dummy value. By default setting JSESSIONID cookie is disabled. More sophisticated behaviour can be achieved by supplying a function.</p>
<p class="enddd"></p>
</dd>
<dt>log (function(severity, message)) </dt>
<dd><p class="startdd">It's quite useful, especially for debugging, to see some messages printed by a SockJS-node library. This is done using this <code>log</code> function, which is by default set to <code>console.log</code>. If this behaviour annoys you for some reason, override <code>log</code> setting with a custom handler. The following <code>severities</code> are used: <code>debug</code> (miscellaneous logs), <code>info</code> (requests logs), <code>error</code> (serious errors, consider filing an issue).</p>
<p class="enddd"></p>
</dd>
<dt>heartbeat_delay (milliseconds) </dt>
<dd><p class="startdd">In order to keep proxies and load balancers from closing long running http requests we need to pretend that the connection is active and send a heartbeat packet once in a while. This setting controls how often this is done. By default a heartbeat packet is sent every 25 seconds. </p>
<p class="enddd"></p>
</dd>
<dt>disconnect_delay (milliseconds) </dt>
<dd>The server sends a <code>close</code> event when a client receiving connection have not been seen for a while. This delay is configured by this setting. By default the <code>close</code> event will be emitted when a receiving connection wasn't seen for 5 seconds.  </dd>
</dl>
<h3>Server instance</h3>
<p>Once you have create <code>Server</code> instance you can hook it to the <a href="http://nodejs.org/docs/v0.5.8/api/http.html#http.createServer">http.Server instance</a>.</p>
<div class="fragment"><div class="line">var http_server = http.createServer();</div><div class="line">sockjs_server.installHandlers(http_server, options);</div><div class="line">http_server.listen(...);</div></div><!-- fragment --><p>Where <code>options</code> can overshadow options given when creating <code>Server</code> instance.</p>
<p><code>Server</code> instance is an <a href="http://nodejs.org/docs/v0.4.10/api/events.html#events.EventEmitter">EventEmitter</a>, and emits following event:</p>
<dl>
<dt>Event: connection (connection) </dt>
<dd>A new connection has been successfully opened. </dd>
</dl>
<p>All http requests that don't go under the path selected by <code>prefix</code> will remain unanswered and will be passed to previously registered handlers. You must install your custom http handlers before calling <code>installHandlers</code>.</p>
<h3>Connection instance</h3>
<p>A <code>Connection</code> instance supports <a href="http://nodejs.org/docs/v0.5.8/api/streams.html">Node Stream API</a> and has following methods and properties:</p>
<dl>
<dt>Property: readable (boolean) </dt>
<dd><p class="startdd">Is the stream readable?</p>
<p class="enddd"></p>
</dd>
<dt>Property: writable (boolean) </dt>
<dd><p class="startdd">Is the stream writable?</p>
<p class="enddd"></p>
</dd>
<dt>Property: remoteAddress (string) </dt>
<dd><p class="startdd">Last known IP address of the client.</p>
<p class="enddd"></p>
</dd>
<dt>Property: remotePort (number) </dt>
<dd><p class="startdd">Last known port number of the client.</p>
<p class="enddd"></p>
</dd>
<dt>Property: address (object) </dt>
<dd><p class="startdd">Hash with 'address' and 'port' fields.</p>
<p class="enddd"></p>
</dd>
<dt>Property: headers (object) </dt>
<dd><p class="startdd">Hash containing various headers copied from last receiving request on that connection. Exposed headers include: <code>origin</code>, <code>referer</code> and <code>x-forwarded-for</code> (and friends). We explicitly do not grant access to <code>cookie</code> header, as using it may easily lead to security issues (for details read the section "Authorisation").</p>
<p class="enddd"></p>
</dd>
<dt>Property: url (string) </dt>
<dd><p class="startdd"><a href="http://nodejs.org/docs/v0.4.10/api/http.html#request.url">Url</a> property copied from last request.</p>
<p class="enddd"></p>
</dd>
<dt>Property: pathname (string) </dt>
<dd><p class="startdd"><code>pathname</code> from parsed url, for convenience.</p>
<p class="enddd"></p>
</dd>
<dt>Property: prefix (string) </dt>
<dd><p class="startdd">Prefix of the url on which the request was handled.</p>
<p class="enddd"></p>
</dd>
<dt>Property: protocol (string) </dt>
<dd><p class="startdd">Protocol used by the connection. Keep in mind that some protocols are indistinguishable - for example "xhr-polling" and "xdr-polling".</p>
<p class="enddd"></p>
</dd>
<dt>Property: readyState (integer) </dt>
<dd><p class="startdd">Current state of the connection: 0-connecting, 1-open, 2-closing, 3-closed.</p>
<p class="enddd"></p>
</dd>
<dt>write(message) </dt>
<dd><p class="startdd">Sends a message over opened connection. A message must be a non-empty string. It's illegal to send a message after the connection was closed (either after 'close' or 'end' method or 'close' event).</p>
<p class="enddd"></p>
</dd>
<dt>close([code], [reason]) </dt>
<dd><p class="startdd">Asks the remote client to disconnect. 'code' and 'reason' parameters are optional and can be used to share the reason of disconnection.</p>
<p class="enddd"></p>
</dd>
<dt>end() </dt>
<dd><p class="startdd">Asks the remote client to disconnect with default 'code' and 'reason' values.</p>
<p class="enddd"></p>
</dd>
</dl>
<p>A <code>Connection</code> instance emits the following events:</p>
<dl>
<dt>Event: data (message) </dt>
<dd><p class="startdd">A message arrived on the connection. Message is a unicode string.</p>
<p class="enddd"></p>
</dd>
<dt>Event: close () </dt>
<dd>Connection was closed. This event is triggered exactly once for every connection. </dd>
</dl>
<p>For example:</p>
<div class="fragment"><div class="line">sockjs_server.on(&#39;connection&#39;, function(conn) {</div><div class="line">    console.log(&#39;connection&#39; + conn);</div><div class="line">    conn.on(&#39;close&#39;, function() {</div><div class="line">        console.log(&#39;close &#39; + conn);</div><div class="line">    });</div><div class="line">    conn.on(&#39;data&#39;, function(message) {</div><div class="line">        console.log(&#39;message &#39; + conn,</div><div class="line">                    message);</div><div class="line">    });</div><div class="line">});</div></div><!-- fragment --><h3>Footnote</h3>
<p>A fully working echo server does need a bit more boilerplate (to handle requests unanswered by SockJS), see the <a href="https://github.com/sockjs/sockjs-node/tree/master/examples/echo"><code>echo</code> example</a> for a complete code.</p>
<h3>Examples</h3>
<p>If you want to see samples of running code, take a look at:</p>
<ul>
<li><a href="https://github.com/sockjs/sockjs-node/tree/master/examples/echo">./examples/echo</a> directory, which contains a full example of a echo server.</li>
<li><a href="https://github.com/sockjs/sockjs-node/tree/master/examples/test_server">./examples/test_server</a> a standard SockJS test server.</li>
</ul>
<h2>Connecting to SockJS-node without the client </h2>
<p>Although the main point of SockJS it to enable browser-to-server connectivity, it is possible to connect to SockJS from an external application. Any SockJS server complying with 0.3 protocol does support a raw WebSocket url. The raw WebSocket url for the test server looks like:</p>
<ul>
<li>ws://localhost:8081/echo/websocket</li>
</ul>
<p>You can connect any WebSocket RFC 6455 compliant WebSocket client to this url. This can be a command line client, external application, third party code or even a browser (though I don't know why you would want to do so).</p>
<p>Note: This endpoint will <em>not send any heartbeat packets</em>.</p>
<h2>Deployment and load balancing </h2>
<p>There are two issues that need to be considered when planning a non-trivial SockJS-node deployment: WebSocket-compatible load balancer and sticky sessions (aka session affinity).</p>
<h3>WebSocket compatible load balancer</h3>
<p>Often WebSockets don't play nicely with proxies and load balancers. Deploying a SockJS server behind Nginx or Apache could be painful.</p>
<p>Fortunately recent versions of an excellent load balancer <a href="http://haproxy.1wt.eu/">HAProxy</a> are able to proxy WebSocket connections. We propose to put HAProxy as a front line load balancer and use it to split SockJS traffic from normal HTTP data. Take a look at the sample <a href="https://github.com/sockjs/sockjs-node/blob/master/examples/haproxy.cfg">SockJS HAProxy configuration</a>.</p>
<p>The config also shows how to use HAproxy balancing to split traffic between multiple Node.js servers. You can also do balancing using dns names.</p>
<h3>Sticky sessions</h3>
<p>If you plan deploying more than one SockJS server, you must make sure that all HTTP requests for a single session will hit the same server. SockJS has two mechanisms that can be useful to achieve that:</p>
<ul>
<li>Urls are prefixed with server and session id numbers, like: <code>/resource/&lt;server_number&gt;/&lt;session_id&gt;/transport</code>. This is useful for load balancers that support prefix-based affinity (HAProxy does).</li>
<li><code>JSESSIONID</code> cookie is being set by SockJS-node. Many load balancers turn on sticky sessions if that cookie is set. This technique is derived from Java applications, where sticky sessions are often necessary. HAProxy does support this method, as well as some hosting providers, for example CloudFoundry. In order to enable this method on the client side, please supply a <code>cookie:true</code> option to SockJS constructor.</li>
</ul>
<h2>Development and testing </h2>
<p>If you want to work on SockJS-node source code, you need to clone the git repo and follow these steps. First you need to install dependencies: </p><pre class="fragment">cd sockjs-node
npm install
npm install --dev
ln -s .. node_modules/sockjs
</pre><p>You're ready to compile CoffeeScript: </p><pre class="fragment">make build
</pre><p>If compilation succeeds you may want to test if your changes pass all the tests. Currently, there are two separate test suites. For both of them you need to start a SockJS-node test server (by default listening on port 8081): </p><pre class="fragment">make test_server
</pre><h3>SockJS-protocol Python tests</h3>
<p>To run it run something like: </p><pre class="fragment">cd sockjs-protocol
make test_deps
./venv/bin/python sockjs-protocol.py
</pre><p>For details see <a href="https://github.com/sockjs/sockjs-protocol#readme">SockJS-protocol README</a>.</p>
<h3>SockJS-client QUnit tests</h3>
<p>You need to start a second web server (by default listening on 8080) that is serving various static html and javascript files: </p><pre class="fragment">cd sockjs-client
make test
</pre><p>At that point you should have two web servers running: sockjs-node on 8081 and sockjs-client on 8080. When you open the browser on <a href="http://localhost:8080/">http://localhost:8080/</a> you should be able run the QUnit tests against your sockjs-node server.</p>
<p>For details see <a href="https://github.com/sockjs/sockjs-client#readme">SockJS-client README</a>.</p>
<p>Additionally, if you're doing more serious development consider using <code>make serve</code>, which will automatically the server when you modify the source code.</p>
<h2>Various issues and design considerations </h2>
<h3>Authorisation</h3>
<p>SockJS-node does not expose cookies to the application. This is done deliberately as using cookie-based authorisation with SockJS simply doesn't make sense and will lead to security issues.</p>
<p>Cookies are a contract between a browser and an http server, and are identified by a domain name. If a browser has a cookie set for particular domain, it will pass it as a part of all http requests to the host. But to get various transports working, SockJS uses a middleman</p><ul>
<li>an iframe hosted from target SockJS domain. That means the server will receive requests from the iframe, and not from the real domain. The domain of an iframe is the same as the SockJS domain. The problem is that any website can embed the iframe and communicate with it - and request establishing SockJS connection. Using cookies for authorisation in this scenario will result in granting full access to SockJS communication with your website from any website. This is a classic CSRF attack.</li>
</ul>
<p>Basically - cookies are not suited for SockJS model. If you want to authorise a session - provide a unique token on a page, send it as a first thing over SockJS connection and validate it on the server side. In essence, this is how cookies work.</p>
<h3>Deploying SockJS on Heroku</h3>
<p>Long polling is known to cause problems on Heroku, but <a href="https://github.com/sockjs/sockjs-node/issues/57#issuecomment-5242187">workaround for SockJS is available</a>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者 &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
