<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>demo: websocket-driver [![Build Status](https://travis-ci.org/faye/websocket-driver-node.svg)](https://travis-ci.org/faye/websocket-driver-node)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">demo
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">Vfunc Spring Boot项目概要</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">websocket-driver [![Build Status](<a href="https://travis-ci.org/faye/websocket-driver-node.svg">https://travis-ci.org/faye/websocket-driver-node.svg</a>)](<a href="https://travis-ci.org/faye/websocket-driver-node">https://travis-ci.org/faye/websocket-driver-node</a>) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This module provides a complete implementation of the WebSocket protocols that can be hooked up to any I/O stream. It aims to simplify things by decoupling the protocol details from the I/O layer, such that users only need to implement code to stream data in and out of it without needing to know anything about how the protocol actually works. Think of it as a complete WebSocket system with pluggable I/O.</p>
<p>Due to this design, you get a lot of things for free. In particular, if you hook this module up to some I/O object, it will do all of this for you:</p>
<ul>
<li>Select the correct server-side driver to talk to the client</li>
<li>Generate and send both server- and client-side handshakes</li>
<li>Recognize when the handshake phase completes and the WS protocol begins</li>
<li>Negotiate subprotocol selection based on <code>Sec-WebSocket-Protocol</code></li>
<li>Negotiate and use extensions via the <a href="https://github.com/faye/websocket-extensions-node">websocket-extensions</a> module</li>
<li>Buffer sent messages until the handshake process is finished</li>
<li>Deal with proxies that defer delivery of the draft-76 handshake body</li>
<li>Notify you when the socket is open and closed and when messages arrive</li>
<li>Recombine fragmented messages</li>
<li>Dispatch text, binary, ping, pong and close frames</li>
<li>Manage the socket-closing handshake process</li>
<li>Automatically reply to ping frames with a matching pong</li>
<li>Apply masking to messages sent by the client</li>
</ul>
<p>This library was originally extracted from the <a href="http://faye.jcoglan.com">Faye</a> project but now aims to provide simple WebSocket support for any Node-based project.</p>
<h2>Installation</h2>
<div class="fragment"><div class="line">$ npm install websocket-driver</div></div><!-- fragment --><h2>Usage</h2>
<p>This module provides protocol drivers that have the same interface on the server and on the client. A WebSocket driver is an object with two duplex streams attached; one for incoming/outgoing messages and one for managing the wire protocol over an I/O stream. The full API is described below.</p>
<h3>Server-side with HTTP</h3>
<p>A Node webserver emits a special event for 'upgrade' requests, and this is where you should handle WebSockets. You first check whether the request is a WebSocket, and if so you can create a driver and attach the request's I/O stream to it.</p>
<div class="fragment"><div class="line">var http = require(&#39;http&#39;),</div><div class="line">    websocket = require(&#39;websocket-driver&#39;);</div><div class="line"></div><div class="line">var server = http.createServer();</div><div class="line"></div><div class="line">server.on(&#39;upgrade&#39;, function(request, socket, body) {</div><div class="line">  if (!websocket.isWebSocket(request)) return;</div><div class="line"></div><div class="line">  var driver = websocket.http(request);</div><div class="line"></div><div class="line">  driver.io.write(body);</div><div class="line">  socket.pipe(driver.io).pipe(socket);</div><div class="line"></div><div class="line">  driver.messages.on(&#39;data&#39;, function(message) {</div><div class="line">    console.log(&#39;Got a message&#39;, message);</div><div class="line">  });</div><div class="line"></div><div class="line">  driver.start();</div><div class="line">});</div></div><!-- fragment --><p>Note the line <code>driver.io.write(body)</code> - you must pass the <code>body</code> buffer to the socket driver in order to make certain versions of the protocol work.</p>
<h3>Server-side with TCP</h3>
<p>You can also handle WebSocket connections in a bare TCP server, if you're not using an HTTP server and don't want to implement HTTP parsing yourself.</p>
<p>The driver will emit a <code>connect</code> event when a request is received, and at this point you can detect whether it's a WebSocket and handle it as such. Here's an example using the Node <code>net</code> module:</p>
<div class="fragment"><div class="line">var net = require(&#39;net&#39;),</div><div class="line">    websocket = require(&#39;websocket-driver&#39;);</div><div class="line"></div><div class="line">var server = net.createServer(function(connection) {</div><div class="line">  var driver = websocket.server();</div><div class="line"></div><div class="line">  driver.on(&#39;connect&#39;, function() {</div><div class="line">    if (websocket.isWebSocket(driver)) {</div><div class="line">      driver.start();</div><div class="line">    } else {</div><div class="line">      // handle other HTTP requests</div><div class="line">    }</div><div class="line">  });</div><div class="line"></div><div class="line">  driver.on(&#39;close&#39;, function() { connection.end() });</div><div class="line">  connection.on(&#39;error&#39;, function() {});</div><div class="line"></div><div class="line">  connection.pipe(driver.io).pipe(connection);</div><div class="line"></div><div class="line">  driver.messages.pipe(driver.messages);</div><div class="line">});</div><div class="line"></div><div class="line">server.listen(4180);</div></div><!-- fragment --><p>In the <code>connect</code> event, the driver gains several properties to describe the request, similar to a Node request object, such as <code>method</code>, <code>url</code> and <code>headers</code>. However you should remember it's not a real request object; you cannot write data to it, it only tells you what request data we parsed from the input.</p>
<p>If the request has a body, it will be in the <code>driver.body</code> buffer, but only as much of the body as has been piped into the driver when the <code>connect</code> event fires.</p>
<h3>Client-side</h3>
<p>Similarly, to implement a WebSocket client you just need to make a driver by passing in a <a class="el" href="namespace_u_r_l.html">URL</a>. After this you use the driver API as described below to process incoming data and send outgoing data.</p>
<div class="fragment"><div class="line">var net = require(&#39;net&#39;),</div><div class="line">    websocket = require(&#39;websocket-driver&#39;);</div><div class="line"></div><div class="line">var driver = websocket.client(&#39;ws://www.example.com/socket&#39;),</div><div class="line">    tcp = net.connect(80, &#39;www.example.com&#39;);</div><div class="line"></div><div class="line">tcp.pipe(driver.io).pipe(tcp);</div><div class="line"></div><div class="line">tcp.on(&#39;connect&#39;, function() {</div><div class="line">  driver.start();</div><div class="line">});</div><div class="line"></div><div class="line">driver.messages.on(&#39;data&#39;, function(message) {</div><div class="line">  console.log(&#39;Got a message&#39;, message);</div><div class="line">});</div></div><!-- fragment --><p>Client drivers have two additional properties for reading the HTTP data that was sent back by the server:</p>
<ul>
<li><code>driver.statusCode</code> - the integer value of the HTTP status code</li>
<li><code>driver.headers</code> - an object containing the response headers</li>
</ul>
<h3>HTTP Proxies</h3>
<p>The client driver supports connections via HTTP proxies using the <code>CONNECT</code> method. Instead of sending the WebSocket handshake immediately, it will send a <code>CONNECT</code> request, wait for a <code>200</code> response, and then proceed as normal.</p>
<p>To use this feature, call <code>driver.proxy(url)</code> where <code>url</code> is the origin of the proxy, including a username and password if required. This produces a duplex stream that you should pipe in and out of your TCP connection to the proxy server. When the proxy emits <code>connect</code>, you can then pipe <code>driver.io</code> to your TCP stream and call <code>driver.start()</code>.</p>
<div class="fragment"><div class="line">var net = require(&#39;net&#39;),</div><div class="line">    websocket = require(&#39;websocket-driver&#39;);</div><div class="line"></div><div class="line">var driver = websocket.client(&#39;ws://www.example.com/socket&#39;),</div><div class="line">    proxy  = driver.proxy(&#39;http://username:password@proxy.example.com&#39;),</div><div class="line">    tcp    = net.connect(80, &#39;proxy.example.com&#39;);</div><div class="line"></div><div class="line">tcp.pipe(proxy).pipe(tcp, {end: false});</div><div class="line"></div><div class="line">tcp.on(&#39;connect&#39;, function() {</div><div class="line">  proxy.start();</div><div class="line">});</div><div class="line"></div><div class="line">proxy.on(&#39;connect&#39;, function() {</div><div class="line">  driver.io.pipe(tcp).pipe(driver.io);</div><div class="line">  driver.start();</div><div class="line">});</div><div class="line"></div><div class="line">driver.messages.on(&#39;data&#39;, function(message) {</div><div class="line">  console.log(&#39;Got a message&#39;, message);</div><div class="line">});</div></div><!-- fragment --><p>The proxy's <code>connect</code> event is also where you should perform a TLS handshake on your TCP stream, if you are connecting to a <code>wss:</code> endpoint.</p>
<p>In the event that proxy connection fails, <code>proxy</code> will emit an <code>error</code>. You can inspect the proxy's response via <code>proxy.statusCode</code> and <code>proxy.headers</code>.</p>
<div class="fragment"><div class="line">proxy.on(&#39;error&#39;, function(error) {</div><div class="line">  console.error(error.message);</div><div class="line">  console.log(proxy.statusCode);</div><div class="line">  console.log(proxy.headers);</div><div class="line">});</div></div><!-- fragment --><p>Before calling <code>proxy.start()</code> you can set custom headers using <code>proxy.setHeader()</code>:</p>
<div class="fragment"><div class="line">proxy.setHeader(&#39;User-Agent&#39;, &#39;node&#39;);</div><div class="line">proxy.start();</div></div><!-- fragment --><h3>Driver API</h3>
<p>Drivers are created using one of the following methods:</p>
<div class="fragment"><div class="line">driver = websocket.http(request, options)</div><div class="line">driver = websocket.server(options)</div><div class="line">driver = websocket.client(url, options)</div></div><!-- fragment --><p>The <code>http</code> method returns a driver chosen using the headers from a Node HTTP request object. The <code>server</code> method returns a driver that will parse an HTTP request and then decide which driver to use for it using the <code>http</code> method. The <code>client</code> method always returns a driver for the RFC version of the protocol with masking enabled on outgoing frames.</p>
<p>The <code>options</code> argument is optional, and is an object. It may contain the following fields:</p>
<ul>
<li><code>maxLength</code> - the maximum allowed size of incoming message frames, in bytes. The default value is <code>2^26 - 1</code>, or 1 byte short of 64 MiB.</li>
<li><code>protocols</code> - an array of strings representing acceptable subprotocols for use over the socket. The driver will negotiate one of these to use via the <code>Sec-WebSocket-Protocol</code> header if supported by the other peer.</li>
</ul>
<p>A driver has two duplex streams attached to it:</p>
<ul>
<li><b><code>driver.io</code></b> - this stream should be attached to an I/O socket like a TCP stream. Pipe incoming TCP chunks to this stream for them to be parsed, and pipe this stream back into TCP to send outgoing frames.</li>
<li><b><code>driver.messages</code></b> - this stream emits messages received over the WebSocket. Writing to it sends messages to the other peer by emitting frames via the <code>driver.io</code> stream.</li>
</ul>
<p>All drivers respond to the following API methods, but some of them are no-ops depending on whether the client supports the behaviour.</p>
<p>Note that most of these methods are commands: if they produce data that should be sent over the socket, they will give this to you by emitting <code>data</code> events on the <code>driver.io</code> stream.</p>
<h4>&lsquo;driver.on('open&rsquo;, function(event) {})`</h4>
<p>Adds a callback to execute when the socket becomes open.</p>
<h4>&lsquo;driver.on('message&rsquo;, function(event) {})`</h4>
<p>Adds a callback to execute when a message is received. <code>event</code> will have a <code>data</code> attribute containing either a string in the case of a text message or a <code>Buffer</code> in the case of a binary message.</p>
<p>You can also listen for messages using the &lsquo;driver.messages.on('data&rsquo;)` event, which emits strings for text messages and buffers for binary messages.</p>
<h4>&lsquo;driver.on('error&rsquo;, function(event) {})`</h4>
<p>Adds a callback to execute when a protocol error occurs due to the other peer sending an invalid byte sequence. <code>event</code> will have a <code>message</code> attribute describing the error.</p>
<h4>&lsquo;driver.on('close&rsquo;, function(event) {})`</h4>
<p>Adds a callback to execute when the socket becomes closed. The <code>event</code> object has <code>code</code> and <code>reason</code> attributes.</p>
<h4><code>driver.addExtension(extension)</code></h4>
<p>Registers a protocol extension whose operation will be negotiated via the <code>Sec-WebSocket-Extensions</code> header. <code>extension</code> is any extension compatible with the <a href="https://github.com/faye/websocket-extensions-node">websocket-extensions</a> framework.</p>
<h4><code>driver.setHeader(name, value)</code></h4>
<p>Sets a custom header to be sent as part of the handshake response, either from the server or from the client. Must be called before <code>start()</code>, since this is when the headers are serialized and sent.</p>
<h4><code>driver.start()</code></h4>
<p>Initiates the protocol by sending the handshake - either the response for a server-side driver or the request for a client-side one. This should be the first method you invoke. Returns <code>true</code> if and only if a handshake was sent.</p>
<h4><code>driver.parse(string)</code></h4>
<p>Takes a string and parses it, potentially resulting in message events being emitted (see &lsquo;on('message&rsquo;)<code>above) or in data being sent to</code>driver.io`. You should send all data you receive via I/O to this method by piping a stream into <code>driver.io</code>.</p>
<h4><code>driver.text(string)</code></h4>
<p>Sends a text message over the socket. If the socket handshake is not yet complete, the message will be queued until it is. Returns <code>true</code> if the message was sent or queued, and <code>false</code> if the socket can no longer send messages.</p>
<p>This method is equivalent to <code>driver.messages.write(string)</code>.</p>
<h4><code>driver.binary(buffer)</code></h4>
<p>Takes a <code>Buffer</code> and sends it as a binary message. Will queue and return <code>true</code> or <code>false</code> the same way as the <code>text</code> method. It will also return <code>false</code> if the driver does not support binary messages.</p>
<p>This method is equivalent to <code>driver.messages.write(buffer)</code>.</p>
<h4>&lsquo;driver.ping(string = &rsquo;', function() {})`</h4>
<p>Sends a ping frame over the socket, queueing it if necessary. <code>string</code> and the callback are both optional. If a callback is given, it will be invoked when the socket receives a pong frame whose content matches <code>string</code>. Returns <code>false</code> if frames can no longer be sent, or if the driver does not support ping/pong.</p>
<h4>&lsquo;driver.pong(string = &rsquo;')`</h4>
<p>Sends a pong frame over the socket, queueing it if necessary. <code>string</code> is optional. Returns <code>false</code> if frames can no longer be sent, or if the driver does not support ping/pong.</p>
<p>You don't need to call this when a ping frame is received; pings are replied to automatically by the driver. This method is for sending unsolicited pongs.</p>
<h4><code>driver.close()</code></h4>
<p>Initiates the closing handshake if the socket is still open. For drivers with no closing handshake, this will result in the immediate execution of the &lsquo;on('close&rsquo;)<code>driver. For drivers with a closing handshake, this sends a closing frame and</code>emit('close')` will execute when a response is received or a protocol error occurs.</p>
<h4><code>driver.version</code></h4>
<p>Returns the WebSocket version in use as a string. Will either be <code>hixie-75</code>, <code>hixie-76</code> or <code>hybi-$version</code>.</p>
<h4><code>driver.protocol</code></h4>
<p>Returns a string containing the selected subprotocol, if any was agreed upon using the <code>Sec-WebSocket-Protocol</code> mechanism. This value becomes available after &lsquo;emit('open&rsquo;)` has fired.</p>
<h2>License</h2>
<p>(The MIT License)</p>
<p>Copyright (c) 2010-2016 James Coglan</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者 &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
