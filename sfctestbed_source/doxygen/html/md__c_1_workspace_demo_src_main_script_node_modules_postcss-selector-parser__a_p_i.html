<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>demo: API Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">demo
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">Vfunc Spring Boot项目概要</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">API Documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><em>Please use only this documented API when working with the parser. Methods not documented here are subject to change at any point.</em></p>
<h2><code>parser</code> function</h2>
<p>This is the module's main entry point.</p>
<div class="fragment"><div class="line">var parser = require(&#39;postcss-selector-parser&#39;);</div></div><!-- fragment --><h3><code>parser([transform])</code></h3>
<p>Creates a new <code>processor</code> instance</p>
<div class="fragment"><div class="line">var processor = parser();</div><div class="line"></div><div class="line">// or, with optional transform function</div><div class="line">var transform = function (selectors) {</div><div class="line">    selectors.eachUniversal(function (selector) {</div><div class="line">        selector.remove();</div><div class="line">    });</div><div class="line">};</div><div class="line"></div><div class="line">var processor = parser(transform)</div><div class="line"></div><div class="line">// Example</div><div class="line">var result = processor.process(&#39;*.class&#39;).result;</div><div class="line">// =&gt; .class</div></div><!-- fragment --><p><a href="#processor">See processor documentation</a></p>
<p>Arguments:</p>
<ul>
<li><code>transform (function)</code>: Provide a function to work with the parsed AST.</li>
</ul>
<h3><code>parser.attribute([props])</code></h3>
<p>Creates a new attribute selector.</p>
<div class="fragment"><div class="line">parser.attribute({attribute: &#39;href&#39;});</div><div class="line">// =&gt; [href]</div></div><!-- fragment --><p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node's properties.</li>
</ul>
<h3><code>parser.className([props])</code></h3>
<p>Creates a new class selector.</p>
<div class="fragment"><div class="line">parser.className({value: &#39;button&#39;});</div><div class="line">// =&gt; .button</div></div><!-- fragment --><p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node's properties.</li>
</ul>
<h3><code>parser.combinator([props])</code></h3>
<p>Creates a new selector combinator.</p>
<div class="fragment"><div class="line">parser.combinator({value: &#39;+&#39;});</div><div class="line">// =&gt; +</div></div><!-- fragment --><p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node's properties.</li>
</ul>
<h3><code>parser.comment([props])</code></h3>
<p>Creates a new comment.</p>
<div class="fragment"><div class="line">parser.comment({value: &#39;/* Affirmative, Dave. I read you. */&#39;});</div><div class="line">// =&gt; /* Affirmative, Dave. I read you. */</div></div><!-- fragment --><p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node's properties.</li>
</ul>
<h3><code>parser.id([props])</code></h3>
<p>Creates a new id selector.</p>
<div class="fragment"><div class="line">parser.id({value: &#39;search&#39;});</div><div class="line">// =&gt; #search</div></div><!-- fragment --><p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node's properties.</li>
</ul>
<h3><code>parser.nesting([props])</code></h3>
<p>Creates a new nesting selector.</p>
<div class="fragment"><div class="line">parser.nesting();</div><div class="line">// =&gt; &amp;</div></div><!-- fragment --><p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node's properties.</li>
</ul>
<h3><code>parser.pseudo([props])</code></h3>
<p>Creates a new pseudo selector.</p>
<div class="fragment"><div class="line">parser.pseudo({value: &#39;::before&#39;});</div><div class="line">// =&gt; ::before</div></div><!-- fragment --><p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node's properties.</li>
</ul>
<h3><code>parser.root([props])</code></h3>
<p>Creates a new root node.</p>
<div class="fragment"><div class="line">parser.root();</div><div class="line">// =&gt; (empty)</div></div><!-- fragment --><p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node's properties.</li>
</ul>
<h3><code>parser.selector([props])</code></h3>
<p>Creates a new selector node.</p>
<div class="fragment"><div class="line">parser.selector();</div><div class="line">// =&gt; (empty)</div></div><!-- fragment --><p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node's properties.</li>
</ul>
<h3><code>parser.string([props])</code></h3>
<p>Creates a new string node.</p>
<div class="fragment"><div class="line">parser.string();</div><div class="line">// =&gt; (empty)</div></div><!-- fragment --><p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node's properties.</li>
</ul>
<h3><code>parser.tag([props])</code></h3>
<p>Creates a new tag selector.</p>
<div class="fragment"><div class="line">parser.tag({value: &#39;button&#39;});</div><div class="line">// =&gt; button</div></div><!-- fragment --><p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node's properties.</li>
</ul>
<h3><code>parser.universal([props])</code></h3>
<p>Creates a new universal selector.</p>
<div class="fragment"><div class="line">parser.universal();</div><div class="line">// =&gt; *</div></div><!-- fragment --><p>Arguments:</p>
<ul>
<li><code>props (object)</code>: The new node's properties.</li>
</ul>
<h2>Node types</h2>
<h3><code>node.type</code></h3>
<p>A string representation of the selector type. It can be one of the following; <code>attribute</code>, <code>class</code>, <code>combinator</code>, <code>comment</code>, <code>id</code>, <code>nesting</code>, <code>pseudo</code>, <code>root</code>, <code>selector</code>, <code>string</code>, <code>tag</code>, or <code>universal</code>. Note that for convenience, these constants are exposed on the main <code>parser</code> as uppercased keys. So for example you can get <code>id</code> by querying <code>parser.ID</code>.</p>
<div class="fragment"><div class="line">parser.attribute({attribute: &#39;href&#39;}).type;</div><div class="line">// =&gt; &#39;attribute&#39;</div></div><!-- fragment --><h3><code>node.parent</code></h3>
<p>Returns the parent node.</p>
<div class="fragment"><div class="line">root.nodes[0].parent === root;</div></div><!-- fragment --><h3><code>node.toString()</code>, <code>String(node)</code>, or &lsquo;&rsquo;' + node`</h3>
<p>Returns a string representation of the node.</p>
<div class="fragment"><div class="line">var id = parser.id({value: &#39;search&#39;});</div><div class="line">console.log(String(id));</div><div class="line">// =&gt; #search</div></div><!-- fragment --><h3><code>node.next()</code> &amp; <code>node.prev()</code></h3>
<p>Returns the next/previous child of the parent node.</p>
<div class="fragment"><div class="line">var next = id.next();</div><div class="line">if (next &amp;&amp; next.type !== &#39;combinator&#39;) {</div><div class="line">    throw new Error(&#39;Qualified IDs are not allowed!&#39;);</div><div class="line">}</div></div><!-- fragment --><h3><code>node.replaceWith(node)</code></h3>
<p>Replace a node with another.</p>
<div class="fragment"><div class="line">var attr = selectors.first.first;</div><div class="line">var className = parser.className({value: &#39;test&#39;});</div><div class="line">attr.replaceWith(className);</div></div><!-- fragment --><p>Arguments:</p>
<ul>
<li><code>node</code>: The node to substitute the original with.</li>
</ul>
<h3><code>node.remove()</code></h3>
<p>Removes the node from its parent node.</p>
<div class="fragment"><div class="line">if (node.type === &#39;id&#39;) {</div><div class="line">    node.remove();</div><div class="line">}</div></div><!-- fragment --><h3><code>node.clone()</code></h3>
<p>Returns a copy of a node, detached from any parent containers that the original might have had.</p>
<div class="fragment"><div class="line">var cloned = parser.id({value: &#39;search&#39;});</div><div class="line">String(cloned);</div><div class="line"></div><div class="line">// =&gt; #search</div></div><!-- fragment --><h3><code>node.spaces</code></h3>
<p>Extra whitespaces around the node will be moved into <code>node.spaces.before</code> and <code>node.spaces.after</code>. So for example, these spaces will be moved as they have no semantic meaning:</p>
<div class="fragment"><div class="line">h1     ,     h2   {}</div></div><!-- fragment --><p>However, <em>combinating</em> spaces will form a <code>combinator</code> node:</p>
<div class="fragment"><div class="line">h1        h2 {}</div></div><!-- fragment --><p>A <code>combinator</code> node may only have the <code>spaces</code> property set if the combinator value is a non-whitespace character, such as <code>+</code>, <code>~</code> or <code>&gt;</code>. Otherwise, the combinator value will contain all of the spaces between selectors.</p>
<h3><code>node.source</code></h3>
<p>An object describing the node's start/end, line/column source position.</p>
<p>Within the following CSS, the <code>.bar</code> class node ...</p>
<div class="fragment"><div class="line">.foo,</div><div class="line">  .bar {}</div></div><!-- fragment --><p>... will contain the following <code>source</code> object.</p>
<div class="fragment"><div class="line">source: {</div><div class="line">    start: {</div><div class="line">        line: 2,</div><div class="line">        column: 3</div><div class="line">    },</div><div class="line">    end: {</div><div class="line">        line: 2,</div><div class="line">        column: 6</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3><code>node.sourceIndex</code></h3>
<p>The zero-based index of the node within the original source string.</p>
<p>Within the following CSS, the <code>.baz</code> class node will have a <code>sourceIndex</code> of <code>12</code>.</p>
<div class="fragment"><div class="line">.foo, .bar, .baz {}</div></div><!-- fragment --><h2>Container types</h2>
<p>The <code>root</code>, <code>selector</code>, and <code>pseudo</code> nodes have some helper methods for working with their children.</p>
<h3><code>container.nodes</code></h3>
<p>An array of the container's children.</p>
<div class="fragment"><div class="line">// Input: h1 h2</div><div class="line">selectors.at(0).nodes.length   // =&gt; 3</div><div class="line">selectors.at(0).nodes[0].value // =&gt; &#39;h1&#39;</div><div class="line">selectors.at(0).nodes[1].value // =&gt; &#39; &#39;</div></div><!-- fragment --><h3><code>container.first</code> &amp; <code>container.last</code></h3>
<p>The first/last child of the container.</p>
<div class="fragment"><div class="line">selector.first === selector.nodes[0];</div><div class="line">selector.last === selector.nodes[selector.nodes.length - 1];</div></div><!-- fragment --><h3><code>container.at(index)</code></h3>
<p>Returns the node at position <code>index</code>.</p>
<div class="fragment"><div class="line">selector.at(0) === selector.first;</div><div class="line">selector.at(0) === selector.nodes[0];</div></div><!-- fragment --><p>Arguments:</p>
<ul>
<li><code>index</code>: The index of the node to return.</li>
</ul>
<h3><code>container.index(node)</code></h3>
<p>Return the index of the node within its container.</p>
<div class="fragment"><div class="line">selector.index(selector.nodes[2]) // =&gt; 2</div></div><!-- fragment --><p>Arguments:</p>
<ul>
<li><code>node</code>: A node within the current container.</li>
</ul>
<h3><code>container.length</code></h3>
<p>Proxy to the length of the container's nodes.</p>
<div class="fragment"><div class="line">container.length === container.nodes.length</div></div><!-- fragment --><h3><code>container</code> Array iterators</h3>
<p>The container class provides proxies to certain Array methods; these are:</p>
<ul>
<li><code>container.map === container.nodes.map</code></li>
<li><code>container.reduce === container.nodes.reduce</code></li>
<li><code>container.every === container.nodes.every</code></li>
<li><code>container.some === container.nodes.some</code></li>
<li><code>container.filter === container.nodes.filter</code></li>
<li><code>container.sort === container.nodes.sort</code></li>
</ul>
<p>Note that these methods only work on a container's immediate children; recursive iteration is provided by <code>container.walk</code>.</p>
<h3><code>container.each(callback)</code></h3>
<p>Iterate the container's immediate children, calling <code>callback</code> for each child. You may return <code>false</code> within the callback to break the iteration.</p>
<div class="fragment"><div class="line">var className;</div><div class="line">selectors.each(function (selector, index) {</div><div class="line">    if (selector.type === &#39;class&#39;) {</div><div class="line">        className = selector.value;</div><div class="line">        return false;</div><div class="line">    }</div><div class="line">});</div></div><!-- fragment --><p>Note that unlike <code>Array::forEach()</code>, this iterator is safe to use whilst adding or removing nodes from the container.</p>
<p>Arguments:</p>
<ul>
<li><code>callback (function)</code>: A function to call for each node, which receives <code>node</code> and <code>index</code> arguments.</li>
</ul>
<h3><code>container.walk(callback)</code></h3>
<p>Like <code>container::each</code>, but will also iterate child nodes as long as they are <code>container</code> types.</p>
<div class="fragment"><div class="line">selectors.walk(function (selector, index) {</div><div class="line">    // all nodes</div><div class="line">});</div></div><!-- fragment --><p>Arguments:</p>
<ul>
<li><code>callback (function)</code>: A function to call for each node, which receives <code>node</code> and <code>index</code> arguments.</li>
</ul>
<p>This iterator is safe to use whilst mutating <code>container.nodes</code>, like <code>container::each</code>.</p>
<h3><code>container.walk</code> proxies</h3>
<p>The container class provides proxy methods for iterating over types of nodes, so that it is easier to write modules that target specific selectors. Those methods are:</p>
<ul>
<li><code>container.walkAttributes</code></li>
<li><code>container.walkClasses</code></li>
<li><code>container.walkCombinators</code></li>
<li><code>container.walkComments</code></li>
<li><code>container.walkIds</code></li>
<li><code>container.walkNesting</code></li>
<li><code>container.walkPseudos</code></li>
<li><code>container.walkTags</code></li>
<li><code>container.walkUniversals</code></li>
</ul>
<h3><code>container.split(callback)</code></h3>
<p>This method allows you to split a group of nodes by returning <code>true</code> from a callback. It returns an array of arrays, where each inner array corresponds to the groups that you created via the callback.</p>
<div class="fragment"><div class="line">// (input) =&gt; h1 h2&gt;&gt;h3</div><div class="line">var list = selectors.first.split((selector) =&gt; {</div><div class="line">    return selector.type === &#39;combinator&#39;;</div><div class="line">});</div><div class="line"></div><div class="line">// (node values) =&gt; [[&#39;h1&#39;, &#39; &#39;], [&#39;h2&#39;, &#39;&gt;&gt;&#39;], [&#39;h3&#39;]]</div></div><!-- fragment --><p>Arguments:</p>
<ul>
<li><code>callback (function)</code>: A function to call for each node, which receives <code>node</code> as an argument.</li>
</ul>
<h3><code>container.prepend(node)</code> &amp; <code>container.append(node)</code></h3>
<p>Add a node to the start/end of the container. Note that doing so will set the parent property of the node to this container.</p>
<div class="fragment"><div class="line">var id = parser.id({value: &#39;search&#39;});</div><div class="line">selector.append(id);</div></div><!-- fragment --><p>Arguments:</p>
<ul>
<li><code>node</code>: The node to add.</li>
</ul>
<h3><code>container.insertBefore(old, new)</code> &amp; <code>container.insertAfter(old, new)</code></h3>
<p>Add a node before or after an existing node in a container:</p>
<div class="fragment"><div class="line">selectors.walk(function (selector) {</div><div class="line">    if (selector.type !== &#39;class&#39;) {</div><div class="line">        var className = parser.className({value: &#39;theme-name&#39;});</div><div class="line">        selector.parent.insertAfter(selector, className);</div><div class="line">    }</div><div class="line">});</div></div><!-- fragment --><p>Arguments:</p>
<ul>
<li><code>old</code>: The existing node in the container.</li>
<li><code>new</code>: The new node to add before/after the existing node.</li>
</ul>
<h3><code>container.removeChild(node)</code></h3>
<p>Remove the node from the container. Note that you can also use <code>node.remove()</code> if you would like to remove just a single node.</p>
<div class="fragment"><div class="line">selector.length // =&gt; 2</div><div class="line">selector.remove(id)</div><div class="line">selector.length // =&gt; 1;</div><div class="line">id.parent       // undefined</div></div><!-- fragment --><p>Arguments:</p>
<ul>
<li><code>node</code>: The node to remove.</li>
</ul>
<h3><code>container.removeAll()</code> or <code>container.empty()</code></h3>
<p>Remove all children from the container.</p>
<div class="fragment"><div class="line">selector.removeAll();</div><div class="line">selector.length // =&gt; 0</div></div><!-- fragment --><h2>Root nodes</h2>
<p>A root node represents a comma separated list of selectors. Indeed, all a root's <code>toString()</code> method does is join its selector children with a ','. Other than this, it has no special functionality and acts like a container.</p>
<h3><code>root.trailingComma</code></h3>
<p>This will be set to <code>true</code> if the input has a trailing comma, in order to support parsing of legacy CSS hacks.</p>
<h2>Selector nodes</h2>
<p>A selector node represents a single compound selector. For example, this selector string <code>h1 h2 h3, [href] &gt; p</code>, is represented as two selector nodes. It has no special functionality of its own.</p>
<h2>Pseudo nodes</h2>
<p>A pseudo selector extends a container node; if it has any parameters of its own (such as <code>h1:not(h2, h3)</code>), they will be its children. Note that the pseudo <code>value</code> will always contain the colons preceding the pseudo identifier. This is so that both <code>:before</code> and <code>::before</code> are properly represented in the AST.</p>
<h2>Attribute nodes</h2>
<h3><code>attribute.quoted</code></h3>
<p>Returns <code>true</code> if the attribute's value is wrapped in quotation marks, false if it is not. Remains <code>undefined</code> if there is no attribute value.</p>
<div class="fragment"><div class="line">[href=foo] /* false */</div><div class="line">[href=&#39;foo&#39;] /* true */</div><div class="line">[href=&quot;foo&quot;] /* true */</div><div class="line">[href] /* undefined */</div></div><!-- fragment --><h3><code>attribute.raws.unquoted</code></h3>
<p>Returns the unquoted content of the attribute's value. Remains <code>undefined</code> if there is no attribute value.</p>
<div class="fragment"><div class="line">[href=foo] /* foo */</div><div class="line">[href=&#39;foo&#39;] /* foo */</div><div class="line">[href=&quot;foo&quot;] /* foo */</div><div class="line">[href] /* undefined */</div></div><!-- fragment --><h3><code>attribute.raws.insensitive</code></h3>
<p>If there is an <code>i</code> specifying case insensitivity, returns that <code>i</code> along with the whitespace around it.</p>
<div class="fragment"><div class="line">[id=Bar i ] /* &quot; i &quot; */</div><div class="line">[id=Bar   i  ] /* &quot;   i  &quot; */</div></div><!-- fragment --><h2><code>processor</code></h2>
<h3><code>process(cssText, [options])</code></h3>
<p>Processes the <code>cssText</code>, returning the parsed output</p>
<div class="fragment"><div class="line">var processor = parser();</div><div class="line"></div><div class="line">var result = processor.process(&#39; .class&#39;).result;</div><div class="line">// =&gt;  .class</div><div class="line"></div><div class="line">// To have the parser normalize whitespace values, utilize the options</div><div class="line">var result = processor.process(&#39;  .class  &#39;, {lossless: false}).result;</div><div class="line">// =&gt; .class</div></div><!-- fragment --><p>Arguments:</p>
<ul>
<li><code>cssText (string)</code>: The css to be parsed.</li>
<li><code>[options] (object)</code>: Process options</li>
</ul>
<p>Options:</p>
<ul>
<li><code>lossless (boolean)</code>: false to normalize the selector whitespace, defaults to true </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者 &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
