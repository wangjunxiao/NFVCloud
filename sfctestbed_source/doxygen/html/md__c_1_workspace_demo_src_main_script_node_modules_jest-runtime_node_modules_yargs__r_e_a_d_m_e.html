<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>demo: yargs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">demo
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">Vfunc Spring Boot项目概要</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">yargs </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Yargs be a node.js library fer hearties tryin' ter parse optstrings.</p>
<p>With yargs, ye be havin' a map that leads straight to yer treasure! Treasure of course, being a simple option hash.</p>
<p><a href="https://travis-ci.org/yargs/yargs"></a> <a href="https://coveralls.io/github/yargs/yargs"></a> <a href="https://www.npmjs.com/package/yargs"></a> <a href="https://ci.appveyor.com/project/bcoe/yargs-ljwvf"></a> <a href="http://standardjs.com/"></a> <a href="https://conventionalcommits.org/"></a> <a href="https://gitter.im/yargs/Lobby?utm_source=share-link&amp;utm_medium=link&amp;utm_campaign=share-link"></a></p>
<blockquote class="doxtable">
<p>Yargs is the official successor to optimist. Please feel free to submit issues and pull requests. If you'd like to contribute and don't know where to start, have a look at <a href="https://github.com/yargs/yargs/issues">the issue list</a> :) </p>
</blockquote>
<h1>examples </h1>
<h2>With yargs, the options be just a hash! </h2>
<p>plunder.js:</p>
<div class="fragment"><div class="line">#!/usr/bin/env node</div><div class="line">var argv = require(&#39;yargs&#39;).argv;</div><div class="line"></div><div class="line">if (argv.ships &gt; 3 &amp;&amp; argv.distance &lt; 53.5) {</div><div class="line">    console.log(&#39;Plunder more riffiwobbles!&#39;);</div><div class="line">} else {</div><div class="line">    console.log(&#39;Retreat from the xupptumblers!&#39;);</div><div class="line">}</div></div><!-- fragment --><hr/>
 <pre class="fragment">$ ./plunder.js --ships=4 --distance=22
Plunder more riffiwobbles!

$ ./plunder.js --ships 12 --distance 98.7
Retreat from the xupptumblers!
</pre><div class="image">
<img src="https://i.imgur.com/4WFGVJ9.png" alt="Joe was one optimistic pirate."/>
</div>
<h2>But don't walk the plank just yet! There be more! You can do short options: </h2>
<p>short.js:</p>
<div class="fragment"><div class="line">#!/usr/bin/env node</div><div class="line">var argv = require(&#39;yargs&#39;).argv;</div><div class="line">console.log(&#39;(%d,%d)&#39;, argv.x, argv.y);</div></div><!-- fragment --><hr/>
 <pre class="fragment">$ ./short.js -x 10 -y 21
(10,21)
</pre><h2>And booleans, both long, short, and even grouped: </h2>
<p>bool.js:</p>
<div class="fragment"><div class="line">#!/usr/bin/env node</div><div class="line">var argv = require(&#39;yargs&#39;).argv;</div><div class="line"></div><div class="line">if (argv.s) {</div><div class="line">    process.stdout.write(argv.fr ? &#39;Le perroquet dit: &#39; : &#39;The parrot says: &#39;);</div><div class="line">}</div><div class="line">console.log(</div><div class="line">    (argv.fr ? &#39;couac&#39; : &#39;squawk&#39;) + (argv.p ? &#39;!&#39; : &#39;&#39;)</div><div class="line">);</div></div><!-- fragment --><hr/>
 <pre class="fragment">$ ./bool.js -s
The parrot says: squawk

$ ./bool.js -sp
The parrot says: squawk!

$ ./bool.js -sp --fr
Le perroquet dit: couac!
</pre><h2>And non-hyphenated options too! Just use <code>argv._</code>! </h2>
<p>nonopt.js:</p>
<div class="fragment"><div class="line">#!/usr/bin/env node</div><div class="line">var argv = require(&#39;yargs&#39;).argv;</div><div class="line">console.log(&#39;(%d,%d)&#39;, argv.x, argv.y);</div><div class="line">console.log(argv._);</div></div><!-- fragment --><hr/>
 <pre class="fragment">$ ./nonopt.js -x 6.82 -y 3.35 rum
(6.82,3.35)
[ 'rum' ]

$ ./nonopt.js "me hearties" -x 0.54 yo -y 1.12 ho
(0.54,1.12)
[ 'me hearties', 'yo', 'ho' ]
</pre><h2>Yargs even counts your booleans! </h2>
<p>count.js:</p>
<div class="fragment"><div class="line">#!/usr/bin/env node</div><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">    .count(&#39;verbose&#39;)</div><div class="line">    .alias(&#39;v&#39;, &#39;verbose&#39;)</div><div class="line">    .argv;</div><div class="line"></div><div class="line">VERBOSE_LEVEL = argv.verbose;</div><div class="line"></div><div class="line">function WARN()  { VERBOSE_LEVEL &gt;= 0 &amp;&amp; console.log.apply(console, arguments); }</div><div class="line">function INFO()  { VERBOSE_LEVEL &gt;= 1 &amp;&amp; console.log.apply(console, arguments); }</div><div class="line">function DEBUG() { VERBOSE_LEVEL &gt;= 2 &amp;&amp; console.log.apply(console, arguments); }</div><div class="line"></div><div class="line">WARN(&quot;Showing only important stuff&quot;);</div><div class="line">INFO(&quot;Showing semi-important stuff too&quot;);</div><div class="line">DEBUG(&quot;Extra chatty mode&quot;);</div></div><!-- fragment --><hr/>
<p> $ node count.js Showing only important stuff</p>
<p>$ node count.js -v Showing only important stuff Showing semi-important stuff too</p>
<p>$ node count.js -vv Showing only important stuff Showing semi-important stuff too Extra chatty mode</p>
<p>$ node count.js -v &ndash;verbose Showing only important stuff Showing semi-important stuff too Extra chatty mode</p>
<h2>Tell users how to use yer options and make demands. </h2>
<p>area.js:</p>
<div class="fragment"><div class="line">#!/usr/bin/env node</div><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">    .usage(&#39;Usage: $0 -w [num] -h [num]&#39;)</div><div class="line">    .demandOption([&#39;w&#39;,&#39;h&#39;])</div><div class="line">    .argv;</div><div class="line"></div><div class="line">console.log(&quot;The area is:&quot;, argv.w * argv.h);</div></div><!-- fragment --><hr/>
 <pre class="fragment">$ ./area.js -w 55 -h 11
The area is: 605

$ node ./area.js -w 4.91 -w 2.51
Usage: area.js -w [num] -h [num]

Options:
  -w  [required]
  -h  [required]

Missing required arguments: h
</pre><h2>After yer demands have been met, demand more! Ask for non-hyphenated arguments! </h2>
<p>demand_count.js:</p>
<div class="fragment"><div class="line">#!/usr/bin/env node</div><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">    .demandCommand(2)</div><div class="line">    .argv;</div><div class="line">console.dir(argv);</div></div><!-- fragment --><hr/>
 <pre class="fragment">$ ./demand_count.js a

Not enough non-option arguments: got 1, need at least 2

$ ./demand_count.js a b
{ _: [ 'a', 'b' ], '$0': 'demand_count.js' }

$ ./demand_count.js a b c
{ _: [ 'a', 'b', 'c' ], '$0': 'demand_count.js' }
</pre><h2>EVEN MORE SHIVER ME TIMBERS! </h2>
<p>default_singles.js:</p>
<div class="fragment"><div class="line">#!/usr/bin/env node</div><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">    .default(&#39;x&#39;, 10)</div><div class="line">    .default(&#39;y&#39;, 10)</div><div class="line">    .argv</div><div class="line">;</div><div class="line">console.log(argv.x + argv.y);</div></div><!-- fragment --><hr/>
 <pre class="fragment">$ ./default_singles.js -x 5
15
</pre><p>default_hash.js:</p>
<div class="fragment"><div class="line">#!/usr/bin/env node</div><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">    .default({ x : 10, y : 10 })</div><div class="line">    .argv</div><div class="line">;</div><div class="line">console.log(argv.x + argv.y);</div></div><!-- fragment --><hr/>
 <pre class="fragment">$ ./default_hash.js -y 7
17
</pre><h2>And if you really want to get all descriptive about it... </h2>
<p>boolean_single.js:</p>
<div class="fragment"><div class="line">#!/usr/bin/env node</div><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">    .boolean(&#39;v&#39;)</div><div class="line">    .argv</div><div class="line">;</div><div class="line">console.dir(argv.v);</div><div class="line">console.dir(argv._);</div></div><!-- fragment --><hr/>
 <pre class="fragment">$ ./boolean_single.js -v "me hearties" yo ho
true
[ 'me hearties', 'yo', 'ho' ]
</pre><p>boolean_double.js:</p>
<div class="fragment"><div class="line">#!/usr/bin/env node</div><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">    .boolean([&#39;x&#39;,&#39;y&#39;,&#39;z&#39;])</div><div class="line">    .argv</div><div class="line">;</div><div class="line">console.dir([ argv.x, argv.y, argv.z ]);</div><div class="line">console.dir(argv._);</div></div><!-- fragment --><hr/>
 <pre class="fragment">$ ./boolean_double.js -x -z one two three
[ true, false, true ]
[ 'one', 'two', 'three' ]
</pre><h2>Yargs is here to help you... </h2>
<p>Ye can describe parameters fer help messages and set aliases. Yargs figures out how ter format a handy help string automatically.</p>
<p>line_count.js:</p>
<div class="fragment"><div class="line">#!/usr/bin/env node</div><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">    .usage(&#39;Usage: $0 &lt;command&gt; [options]&#39;)</div><div class="line">    .command(&#39;count&#39;, &#39;Count the lines in a file&#39;)</div><div class="line">    .example(&#39;$0 count -f foo.js&#39;, &#39;count the lines in the given file&#39;)</div><div class="line">    .alias(&#39;f&#39;, &#39;file&#39;)</div><div class="line">    .nargs(&#39;f&#39;, 1)</div><div class="line">    .describe(&#39;f&#39;, &#39;Load a file&#39;)</div><div class="line">    .demandOption([&#39;f&#39;])</div><div class="line">    .help(&#39;h&#39;)</div><div class="line">    .alias(&#39;h&#39;, &#39;help&#39;)</div><div class="line">    .epilog(&#39;copyright 2015&#39;)</div><div class="line">    .argv;</div><div class="line"></div><div class="line">var fs = require(&#39;fs&#39;);</div><div class="line">var s = fs.createReadStream(argv.file);</div><div class="line"></div><div class="line">var lines = 0;</div><div class="line">s.on(&#39;data&#39;, function (buf) {</div><div class="line">    lines += buf.toString().match(/\n/g).length;</div><div class="line">});</div><div class="line"></div><div class="line">s.on(&#39;end&#39;, function () {</div><div class="line">    console.log(lines);</div><div class="line">});</div></div><!-- fragment --><hr/>
<p> $ node line_count.js count Usage: line_count.js &lt;command&gt; [options]</p>
<p>Commands: count Count the lines in a file</p>
<p>Options: -f, &ndash;file Load a file [required] -h, &ndash;help Show help [boolean]</p>
<p>Examples: line_count.js count -f foo.js count the lines in the given file</p>
<p>copyright 2015</p>
<p>Missing required arguments: f</p>
<p>$ node line_count.js count &ndash;file line_count.js 26</p>
<p>$ node line_count.js count -f line_count.js 26</p>
<h1>methods </h1>
<p>By itself,</p>
<div class="fragment"><div class="line">require(&#39;yargs&#39;).argv</div></div><!-- fragment --><p>will use the <code>process.argv</code> array to construct the <code>argv</code> object.</p>
<p>You can pass in the <code>process.argv</code> yourself:</p>
<div class="fragment"><div class="line">require(&#39;yargs&#39;)([ &#39;-x&#39;, &#39;1&#39;, &#39;-y&#39;, &#39;2&#39; ]).argv</div></div><!-- fragment --><p>or use <code>.parse()</code> to do the same thing:</p>
<div class="fragment"><div class="line">require(&#39;yargs&#39;).parse([ &#39;-x&#39;, &#39;1&#39;, &#39;-y&#39;, &#39;2&#39; ])</div></div><!-- fragment --><p>The rest of these methods below come in just before the terminating <code>.argv</code>.</p>
<h2><a class="anchor" id="alias"></a>.alias(key, alias) </h2>
<p>Set key names as equivalent such that updates to a key will propagate to aliases and vice-versa.</p>
<p>Optionally <code>.alias()</code> can take an object that maps keys to aliases. Each key of this object should be the canonical version of the option, and each value should be a string or an array of strings.</p>
<h2>.argv </h2>
<p>Get the arguments as a plain old object.</p>
<p>Arguments without a corresponding flag show up in the <code>argv._</code> array.</p>
<p>The script name or node command is available at <code>argv.$0</code> similarly to how <code>$0</code> works in bash or perl.</p>
<p>If <code>yargs</code> is executed in an environment that embeds node and there's no script name (e.g. <a href="http://electron.atom.io/">Electron</a> or <a href="http://nwjs.io/">nw.js</a>), it will ignore the first parameter since it expects it to be the script name. In order to override this behavior, use <code>.parse(process.argv.slice(1))</code> instead of <code>.argv</code> and the first parameter won't be ignored.</p>
<h2><a class="anchor" id="array"></a>.array(key) </h2>
<p>Tell the parser to interpret <code>key</code> as an array. If &lsquo;.array('foo&rsquo;)<code>is set, </code>&ndash;foo foo bar<code>will be parsed as</code>['foo', 'bar']<code>rather than as</code>'foo'`.</p>
<h2><a class="anchor" id="boolean"></a>.boolean(key) </h2>
<p>Interpret <code>key</code> as a boolean. If a non-flag option follows <code>key</code> in <code>process.argv</code>, that string won't get set as the value of <code>key</code>.</p>
<p><code>key</code> will default to <code>false</code>, unless a <code>default(key, undefined)</code> is explicitly set.</p>
<p>If <code>key</code> is an array, interpret all the elements as booleans.</p>
<h2>.check(fn, [global=true]) </h2>
<p>Check that certain conditions are met in the provided arguments.</p>
<p><code>fn</code> is called with two arguments, the parsed <code>argv</code> hash and an array of options and their aliases.</p>
<p>If <code>fn</code> throws or returns a non-truthy value, show the thrown error, usage information, and exit.</p>
<p><code>global</code> indicates whether <code>check()</code> should be enabled both at the top-level and for each sub-command.</p>
<h2><a class="anchor" id="choices"></a>.choices(key, choices) </h2>
<p>Limit valid values for <code>key</code> to a predefined set of <code>choices</code>, given as an array or as an individual value.</p>
<div class="fragment"><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">  .alias(&#39;i&#39;, &#39;ingredient&#39;)</div><div class="line">  .describe(&#39;i&#39;, &#39;choose your sandwich ingredients&#39;)</div><div class="line">  .choices(&#39;i&#39;, [&#39;peanut-butter&#39;, &#39;jelly&#39;, &#39;banana&#39;, &#39;pickles&#39;])</div><div class="line">  .help(&#39;help&#39;)</div><div class="line">  .argv</div></div><!-- fragment --><p>If this method is called multiple times, all enumerated values will be merged together. Choices are generally strings or numbers, and value matching is case-sensitive.</p>
<p>Optionally <code>.choices()</code> can take an object that maps multiple keys to their choices.</p>
<p>Choices can also be specified as <code>choices</code> in the object given to <code>option()</code>.</p>
<div class="fragment"><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">  .option(&#39;size&#39;, {</div><div class="line">    alias: &#39;s&#39;,</div><div class="line">    describe: &#39;choose a size&#39;,</div><div class="line">    choices: [&#39;xs&#39;, &#39;s&#39;, &#39;m&#39;, &#39;l&#39;, &#39;xl&#39;]</div><div class="line">  })</div><div class="line">  .argv</div></div><!-- fragment --><h2><a class="anchor" id="coerce"></a>.coerce(key, fn) </h2>
<p>Provide a synchronous function to coerce or transform the value(s) given on the command line for <code>key</code>.</p>
<p>The coercion function should accept one argument, representing the parsed value from the command line, and should return a new value or throw an error. The returned value will be used as the value for <code>key</code> (or one of its aliases) in <code>argv</code>.</p>
<p>If the function throws, the error will be treated as a validation failure, delegating to either a custom <a href="#fail"><code>.fail()</code></a> handler or printing the error message in the console.</p>
<p>Coercion will be applied to a value after all other modifications, such as <a href="#normalize"><code>.normalize()</code></a>.</p>
<p><em>Examples:</em></p>
<div class="fragment"><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">  .coerce(&#39;file&#39;, function (arg) {</div><div class="line">    return require(&#39;fs&#39;).readFileSync(arg, &#39;utf8&#39;)</div><div class="line">  })</div><div class="line">  .argv</div></div><!-- fragment --><p>Optionally <code>.coerce()</code> can take an object that maps several keys to their respective coercion function.</p>
<div class="fragment"><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">  .coerce({</div><div class="line">    date: Date.parse,</div><div class="line">    json: JSON.parse</div><div class="line">  })</div><div class="line">  .argv</div></div><!-- fragment --><p>You can also map the same function to several keys at one time. Just pass an array of keys as the first argument to <code>.coerce()</code>:</p>
<div class="fragment"><div class="line">var path = require(&#39;path&#39;)</div><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">  .coerce([&#39;src&#39;, &#39;dest&#39;], path.resolve)</div><div class="line">  .argv</div></div><!-- fragment --><p>If you are using dot-notion or arrays, .e.g., <code>user.email</code> and <code>user.password</code>, coercion will be applied to the final object that has been parsed:</p>
<div class="fragment"><div class="line">// --user.name Batman --user.password 123</div><div class="line">// gives us: {name: &#39;batman&#39;, password: &#39;[SECRET]&#39;}</div><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">  .option(&#39;user&#39;)</div><div class="line">  .coerce(&#39;user&#39;, opt =&gt; {</div><div class="line">    opt.name = opt.name.toLowerCase()</div><div class="line">    opt.password = &#39;[SECRET]&#39;</div><div class="line">    return opt</div><div class="line">  })</div><div class="line">  .argv</div></div><!-- fragment --><h2>.command(cmd, desc, [builder], [handler]) </h2>
<h2>.command(cmd, desc, [module]) </h2>
<h2>.command(module) </h2>
<p>Define the commands exposed by your application.</p>
<p><code>cmd</code> should be a string representing the command or an array of strings representing the command and its aliases. Read more about command aliases in the subsection below.</p>
<p>Use <code>desc</code> to provide a description for each command your application accepts (the values stored in <code>argv._</code>). Set <code>desc</code> to <code>false</code> to create a hidden command. Hidden commands don't show up in the help output and aren't available for completion.</p>
<p>Optionally, you can provide a <code>builder</code> object to give hints about the options that your command accepts:</p>
<div class="fragment"><div class="line">yargs</div><div class="line">  .command(&#39;get&#39;, &#39;make a get HTTP request&#39;, {</div><div class="line">    url: {</div><div class="line">      alias: &#39;u&#39;,</div><div class="line">      default: &#39;http://yargs.js.org/&#39;</div><div class="line">    }</div><div class="line">  })</div><div class="line">  .help()</div><div class="line">  .argv</div></div><!-- fragment --><p><code>builder</code> can also be a function. This function is executed with a <code>yargs</code> instance, and can be used to provide <em>advanced</em> command specific help:</p>
<div class="fragment"><div class="line">yargs</div><div class="line">  .command(&#39;get&#39;, &#39;make a get HTTP request&#39;, function (yargs) {</div><div class="line">    return yargs.option(&#39;url&#39;, {</div><div class="line">      alias: &#39;u&#39;,</div><div class="line">      default: &#39;http://yargs.js.org/&#39;</div><div class="line">    })</div><div class="line">  })</div><div class="line">  .help()</div><div class="line">  .argv</div></div><!-- fragment --><p>You can also provide a handler function, which will be executed with the parsed <code>argv</code> object:</p>
<div class="fragment"><div class="line">yargs</div><div class="line">  .command(</div><div class="line">    &#39;get&#39;,</div><div class="line">    &#39;make a get HTTP request&#39;,</div><div class="line">    function (yargs) {</div><div class="line">      return yargs.option(&#39;u&#39;, {</div><div class="line">        alias: &#39;url&#39;,</div><div class="line">        describe: &#39;the URL to make an HTTP request to&#39;</div><div class="line">      })</div><div class="line">    },</div><div class="line">    function (argv) {</div><div class="line">      console.log(argv.url)</div><div class="line">    }</div><div class="line">  )</div><div class="line">  .help()</div><div class="line">  .argv</div></div><!-- fragment --><h3>Default Commands</h3>
<p>To specify a default command use the character <code>*</code>. A default command will be run if the positional arguments provided match no known commands:</p>
<div class="fragment"><div class="line">const argv = require(&#39;yargs&#39;)</div><div class="line">  .command(&#39;*&#39;, &#39;the default command&#39;, () =&gt; {}, (argv) =&gt; {</div><div class="line">    console.log(&#39;this command will be run by default&#39;)</div><div class="line">  })</div></div><!-- fragment --><p>The command defined above will be executed if the program is run with <code>./my-cli.js --x=22</code>.</p>
<p>Default commands can also be used as a command alias, like so:</p>
<div class="fragment"><div class="line">const argv = require(&#39;yargs&#39;)</div><div class="line">  .command([&#39;serve&#39;, &#39;*&#39;], &#39;the serve command&#39;, () =&gt; {}, (argv) =&gt; {</div><div class="line">    console.log(&#39;this command will be run by default&#39;)</div><div class="line">  })</div></div><!-- fragment --><p>The command defined above will be executed if the program is run with <code>./my-cli.js --x=22</code>, or with <code>./my-cli.js serve --x=22</code>.</p>
<h3>Positional Arguments</h3>
<p>Commands can accept <em>optional</em> and <em>required</em> positional arguments. Required positional arguments take the form <code>&lt;foo&gt;</code>, and optional arguments take the form <code>[bar]</code>. The parsed positional arguments will be populated in <code>argv</code>:</p>
<div class="fragment"><div class="line">yargs.command(&#39;get &lt;source&gt; [proxy]&#39;, &#39;make a get HTTP request&#39;)</div><div class="line">  .help()</div><div class="line">  .argv</div></div><!-- fragment --><h4>Positional Argument Aliases</h4>
<p>Aliases can be provided for positional arguments using the <code>|</code> character. As an example, suppose our application allows either a username <em>or</em> an email as the first argument:</p>
<div class="fragment"><div class="line">yargs.command(&#39;get &lt;username|email&gt; [password]&#39;, &#39;fetch a user by username or email.&#39;)</div><div class="line">  .help()</div><div class="line">  .argv</div></div><!-- fragment --><p>In this way, both <code>argv.username</code> and <code>argv.email</code> would be populated with the same value when the command is executed.</p>
<h4>Variadic Positional Arguments</h4>
<p>The last positional argument can optionally accept an array of values, by using the <code>..</code> operator:</p>
<div class="fragment"><div class="line">yargs.command(&#39;download &lt;url&gt; [files..]&#39;, &#39;download several files&#39;)</div><div class="line">  .help()</div><div class="line">  .argv</div></div><!-- fragment --><h3>Command Execution</h3>
<p>When a command is given on the command line, yargs will execute the following:</p>
<ol type="1">
<li>push the command into the current context</li>
<li>reset non-global configuration</li>
<li>apply command configuration via the <code>builder</code>, if given</li>
<li>parse and validate args from the command line, including positional args</li>
<li>if validation succeeds, run the <code>handler</code> function, if given</li>
<li>pop the command from the current context</li>
</ol>
<h3>Command Aliases</h3>
<p>You can define aliases for a command by putting the command and all of its aliases into an array.</p>
<p>Alternatively, a command module may specify an <code>aliases</code> property, which may be a string or an array of strings. All aliases defined via the <code>command</code> property and the <code>aliases</code> property will be concatenated together.</p>
<p>The first element in the array is considered the canonical command, which may define positional arguments, and the remaining elements in the array are considered aliases. Aliases inherit positional args from the canonical command, and thus any positional args defined in the aliases themselves are ignored.</p>
<p>If either the canonical command or any of its aliases are given on the command line, the command will be executed.</p>
<div class="fragment"><div class="line">#!/usr/bin/env node</div><div class="line">require(&#39;yargs&#39;)</div><div class="line">  .command([&#39;start [app]&#39;, &#39;run&#39;, &#39;up&#39;], &#39;Start up an app&#39;, {}, (argv) =&gt; {</div><div class="line">    console.log(&#39;starting up the&#39;, argv.app || &#39;default&#39;, &#39;app&#39;)</div><div class="line">  })</div><div class="line">  .command({</div><div class="line">    command: &#39;configure &lt;key&gt; [value]&#39;,</div><div class="line">    aliases: [&#39;config&#39;, &#39;cfg&#39;],</div><div class="line">    desc: &#39;Set a config variable&#39;,</div><div class="line">    builder: (yargs) =&gt; yargs.default(&#39;value&#39;, &#39;true&#39;),</div><div class="line">    handler: (argv) =&gt; {</div><div class="line">      console.log(`setting ${argv.key} to ${argv.value}`)</div><div class="line">    }</div><div class="line">  })</div><div class="line">  .demandCommand()</div><div class="line">  .help()</div><div class="line">  .wrap(72)</div><div class="line">  .argv</div></div><!-- fragment --><div class="fragment"><div class="line">$ ./svc.js help</div><div class="line">Commands:</div><div class="line">  start [app]              Start up an app            [aliases: run, up]</div><div class="line">  configure &lt;key&gt; [value]  Set a config variable  [aliases: config, cfg]</div><div class="line"></div><div class="line">Options:</div><div class="line">  --help  Show help                                            [boolean]</div><div class="line"></div><div class="line">$ ./svc.js cfg concurrency 4</div><div class="line">setting concurrency to 4</div><div class="line"></div><div class="line">$ ./svc.js run web</div><div class="line">starting up the web app</div></div><!-- fragment --><h3>Providing a Command Module</h3>
<p>For complicated commands you can pull the logic into a module. A module simply needs to export:</p>
<ul>
<li><code>exports.command</code>: string (or array of strings) that executes this command when given on the command line, first string may contain positional args</li>
<li><code>exports.aliases</code>: array of strings (or a single string) representing aliases of <code>exports.command</code>, positional args defined in an alias are ignored</li>
<li><code>exports.describe</code>: string used as the description for the command in help text, use <code>false</code> for a hidden command</li>
<li><code>exports.builder</code>: object declaring the options the command accepts, or a function accepting and returning a yargs instance</li>
<li><code>exports.handler</code>: a function which will be passed the parsed argv.</li>
</ul>
<div class="fragment"><div class="line">// my-module.js</div><div class="line">exports.command = &#39;get &lt;source&gt; [proxy]&#39;</div><div class="line"></div><div class="line">exports.describe = &#39;make a get HTTP request&#39;</div><div class="line"></div><div class="line">exports.builder = {</div><div class="line">  banana: {</div><div class="line">    default: &#39;cool&#39;</div><div class="line">  },</div><div class="line">  batman: {</div><div class="line">    default: &#39;sad&#39;</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line">exports.handler = function (argv) {</div><div class="line">  // do something with argv.</div><div class="line">}</div></div><!-- fragment --><p>You then register the module like so:</p>
<div class="fragment"><div class="line">yargs.command(require(&#39;my-module&#39;))</div><div class="line">  .help()</div><div class="line">  .argv</div></div><!-- fragment --><p>Or if the module does not export <code>command</code> and <code>describe</code> (or if you just want to override them):</p>
<div class="fragment"><div class="line">yargs.command(&#39;get &lt;source&gt; [proxy]&#39;, &#39;make a get HTTP request&#39;, require(&#39;my-module&#39;))</div><div class="line">  .help()</div><div class="line">  .argv</div></div><!-- fragment --><h2>.commandDir(directory, [opts]) </h2>
<p>Apply command modules from a directory relative to the module calling this method.</p>
<p>This allows you to organize multiple commands into their own modules under a single directory and apply all of them at once instead of calling &lsquo;.command(require(&rsquo;./dir/module'))` multiple times.</p>
<p>By default, it ignores subdirectories. This is so you can use a directory structure to represent your command hierarchy, where each command applies its subcommands using this method in its builder function. See the example below.</p>
<p>Note that yargs assumes all modules in the given directory are command modules and will error if non-command modules are encountered. In this scenario, you can either move your module to a different directory or use the <code>exclude</code> or <code>visit</code> option to manually filter it out. More on that below.</p>
<p><code>directory</code> is a relative directory path as a string (required).</p>
<p><code>opts</code> is an options object (optional). The following options are valid:</p>
<ul>
<li><p class="startli"><code>recurse</code>: boolean, default <code>false</code></p>
<p class="startli">Look for command modules in all subdirectories and apply them as a flattened (non-hierarchical) list.</p>
</li>
<li><p class="startli"><code>extensions</code>: array of strings, default &lsquo;['js&rsquo;]`</p>
<p class="startli">The types of files to look for when requiring command modules.</p>
</li>
<li><p class="startli"><code>visit</code>: function</p>
<p class="startli">A synchronous function called for each command module encountered. Accepts <code>commandObject</code>, <code>pathToFile</code>, and <code>filename</code> as arguments. Returns <code>commandObject</code> to include the command; any falsy value to exclude/skip it.</p>
</li>
<li><p class="startli"><code>include</code>: RegExp or function</p>
<p class="startli">Whitelist certain modules. See <a href="https://www.npmjs.com/package/require-directory#whitelisting"><code>require-directory</code> whitelisting</a> for details.</p>
</li>
<li><p class="startli"><code>exclude</code>: RegExp or function</p>
<p class="startli">Blacklist certain modules. See <a href="https://www.npmjs.com/package/require-directory#blacklisting"><code>require-directory</code> blacklisting</a> for details.</p>
</li>
</ul>
<h3>Example command hierarchy using <code>.commandDir()</code></h3>
<p>Desired CLI:</p>
<div class="fragment"><div class="line">$ myapp --help</div><div class="line">$ myapp init</div><div class="line">$ myapp remote --help</div><div class="line">$ myapp remote add base http://yargs.js.org</div><div class="line">$ myapp remote prune base</div><div class="line">$ myapp remote prune base fork whatever</div></div><!-- fragment --><p>Directory structure:</p>
<div class="fragment"><div class="line">myapp/</div><div class="line">├─ cli.js</div><div class="line">└─ cmds/</div><div class="line">   ├─ init.js</div><div class="line">   ├─ remote.js</div><div class="line">   └─ remote_cmds/</div><div class="line">      ├─ add.js</div><div class="line">      └─ prune.js</div></div><!-- fragment --><p>cli.js:</p>
<div class="fragment"><div class="line">#!/usr/bin/env node</div><div class="line">require(&#39;yargs&#39;)</div><div class="line">  .commandDir(&#39;cmds&#39;)</div><div class="line">  .demandCommand()</div><div class="line">  .help()</div><div class="line">  .argv</div></div><!-- fragment --><p>cmds/init.js:</p>
<div class="fragment"><div class="line">exports.command = &#39;init [dir]&#39;</div><div class="line">exports.desc = &#39;Create an empty repo&#39;</div><div class="line">exports.builder = {</div><div class="line">  dir: {</div><div class="line">    default: &#39;.&#39;</div><div class="line">  }</div><div class="line">}</div><div class="line">exports.handler = function (argv) {</div><div class="line">  console.log(&#39;init called for dir&#39;, argv.dir)</div><div class="line">}</div></div><!-- fragment --><p>cmds/remote.js:</p>
<div class="fragment"><div class="line">exports.command = &#39;remote &lt;command&gt;&#39;</div><div class="line">exports.desc = &#39;Manage set of tracked repos&#39;</div><div class="line">exports.builder = function (yargs) {</div><div class="line">  return yargs.commandDir(&#39;remote_cmds&#39;)</div><div class="line">}</div><div class="line">exports.handler = function (argv) {}</div></div><!-- fragment --><p>cmds/remote_cmds/add.js:</p>
<div class="fragment"><div class="line">exports.command = &#39;add &lt;name&gt; &lt;url&gt;&#39;</div><div class="line">exports.desc = &#39;Add remote named &lt;name&gt; for repo at url &lt;url&gt;&#39;</div><div class="line">exports.builder = {}</div><div class="line">exports.handler = function (argv) {</div><div class="line">  console.log(&#39;adding remote %s at url %s&#39;, argv.name, argv.url)</div><div class="line">}</div></div><!-- fragment --><p>cmds/remote_cmds/prune.js:</p>
<div class="fragment"><div class="line">exports.command = &#39;prune &lt;name&gt; [names..]&#39;</div><div class="line">exports.desc = &#39;Delete tracked branches gone stale for remotes&#39;</div><div class="line">exports.builder = {}</div><div class="line">exports.handler = function (argv) {</div><div class="line">  console.log(&#39;pruning remotes %s&#39;, [].concat(argv.name).concat(argv.names).join(&#39;, &#39;))</div><div class="line">}</div></div><!-- fragment --><h2>.completion([cmd], [description], [fn]) </h2>
<p>Enable bash-completion shortcuts for commands and options.</p>
<p><code>cmd</code>: When present in <code>argv._</code>, will result in the <code>.bashrc</code> completion script being outputted. To enable bash completions, concat the generated script to your <code>.bashrc</code> or <code>.bash_profile</code>.</p>
<p><code>description</code>: Provide a description in your usage instructions for the command that generates bash completion scripts.</p>
<p><code>fn</code>: Rather than relying on yargs' default completion functionality, which shiver me timbers is pretty awesome, you can provide your own completion method.</p>
<p>If invoked without parameters, <code>.completion()</code> will make <code>completion</code> the command to output the completion script.</p>
<div class="fragment"><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">  .completion(&#39;completion&#39;, function(current, argv) {</div><div class="line">    // &#39;current&#39; is the current command being completed.</div><div class="line">    // &#39;argv&#39; is the parsed arguments so far.</div><div class="line">    // simply return an array of completions.</div><div class="line">    return [</div><div class="line">      &#39;foo&#39;,</div><div class="line">      &#39;bar&#39;</div><div class="line">    ];</div><div class="line">  })</div><div class="line">  .argv;</div></div><!-- fragment --><p>You can also provide asynchronous completions.</p>
<div class="fragment"><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">  .completion(&#39;completion&#39;, function(current, argv, done) {</div><div class="line">    setTimeout(function() {</div><div class="line">      done([</div><div class="line">        &#39;apple&#39;,</div><div class="line">        &#39;banana&#39;</div><div class="line">      ]);</div><div class="line">    }, 500);</div><div class="line">  })</div><div class="line">  .argv;</div></div><!-- fragment --><p>But wait, there's more! You can return an asynchronous promise.</p>
<div class="fragment"><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">  .completion(&#39;completion&#39;, function(current, argv, done) {</div><div class="line">    return new Promise(function (resolve, reject) {</div><div class="line">      setTimeout(function () {</div><div class="line">        resolve([&#39;apple&#39;, &#39;banana&#39;])</div><div class="line">      }, 10)</div><div class="line">    })</div><div class="line">  })</div><div class="line">  .argv;</div></div><!-- fragment --><h2><a class="anchor" id="config"></a>.config([key], [description], [parseFn]) </h2>
<h2>.config(object) </h2>
<p>Tells the parser that if the option specified by <code>key</code> is passed in, it should be interpreted as a path to a JSON config file. The file is loaded and parsed, and its properties are set as arguments. Because the file is loaded using Node's require(), the filename MUST end in <code>.json</code> to be interpreted correctly.</p>
<p>If invoked without parameters, <code>.config()</code> will make <code>--config</code> the option to pass the JSON config file.</p>
<p>An optional <code>description</code> can be provided to customize the config (<code>key</code>) option in the usage string.</p>
<p>An optional <code>parseFn</code> can be used to provide a custom parser. The parsing function must be synchronous, and should return an object containing key value pairs or an error.</p>
<div class="fragment"><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">  .config(&#39;settings&#39;, function (configPath) {</div><div class="line">    return JSON.parse(fs.readFileSync(configPath, &#39;utf-8&#39;))</div><div class="line">  })</div><div class="line">  .argv</div></div><!-- fragment --><p>You can also pass an explicit configuration <code>object</code>, it will be parsed and its properties will be set as arguments.</p>
<div class="fragment"><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">  .config({foo: 1, bar: 2})</div><div class="line">  .argv</div><div class="line">console.log(argv)</div></div><!-- fragment --><div class="fragment"><div class="line">$ node test.js</div><div class="line">{ _: [],</div><div class="line">  foo: 1,</div><div class="line">  bar: 2,</div><div class="line">  &#39;$0&#39;: &#39;test.js&#39; }</div></div><!-- fragment --><p>Note that a configuration object may extend from a JSON file using the <code>"extends"</code> property. When doing so, the <code>"extends"</code> value should be a path (relative or absolute) to the extended JSON file.</p>
<h2><a class="anchor" id="conflicts"></a>.conflicts(x, y) </h2>
<p>Given the key <code>x</code> is set, the key <code>y</code> must not be set.</p>
<p>Optionally <code>.conflicts()</code> can accept an object specifying multiple conflicting keys.</p>
<h2><a class="anchor" id="count"></a>.count(key) </h2>
<p>Interpret <code>key</code> as a boolean flag, but set its parsed value to the number of flag occurrences rather than <code>true</code> or <code>false</code>. Default value is thus <code>0</code>.</p>
<h2><a class="anchor" id="default"></a>.default(key, value, [description]) </h2>
<h2>.defaults(key, value, [description]) </h2>
<p><b>Note:</b> The <code>.defaults()</code> alias is deprecated. It will be removed in the next major version.</p>
<p>Set <code>argv[key]</code> to <code>value</code> if no option was specified in <code>process.argv</code>.</p>
<p>Optionally <code>.default()</code> can take an object that maps keys to default values.</p>
<p>But wait, there's more! The default value can be a <code>function</code> which returns a value. The name of the function will be used in the usage string:</p>
<div class="fragment"><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">  .default(&#39;random&#39;, function randomValue() {</div><div class="line">    return Math.random() * 256;</div><div class="line">  }).argv;</div></div><!-- fragment --><p>Optionally, <code>description</code> can also be provided and will take precedence over displaying the value in the usage instructions:</p>
<div class="fragment"><div class="line">.default(&#39;timeout&#39;, 60000, &#39;(one-minute)&#39;)</div></div><!-- fragment --><h2><a class="anchor" id="demand"></a>.demand(count, [max], [msg]) [DEPRECATED] </h2>
<p><code>demand()</code> has been deprecated, please instead see <a href="#demandOption"><code>demandOption()</code></a> and <a href="#demandCommand"><code>demandCommand()</code></a>.</p>
<h2><a class="anchor" id="demandOption"></a>.demandOption(key, [msg | boolean]) </h2>
<h2>.demandOption(key, msg) </h2>
<p>If <code>key</code> is a string, show the usage information and exit if <code>key</code> wasn't specified in <code>process.argv</code>.</p>
<p>If <code>key</code> is an array, demand each element.</p>
<p>If a <code>msg</code> string is given, it will be printed when the argument is missing, instead of the standard error message.</p>
<div class="fragment"><div class="line">// demand an array of keys to be provided</div><div class="line">require(&#39;yargs&#39;)</div><div class="line">  .option(&#39;run&#39;, {</div><div class="line">    alias: &#39;r&#39;,</div><div class="line">    describe: &#39;run your program&#39;</div><div class="line">  })</div><div class="line">  .option(&#39;path&#39;, {</div><div class="line">    alias: &#39;p&#39;,</div><div class="line">    describe: &#39;provide a path to file&#39;</div><div class="line">  })</div><div class="line">  .option(&#39;spec&#39;, {</div><div class="line">    alias: &#39;s&#39;,</div><div class="line">    describe: &#39;program specifications&#39;</div><div class="line">  })</div><div class="line">  .demandOption([&#39;run&#39;, &#39;path&#39;], &#39;Please provide both run and path arguments to work with this tool&#39;)</div><div class="line">  .help()</div><div class="line">  .argv</div></div><!-- fragment --><p> which will provide the following output: </p><div class="fragment"><div class="line">Options:</div><div class="line">  --run, -r   run your program                [required]</div><div class="line">  --path, -p  provide a path to file          [required]</div><div class="line">  --spec, -s  program specifications</div><div class="line">  --help      Show help                        [boolean]</div><div class="line"></div><div class="line">  Missing required arguments: run, path</div><div class="line">  Please provide both run and path arguments to work with this tool</div></div><!-- fragment --><p>If a <code>boolean</code> value is given, it controls whether the option is demanded; this is useful when using <code>.options()</code> to specify command line parameters.</p>
<div class="fragment"><div class="line">// demand individual options within the option constructor</div><div class="line">require(&#39;yargs&#39;)</div><div class="line">  .options({</div><div class="line">    &#39;run&#39;: {</div><div class="line">      alias: &#39;r&#39;,</div><div class="line">      describe: &#39;run your program&#39;,</div><div class="line">      demandOption: true</div><div class="line">    },</div><div class="line">    &#39;path&#39;: {</div><div class="line">      alias: &#39;p&#39;,</div><div class="line">      describe: &#39;provide a path to file&#39;,</div><div class="line">      demandOption: true</div><div class="line">    },</div><div class="line">    &#39;spec&#39;: {</div><div class="line">      alias: &#39;s&#39;,</div><div class="line">      describe: &#39;program specifications&#39;</div><div class="line">    }</div><div class="line">  })</div><div class="line">  .help()</div><div class="line">  .argv</div></div><!-- fragment --><p> which will provide the following output: </p><div class="fragment"><div class="line">Options:</div><div class="line">  --run, -r   run your program                                       [required]</div><div class="line">  --path, -p  provide a path to file                                 [required]</div><div class="line">  --spec, -s  program specifications</div><div class="line">  --help      Show help                                               [boolean]</div><div class="line"></div><div class="line">Missing required arguments: run, path</div></div><!-- fragment --><h2><a class="anchor" id="demandCommand"></a>.demandCommand([min=1], [minMsg]) </h2>
<h2>.demandCommand([min=1], [max], [minMsg], [maxMsg]) </h2>
<p>Demand in context of commands. You can demand a minimum and a maximum number a user can have within your program, as well as provide corresponding error messages if either of the demands is not met. </p><div class="fragment"><div class="line">require(&#39;yargs&#39;)</div><div class="line">  .command({</div><div class="line">    command: &#39;configure &lt;key&gt; [value]&#39;,</div><div class="line">    aliases: [&#39;config&#39;, &#39;cfg&#39;],</div><div class="line">    desc: &#39;Set a config variable&#39;,</div><div class="line">    builder: (yargs) =&gt; yargs.default(&#39;value&#39;, &#39;true&#39;),</div><div class="line">    handler: (argv) =&gt; {</div><div class="line">      console.log(`setting ${argv.key} to ${argv.value}`)</div><div class="line">    }</div><div class="line">  })</div><div class="line">  // provide a minimum demand and a minimum demand message</div><div class="line">  .demandCommand(1, &#39;You need at least one command before moving on&#39;)</div><div class="line">  .help()</div><div class="line">  .argv</div></div><!-- fragment --><p>which will provide the following output:</p>
<div class="fragment"><div class="line">Commands:</div><div class="line">  configure &lt;key&gt; [value]  Set a config variable         [aliases: config, cfg]</div><div class="line"></div><div class="line">Options:</div><div class="line">  --help  Show help                                                   [boolean]</div><div class="line"></div><div class="line">You need at least one command before moving on</div></div><!-- fragment --><p><em>Note: in <code>minMsg</code> and <code>maxMsg</code>, every occurrence of <code>$0</code> will be replaced with the observed value, and every instance of <code>$1</code> will be replaced with the expected value.</em></p>
<h2><a class="anchor" id="describe"></a>.describe(key, desc) </h2>
<p>Describe a <code>key</code> for the generated usage information.</p>
<p>Optionally <code>.describe()</code> can take an object that maps keys to descriptions.</p>
<h2>.detectLocale(boolean) </h2>
<p>Should yargs attempt to detect the os' locale? Defaults to <code>true</code>.</p>
<h2>.env([prefix]) </h2>
<p>Tell yargs to parse environment variables matching the given prefix and apply them to argv as though they were command line arguments.</p>
<p>Use the "__" separator in the environment variable to indicate nested options. (e.g. prefix_nested__foo =&gt; nested.foo)</p>
<p>If this method is called with no argument or with an empty string or with <code>true</code>, then all env vars will be applied to argv.</p>
<p>Program arguments are defined in this order of precedence:</p>
<ol type="1">
<li>Command line args</li>
<li>Env vars</li>
<li>Config file/objects</li>
<li>Configured defaults</li>
</ol>
<div class="fragment"><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">  .env(&#39;MY_PROGRAM&#39;)</div><div class="line">  .option(&#39;f&#39;, {</div><div class="line">    alias: &#39;fruit-thing&#39;,</div><div class="line">    default: &#39;apple&#39;</div><div class="line">  })</div><div class="line">  .argv</div><div class="line">console.log(argv)</div></div><!-- fragment --><div class="fragment"><div class="line">$ node fruity.js</div><div class="line">{ _: [],</div><div class="line">  f: &#39;apple&#39;,</div><div class="line">  &#39;fruit-thing&#39;: &#39;apple&#39;,</div><div class="line">  fruitThing: &#39;apple&#39;,</div><div class="line">  &#39;$0&#39;: &#39;fruity.js&#39; }</div></div><!-- fragment --><div class="fragment"><div class="line">$ MY_PROGRAM_FRUIT_THING=banana node fruity.js</div><div class="line">{ _: [],</div><div class="line">  fruitThing: &#39;banana&#39;,</div><div class="line">  f: &#39;banana&#39;,</div><div class="line">  &#39;fruit-thing&#39;: &#39;banana&#39;,</div><div class="line">  &#39;$0&#39;: &#39;fruity.js&#39; }</div></div><!-- fragment --><div class="fragment"><div class="line">$ MY_PROGRAM_FRUIT_THING=banana node fruity.js -f cat</div><div class="line">{ _: [],</div><div class="line">  f: &#39;cat&#39;,</div><div class="line">  &#39;fruit-thing&#39;: &#39;cat&#39;,</div><div class="line">  fruitThing: &#39;cat&#39;,</div><div class="line">  &#39;$0&#39;: &#39;fruity.js&#39; }</div></div><!-- fragment --><p>Env var parsing is disabled by default, but you can also explicitly disable it by calling <code>.env(false)</code>, e.g. if you need to undo previous configuration.</p>
<h2>.epilog(str) </h2>
<h2>.epilogue(str) </h2>
<p>A message to print at the end of the usage instructions, e.g.</p>
<div class="fragment"><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">  .epilogue(&#39;for more information, find our manual at http://example.com&#39;);</div></div><!-- fragment --><h2>.example(cmd, desc) </h2>
<p>Give some example invocations of your program. Inside <code>cmd</code>, the string <code>$0</code> will get interpolated to the current script name or node command for the present script similar to how <code>$0</code> works in bash or perl. Examples will be printed out as part of the help message.</p>
<h2><a class="anchor" id="exitprocess"></a>.exitProcess(enable) </h2>
<p>By default, yargs exits the process when the user passes a help flag, uses the <code>.version</code> functionality, or when validation fails. Calling <code>.exitProcess(false)</code> disables this behavior, enabling further actions after yargs have been validated.</p>
<h2><a class="anchor" id="fail"></a>.fail(fn) </h2>
<p>Method to execute when a failure occurs, rather than printing the failure message.</p>
<p><code>fn</code> is called with the failure message that would have been printed, the <code>Error</code> instance originally thrown and yargs state when the failure occured.</p>
<div class="fragment"><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">  .fail(function (msg, err, yargs) {</div><div class="line">    if (err) throw err // preserve stack</div><div class="line">    console.error(&#39;You broke it!&#39;)</div><div class="line">    console.error(msg)</div><div class="line">    console.error(&#39;You should be doing&#39;, yargs.help())</div><div class="line">    process.exit(1)</div><div class="line">  })</div><div class="line">  .argv</div></div><!-- fragment --><h2>.getCompletion(args, done); </h2>
<p>Allows to programmatically get completion choices for any line.</p>
<p><code>args</code>: An array of the words in the command line to complete.</p>
<p><code>done</code>: The callback to be called with the resulting completions.</p>
<p>For example:</p>
<div class="fragment"><div class="line">require(&#39;yargs&#39;)</div><div class="line">  .option(&#39;foobar&#39;)</div><div class="line">  .option(&#39;foobaz&#39;)</div><div class="line">  .completion()</div><div class="line">  .getCompletion([&#39;./test.js&#39;, &#39;--foo&#39;], function (completions) {</div><div class="line">    console.log(completions)</div><div class="line">  })</div></div><!-- fragment --><p>Outputs the same completion choices as <code>./test.js --foo</code><code>TAB</code>: <code>--foobar</code> and <code>--foobaz</code></p>
<h2><a class="anchor" id="global"></a>.global(globals, [global=true]) </h2>
<p>Indicate that an option (or group of options) should not be reset when a command is executed, as an example:</p>
<div class="fragment"><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">  .option(&#39;a&#39;, {</div><div class="line">    alias: &#39;all&#39;,</div><div class="line">    default: true,</div><div class="line">    global: false</div><div class="line">  })</div><div class="line">  .option(&#39;n&#39;, {</div><div class="line">    alias: &#39;none&#39;,</div><div class="line">    default: true,</div><div class="line">    global: false</div><div class="line">  })</div><div class="line">  .command(&#39;foo&#39;, &#39;foo command&#39;, function (yargs) {</div><div class="line">    return yargs.option(&#39;b&#39;, {</div><div class="line">      alias: &#39;bar&#39;</div><div class="line">    })</div><div class="line">  })</div><div class="line">  .help(&#39;help&#39;)</div><div class="line">  .global(&#39;a&#39;)</div><div class="line">  .argv</div></div><!-- fragment --><p>If the <code>foo</code> command is executed the <code>all</code> option will remain, but the <code>none</code> option will have been eliminated.</p>
<p>Options default to being global.</p>
<h2><a class="anchor" id="group"></a>.group(key(s), groupName) </h2>
<p>Given a key, or an array of keys, places options under an alternative heading when displaying usage instructions, e.g.,</p>
<div class="fragment"><div class="line">var yargs = require(&#39;yargs&#39;)([&#39;--help&#39;])</div><div class="line">  .help()</div><div class="line">  .group(&#39;batman&#39;, &#39;Heroes:&#39;)</div><div class="line">  .describe(&#39;batman&#39;, &quot;world&#39;s greatest detective&quot;)</div><div class="line">  .wrap(null)</div><div class="line">  .argv</div></div><!-- fragment --> <hr/>
<p> Heroes: &ndash;batman world's greatest detective</p>
<p>Options: &ndash;help Show help [boolean]</p>
<h2><a class="anchor" id="help"></a>.help() </h2>
<h2>.help([option | boolean]) </h2>
<h2>.help([option, [description | boolean]]) </h2>
<h2>.help([option, [description, [boolean]]]) </h2>
<p>Add an option (e.g. <code>--help</code>) and implicit command that displays the usage string and exits the process.</p>
<p>If present, the <code>description</code> parameter customizes the description of the help option in the usage string.</p>
<p>If a boolean argument is provided, it will enable or disable the use of an implicit command. The implicit command is enabled by default, but it can be disabled by passing <code>false</code>.</p>
<p>Note that any multi-char aliases (e.g. <code>help</code>) used for the help option will also be used for the implicit command. If there are no multi-char aliases (e.g. <code>h</code>), then all single-char aliases will be used for the command.</p>
<p>If invoked without parameters, <code>.help()</code> will use <code>--help</code> as the option and <code>help</code> as the implicit command to trigger help output.</p>
<p>Example:</p>
<div class="fragment"><div class="line">var yargs = require(&quot;yargs&quot;)([&#39;--help&#39;])</div><div class="line">  .usage(&quot;$0 -operand1 number -operand2 number -operation [add|subtract]&quot;)</div><div class="line">  .help()</div><div class="line">  .argv</div></div><!-- fragment --><p>Later on, <code>argv</code> can be retrieved with <code>yargs.argv</code>.</p>
<h2><a class="anchor" id="implies"></a>.implies(x, y) </h2>
<p>Given the key <code>x</code> is set, it is required that the key <code>y</code> is set.</p>
<p>Optionally <code>.implies()</code> can accept an object specifying multiple implications.</p>
<h2>.locale() </h2>
<p>Return the locale that yargs is currently using.</p>
<p>By default, yargs will auto-detect the operating system's locale so that yargs-generated help content will display in the user's language.</p>
<p>To override this behavior with a static locale, pass the desired locale as a string to this method (see below).</p>
<h2>.locale(locale) </h2>
<p>Override the auto-detected locale from the user's operating system with a static locale. Note that the OS locale can be modified by setting/exporting the <code>LC_ALL</code> environment variable.</p>
<div class="fragment"><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">  .usage(&#39;./$0 - follow ye instructions true&#39;)</div><div class="line">  .option(&#39;option&#39;, {</div><div class="line">    alias: &#39;o&#39;,</div><div class="line">    describe: &quot;&#39;tis a mighty fine option&quot;,</div><div class="line">    demandOption: true</div><div class="line">  })</div><div class="line">  .command(&#39;run&#39;, &quot;Arrr, ya best be knowin&#39; what yer doin&#39;&quot;)</div><div class="line">  .example(&#39;$0 run foo&#39;, &quot;shiver me timbers, here&#39;s an example for ye&quot;)</div><div class="line">  .help(&#39;help&#39;)</div><div class="line">  .wrap(70)</div><div class="line">  .locale(&#39;pirate&#39;)</div><div class="line">  .argv</div></div><!-- fragment --><hr/>
<div class="fragment"><div class="line">./test.js - follow ye instructions true</div><div class="line"></div><div class="line">Choose yer command:</div><div class="line">  run  Arrr, ya best be knowin&#39; what yer doin&#39;</div><div class="line"></div><div class="line">Options for me hearties!</div><div class="line">  --option, -o  &#39;tis a mighty fine option               [requi-yar-ed]</div><div class="line">  --help        Parlay this here code of conduct             [boolean]</div><div class="line"></div><div class="line">Ex. marks the spot:</div><div class="line">  test.js run foo  shiver me timbers, here&#39;s an example for ye</div><div class="line"></div><div class="line">Ye be havin&#39; to set the followin&#39; argument land lubber: option</div></div><!-- fragment --><p>Locales currently supported:</p>
<ul>
<li><b>de:</b> German.</li>
<li><b>en:</b> American English.</li>
<li><b>es:</b> Spanish.</li>
<li><b>fr:</b> French.</li>
<li><b>hi:</b> Hindi.</li>
<li><b>hu:</b> Hungarian.</li>
<li><b>id:</b> Indonesian.</li>
<li><b>it:</b> Italian.</li>
<li><b>ja:</b> Japanese.</li>
<li><b>ko:</b> Korean.</li>
<li><b>nb:</b> Norwegian Bokmål.</li>
<li><b>pirate:</b> American Pirate.</li>
<li><b>pl:</b> Polish.</li>
<li><b>pt:</b> Portuguese.</li>
<li><b>pt_BR:</b> Brazilian Portuguese.</li>
<li><b>ru:</b> Russian.</li>
<li><b>th:</b> Thai.</li>
<li><b>tr:</b> Turkish.</li>
<li><b>zh_CN:</b> Chinese.</li>
</ul>
<p>To submit a new translation for yargs:</p>
<ol type="1">
<li>use <code>./locales/en.json</code> as a starting point.</li>
<li>submit a pull request with the new locale file.</li>
</ol>
<p><em>The <a href="http://www.microsoft.com/Language/en-US/Search.aspx">Microsoft Terminology Search</a> can be useful for finding the correct terminology in your locale.</em></p>
<h2><a class="anchor" id="nargs"></a>.nargs(key, count) </h2>
<p>The number of arguments that should be consumed after a key. This can be a useful hint to prevent parsing ambiguity. For example:</p>
<div class="fragment"><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">  .nargs(&#39;token&#39;, 1)</div><div class="line">  .parse([&#39;--token&#39;, &#39;-my-token&#39;]);</div></div><!-- fragment --><p>parses as:</p>
<p>&lsquo;{ _: [], token: &rsquo;-my-token', '$0': 'node test' }`</p>
<p>Optionally <code>.nargs()</code> can take an object of <code>key</code>/<code>narg</code> pairs.</p>
<h2><a class="anchor" id="normalize"></a>.normalize(key) </h2>
<p>The key provided represents a path and should have <code>path.normalize()</code> applied.</p>
<h2><a class="anchor" id="number"></a>.number(key) </h2>
<p>Tell the parser to always interpret <code>key</code> as a number.</p>
<p>If <code>key</code> is an array, all elements will be parsed as numbers.</p>
<p>If the option is given on the command line without a value, <code>argv</code> will be populated with <code>undefined</code>.</p>
<p>If the value given on the command line cannot be parsed as a number, <code>argv</code> will be populated with <code>NaN</code>.</p>
<p>Note that decimals, hexadecimals, and scientific notation are all accepted.</p>
<div class="fragment"><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">  .number(&#39;n&#39;)</div><div class="line">  .number([&#39;width&#39;, &#39;height&#39;])</div><div class="line">  .argv</div></div><!-- fragment --><h2>.option(key, [opt]) </h2>
<h2>.options(key, [opt]) </h2>
<p>This method can be used to make yargs aware of options that <em>could</em> exist. You can also pass an <code>opt</code> object which can hold further customization, like <code>.alias()</code>, <code>.demandOption()</code> etc. for that option.</p>
<p>For example:</p>
<div class="fragment"><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">    .option(&#39;f&#39;, {</div><div class="line">        alias: &#39;file&#39;,</div><div class="line">        demandOption: true,</div><div class="line">        default: &#39;/etc/passwd&#39;,</div><div class="line">        describe: &#39;x marks the spot&#39;,</div><div class="line">        type: &#39;string&#39;</div><div class="line">    })</div><div class="line">    .argv</div><div class="line">;</div></div><!-- fragment --><p>is the same as</p>
<div class="fragment"><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">    .alias(&#39;f&#39;, &#39;file&#39;)</div><div class="line">    .demandOption(&#39;f&#39;)</div><div class="line">    .default(&#39;f&#39;, &#39;/etc/passwd&#39;)</div><div class="line">    .describe(&#39;f&#39;, &#39;x marks the spot&#39;)</div><div class="line">    .string(&#39;f&#39;)</div><div class="line">    .argv</div><div class="line">;</div></div><!-- fragment --><p>Optionally <code>.options()</code> can take an object that maps keys to <code>opt</code> parameters.</p>
<div class="fragment"><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">    .options({</div><div class="line">      &#39;f&#39;: {</div><div class="line">        alias: &#39;file&#39;,</div><div class="line">        demandOption: true,</div><div class="line">        default: &#39;/etc/passwd&#39;,</div><div class="line">        describe: &#39;x marks the spot&#39;,</div><div class="line">        type: &#39;string&#39;</div><div class="line">      }</div><div class="line">    })</div><div class="line">    .argv</div><div class="line">;</div></div><!-- fragment --><p>Valid <code>opt</code> keys include:</p>
<ul>
<li><code>alias</code>: string or array of strings, alias(es) for the canonical option key, see <a href="#alias"><code>alias()</code></a></li>
<li><code>array</code>: boolean, interpret option as an array, see <a href="#array"><code>array()</code></a></li>
<li><code>boolean</code>: boolean, interpret option as a boolean flag, see <a href="#boolean"><code>boolean()</code></a></li>
<li><code>choices</code>: value or array of values, limit valid option arguments to a predefined set, see <a href="#choices"><code>choices()</code></a></li>
<li><code>coerce</code>: function, coerce or transform parsed command line values into another value, see <a href="#coerce"><code>coerce()</code></a></li>
<li><code>config</code>: boolean, interpret option as a path to a JSON config file, see <a href="#config"><code>config()</code></a></li>
<li><code>configParser</code>: function, provide a custom config parsing function, see <a href="#config"><code>config()</code></a></li>
<li><code>conflicts</code>: string or object, require certain keys not to be set, see <a href="#conflicts"><code>conflicts()</code></a></li>
<li><code>count</code>: boolean, interpret option as a count of boolean flags, see <a href="#count"><code>count()</code></a></li>
<li><code>default</code>: value, set a default value for the option, see <a href="#default"><code>default()</code></a></li>
<li><code>defaultDescription</code>: string, use this description for the default value in help content, see <a href="#default"><code>default()</code></a></li>
<li><code>demandOption</code>: boolean or string, demand the option be given, with optional error message, see <a href="#demandOption"><code>demandOption()</code></a></li>
<li><code>desc</code>/<code>describe</code>/<code>description</code>: string, the option description for help content, see <a href="#describe"><code>describe()</code></a></li>
<li><code>global</code>: boolean, indicate that this key should not be <a href="#reset">reset</a> when a command is invoked, see <a href="#global"><code>global()</code></a></li>
<li><code>group</code>: string, when displaying usage instructions place the option under an alternative group heading, see <a href="#group"><code>group()</code></a></li>
<li><code>implies</code>: string or object, require certain keys to be set, see <a href="#implies"><code>implies()</code></a></li>
<li><code>nargs</code>: number, specify how many arguments should be consumed for the option, see <a href="#nargs"><code>nargs()</code></a></li>
<li><code>normalize</code>: boolean, apply <code>path.normalize()</code> to the option, see <a href="#normalize"><code>normalize()</code></a></li>
<li><code>number</code>: boolean, interpret option as a number, <a href="#number"><code>number()</code></a></li>
<li><code>requiresArg</code>: boolean, require the option be specified with a value, see <a href="#requiresArg"><code>requiresArg()</code></a></li>
<li><code>skipValidation</code>: boolean, skips validation if the option is present, see <a href="#skipValidation"><code>skipValidation()</code></a></li>
<li><code>string</code>: boolean, interpret option as a string, see <a href="#string"><code>string()</code></a></li>
<li><code>type</code>: one of the following strings<ul>
<li>&lsquo;'array&rsquo;<code>: synonymous for</code>array: true<code>, see [</code>array()<code>](#array) -</code>'boolean'<code>: synonymous for</code>boolean: true<code>, see [</code>boolean()<code>](#boolean) -</code>'count'<code>: synonymous for</code>count: true<code>, see [</code>count()<code>](#count) -</code>'number'<code>: synonymous for</code>number: true<code>, see [</code>number()<code>](#number) -</code>'string'<code>: synonymous for</code>string: true<code>, see [</code>string()`](#string)</li>
</ul>
</li>
</ul>
<h2>.parse(args, [context], [parseCallback]) </h2>
<p>Parse <code>args</code> instead of <code>process.argv</code>. Returns the <code>argv</code> object. <code>args</code> may either be a pre-processed argv array, or a raw argument string.</p>
<p>A <code>context</code> object can optionally be given as the second argument to <code>parse()</code>, providing a useful mechanism for passing state information to commands:</p>
<div class="fragment"><div class="line">const parser = yargs</div><div class="line">  .command(&#39;lunch-train &lt;restaurant&gt;&#39;, &#39;start lunch train&#39;, function () {}, function (argv) {</div><div class="line">    console.log(argv.restaurant, argv.time)</div><div class="line">  })</div><div class="line">  .parse(&quot;lunch-train rudy&#39;s&quot;, {time: &#39;12:15&#39;})</div></div><!-- fragment --><p>A <code>parseCallback</code> can also be provided to <code>.parse()</code>. If a callback is given, it will be invoked with three arguments:</p>
<ol type="1">
<li><code>err</code>: populated if any validation errors raised while parsing.</li>
<li><code>argv</code>: the parsed argv object.</li>
<li><code>output</code>: any text that would have been output to the terminal, had a callback not been provided.</li>
</ol>
<div class="fragment"><div class="line">// providing the `fn` argument to `parse()` runs yargs in headless mode, this</div><div class="line">// makes it easy to use yargs in contexts other than the CLI, e.g., writing</div><div class="line">// a chat-bot.</div><div class="line">const parser = yargs</div><div class="line">  .command(&#39;lunch-train &lt;restaurant&gt; &lt;time&gt;&#39;, &#39;start lunch train&#39;, function () {}, function (argv) {</div><div class="line">    api.scheduleLunch(argv.restaurant, moment(argv.time))</div><div class="line">  })</div><div class="line">  .help()</div><div class="line"></div><div class="line">parser.parse(bot.userText, function (err, argv, output) {</div><div class="line">  if (output) bot.respond(output)</div><div class="line">})</div></div><!-- fragment --><p><em><b>Note:</b></em> Providing a callback to <code>parse()</code> disables the <a href="#exitprocess"><code>exitProcess</code> setting</a> until after the callback is invoked.</p>
<h2>.pkgConf(key, [cwd]) </h2>
<p>Similar to <a href="#config"><code>config()</code></a>, indicates that yargs should interpret the object from the specified key in package.json as a configuration object.</p>
<p><code>cwd</code> can optionally be provided, the package.json will be read from this location.</p>
<p>Note that a configuration stanza in package.json may extend from an identically keyed stanza in another package.json file using the <code>"extends"</code> property. When doing so, the <code>"extends"</code> value should be a path (relative or absolute) to the extended package.json file.</p>
<h2>.recommendCommands() </h2>
<p>Should yargs provide suggestions regarding similar commands if no matching command is found?</p>
<h2>.require(key, [msg | boolean]) </h2>
<h2>.required(key, [msg | boolean]) </h2>
<p>An alias for <a href="#demand"><code>demand()</code></a>. See docs there.</p>
<h2><a class="anchor" id="requiresArg"></a>.requiresArg(key) </h2>
<p>Specifies either a single option key (string), or an array of options that must be followed by option values. If any option value is missing, show the usage information and exit.</p>
<p>The default behavior is to set the value of any key not followed by an option value to <code>true</code>.</p>
<h2><a class="anchor" id="reset"></a>.reset() </h2>
<p>Reset the argument object built up so far. This is useful for creating nested command line interfaces. Use <a href="#global">global</a> to specify keys that should not be reset.</p>
<div class="fragment"><div class="line">var yargs = require(&#39;yargs&#39;)</div><div class="line">  .usage(&#39;$0 command&#39;)</div><div class="line">  .command(&#39;hello&#39;, &#39;hello command&#39;)</div><div class="line">  .command(&#39;world&#39;, &#39;world command&#39;)</div><div class="line">  .demandCommand(1, &#39;must provide a valid command&#39;),</div><div class="line">  argv = yargs.argv,</div><div class="line">  command = argv._[0];</div><div class="line"></div><div class="line">if (command === &#39;hello&#39;) {</div><div class="line">  yargs.reset()</div><div class="line">    .usage(&#39;$0 hello&#39;)</div><div class="line">    .help(&#39;h&#39;)</div><div class="line">    .example(&#39;$0 hello&#39;, &#39;print the hello message!&#39;)</div><div class="line">    .argv</div><div class="line"></div><div class="line">  console.log(&#39;hello!&#39;);</div><div class="line">} else if (command === &#39;world&#39;){</div><div class="line">  yargs.reset()</div><div class="line">    .usage(&#39;$0 world&#39;)</div><div class="line">    .help(&#39;h&#39;)</div><div class="line">    .example(&#39;$0 world&#39;, &#39;print the world message!&#39;)</div><div class="line">    .argv</div><div class="line"></div><div class="line">  console.log(&#39;world!&#39;);</div><div class="line">} else {</div><div class="line">  yargs.showHelp();</div><div class="line">}</div></div><!-- fragment --><h2>.showCompletionScript() </h2>
<p>Generate a bash completion script. Users of your application can install this script in their <code>.bashrc</code>, and yargs will provide completion shortcuts for commands and options.</p>
<h2>.showHelp(consoleLevel='error') </h2>
<p>Print the usage data using the <a href="https://nodejs.org/api/console.html"><code>console</code></a> function <code>consoleLevel</code> for printing.</p>
<p>Example:</p>
<div class="fragment"><div class="line">var yargs = require(&quot;yargs&quot;)</div><div class="line">  .usage(&quot;$0 -operand1 number -operand2 number -operation [add|subtract]&quot;);</div><div class="line">yargs.showHelp(); //prints to stderr using console.error()</div></div><!-- fragment --><p>Or, to print the usage data to <code>stdout</code> instead, you can specify the use of <code>console.log</code>:</p>
<div class="fragment"><div class="line">yargs.showHelp(&quot;log&quot;); //prints to stdout using console.log()</div></div><!-- fragment --><p>Later on, <code>argv</code> can be retrieved with <code>yargs.argv</code>.</p>
<h2>.showHelpOnFail(enable, [message]) </h2>
<p>By default, yargs outputs a usage string if any error is detected. Use the <code>.showHelpOnFail()</code> method to customize this behavior. If <code>enable</code> is <code>false</code>, the usage string is not output. If the <code>message</code> parameter is present, this message is output after the error message.</p>
<p>line_count.js:</p>
<div class="fragment"><div class="line">#!/usr/bin/env node</div><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">    .usage(&#39;Count the lines in a file.\nUsage: $0 -f &lt;file&gt;&#39;)</div><div class="line">    .demandOption(&#39;f&#39;)</div><div class="line">    .alias(&#39;f&#39;, &#39;file&#39;)</div><div class="line">    .describe(&#39;f&#39;, &#39;Load a file&#39;)</div><div class="line">    .string(&#39;f&#39;)</div><div class="line">    .showHelpOnFail(false, &#39;Specify --help for available options&#39;)</div><div class="line">    .help(&#39;help&#39;)</div><div class="line">    .argv;</div><div class="line"></div><div class="line">// etc.</div></div><!-- fragment --><hr/>
<div class="fragment"><div class="line">$ node line_count.js</div><div class="line">Missing argument value: f</div><div class="line"></div><div class="line">Specify --help for available options</div></div><!-- fragment --><h2><a class="anchor" id="skipValidation"></a>.skipValidation(key) </h2>
<p>Specifies either a single option key (string), or an array of options. If any of the options is present, yargs validation is skipped.</p>
<h2>.strict([global=true]) </h2>
<p>Any command-line argument given that is not demanded, or does not have a corresponding description, will be reported as an error.</p>
<p><code>global</code> indicates whether <code>strict()</code> should be enabled both at the top-level and for each sub-command.</p>
<h2><a class="anchor" id="string"></a>.string(key) </h2>
<p>Tell the parser logic not to interpret <code>key</code> as a number or boolean. This can be useful if you need to preserve leading zeros in an input.</p>
<p>If <code>key</code> is an array, interpret all the elements as strings.</p>
<p>&lsquo;.string(&rsquo;_')` will result in non-hyphenated arguments being interpreted as strings, regardless of whether they resemble numbers.</p>
<h2>.updateLocale(obj) </h2>
<h2>.updateStrings(obj) </h2>
<p>Override the default strings used by yargs with the key/value pairs provided in <code>obj</code>:</p>
<div class="fragment"><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">  .command(&#39;run&#39;, &#39;the run command&#39;)</div><div class="line">  .help(&#39;help&#39;)</div><div class="line">  .updateStrings({</div><div class="line">    &#39;Commands:&#39;: &#39;My Commands --&gt;\n&#39;</div><div class="line">  })</div><div class="line">  .wrap(null)</div><div class="line">  .argv</div></div><!-- fragment --><hr/>
<div class="fragment"><div class="line">My Commands --&gt;</div><div class="line"></div><div class="line">  run  the run command</div><div class="line"></div><div class="line">Options:</div><div class="line">  --help  Show help  [boolean]</div></div><!-- fragment --><p>If you explicitly specify a <code>locale()</code>, you should do so <em>before</em> calling <code>updateStrings()</code>.</p>
<h2>.usage(message, [opts]) </h2>
<p>Set a usage message to show which commands to use. Inside <code>message</code>, the string <code>$0</code> will get interpolated to the current script name or node command for the present script similar to how <code>$0</code> works in bash or perl.</p>
<p><code>opts</code> is optional and acts like calling <code>.options(opts)</code>.</p>
<h2><a class="anchor" id="version"></a>.version([option], [description], [version]) </h2>
<p>Add an option (e.g. <code>--version</code>) that displays the version number (given by the <code>version</code> parameter) and exits the process.</p>
<p>If no arguments are passed to <code>version</code> (<code>.<a class="el" href="namespacesetup.html#a2aa722b36a933088812b50ea79b97a5c">version()</a></code>), yargs will parse the <code>package.json</code> of your module and use its <code>version</code> value. The default value of <code>option</code> is <code>--version</code>.</p>
<p>You can provide a <code>function</code> for version, rather than a string. This is useful if you want to use a version stored in a location other than package.json:</p>
<div class="fragment"><div class="line">var argv = require(&#39;yargs&#39;)</div><div class="line">  .version(function() {</div><div class="line">    return require(&#39;../lib/version&#39;).version;</div><div class="line">  })</div><div class="line">  .argv;</div></div><!-- fragment --><h2><a class="anchor" id="wrap"></a>.wrap(columns) </h2>
<p>Format usage output to wrap at <code>columns</code> many columns.</p>
<p>By default wrap will be set to <code>Math.min(80, windowWidth)</code>. Use <code>.wrap(null)</code> to specify no column limit (no right-align). Use <code>.wrap(yargs.terminalWidth())</code> to maximize the width of yargs' usage instructions.</p>
<h1>parsing tricks </h1>
<h2>stop parsing </h2>
<p>Use <code>--</code> to stop parsing flags and stuff the remainder into <code>argv._</code>. </p><pre class="fragment">$ node examples/reflect.js -a 1 -b 2 -- -c 3 -d 4
{ _: [ '-c', '3', '-d', '4' ],
  a: 1,
  b: 2,
  '$0': 'examples/reflect.js' }
</pre><h2>negate fields </h2>
<p>If you want to explicitly set a field to false instead of just leaving it undefined or to override a default you can do <code>--no-key</code>. </p><pre class="fragment">$ node examples/reflect.js -a --no-b
{ _: [], a: true, b: false, '$0': 'examples/reflect.js' }
</pre><h2>numbers </h2>
<p>Every argument that looks like a number (<code>!isNaN(Number(arg))</code>) is converted to one. This way you can just <code>net.createConnection(argv.port)</code> and you can add numbers out of <code>argv</code> with <code>+</code> without having that mean concatenation, which is super frustrating.</p>
<h2>duplicates </h2>
<p>If you specify a flag multiple times it will get turned into an array containing all the values in order. </p><pre class="fragment">$ node examples/reflect.js -x 5 -x 8 -x 0
{ _: [], x: [ 5, 8, 0 ], '$0': 'examples/reflect.js' }
</pre><h2>dot notation </h2>
<p>When you use dots (<code>.</code>s) in argument names, an implicit object path is assumed. This lets you organize arguments into nested objects. </p><pre class="fragment">$ node examples/reflect.js --foo.bar.baz=33 --foo.quux=5
{ _: [],
  foo: { bar: { baz: 33 }, quux: 5 },
  '$0': 'examples/reflect.js' }
</pre><h2>short numbers </h2>
<p>Short numeric <code>-n5</code> style arguments work too: </p><pre class="fragment">$ node examples/reflect.js -n123 -m456
{ _: [], n: 123, m: 456, '$0': 'examples/reflect.js' }
</pre><h1>installation </h1>
<p>With <a href="https://github.com/npm/npm">npm</a>, just do: </p><pre class="fragment">npm install yargs
</pre><p>or clone this project on github: </p><pre class="fragment">git clone http://github.com/yargs/yargs.git
</pre><p>To run the tests with npm, just do: </p><pre class="fragment">npm test
</pre><h1>configuration </h1>
<p>Using the <code>yargs</code> stanza in your <code>package.json</code> you can turn on and off some of yargs' parsing features:</p>
<div class="fragment"><div class="line">{</div><div class="line">  &quot;yargs&quot;: {</div><div class="line">    &quot;short-option-groups&quot;: true,</div><div class="line">    &quot;camel-case-expansion&quot;: true,</div><div class="line">    &quot;dot-notation&quot;: true,</div><div class="line">    &quot;parse-numbers&quot;: true,</div><div class="line">    &quot;boolean-negation&quot;: true</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>See the <a href="https://github.com/yargs/yargs-parser#configuration">yargs-parser</a> module for detailed documentation of this feature.</p>
<h1>inspired by </h1>
<p>This module is loosely inspired by Perl's <a href="http://search.cpan.org/~photo/Getopt-Casual-0.13.1/Casual.pm">Getopt::Casual</a>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者 &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
