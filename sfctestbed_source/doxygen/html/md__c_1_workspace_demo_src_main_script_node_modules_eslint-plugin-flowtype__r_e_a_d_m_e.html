<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>demo: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">demo
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">Vfunc Spring Boot项目概要</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">README </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="eslint-plugin-flowtype"></a> </p><h1>eslint-plugin-flowtype</h1>
<p><a href="https://www.npmjs.org/package/eslint-plugin-flowtype"></a> <a href="https://travis-ci.org/gajus/eslint-plugin-flowtype"></a> <a href="https://github.com/gajus/canonical"></a></p>
<p><a href="http://flowtype.org/">Flow type</a> linting rules for ESLint.</p>
<ul>
<li><a href="#eslint-plugin-flowtype">eslint-plugin-flowtype</a><ul>
<li><a href="#eslint-plugin-flowtype-installation">Installation</a></li>
<li><a href="#eslint-plugin-flowtype-configuration">Configuration</a><ul>
<li><a href="#eslint-plugin-flowtype-configuration-shareable-configurations">Shareable configurations</a></li>
</ul>
</li>
<li><a href="#eslint-plugin-flowtype-settings">Settings</a><ul>
<li><a href="#eslint-plugin-flowtype-settings-onlyfileswithflowannotation"><code>onlyFilesWithFlowAnnotation</code></a></li>
</ul>
</li>
<li><a href="#eslint-plugin-flowtype-rules">Rules</a><ul>
<li><a href="#eslint-plugin-flowtype-rules-boolean-style"><code>boolean-style</code></a></li>
<li><a href="#eslint-plugin-flowtype-rules-define-flow-type"><code>define-flow-type</code></a></li>
<li><a href="#eslint-plugin-flowtype-rules-delimiter-dangle"><code>delimiter-dangle</code></a></li>
<li><a href="#eslint-plugin-flowtype-rules-generic-spacing"><code>generic-spacing</code></a></li>
<li><a href="#eslint-plugin-flowtype-rules-no-dupe-keys"><code>no-dupe-keys</code></a></li>
<li><a href="#eslint-plugin-flowtype-rules-no-primitive-constructor-types"><code>no-primitive-constructor-types</code></a></li>
<li><a href="#eslint-plugin-flowtype-rules-no-types-missing-file-annotation"><code>no-types-missing-file-annotation</code></a></li>
<li><a href="#eslint-plugin-flowtype-rules-no-weak-types"><code>no-weak-types</code></a></li>
<li><a href="#eslint-plugin-flowtype-rules-object-type-delimiter"><code>object-type-delimiter</code></a></li>
<li><a href="#eslint-plugin-flowtype-rules-require-parameter-type"><code>require-parameter-type</code></a></li>
<li><a href="#eslint-plugin-flowtype-rules-require-return-type"><code>require-return-type</code></a></li>
<li><a href="#eslint-plugin-flowtype-rules-require-valid-file-annotation"><code>require-valid-file-annotation</code></a></li>
<li><a href="#eslint-plugin-flowtype-rules-require-variable-type"><code>require-variable-type</code></a></li>
<li><a href="#eslint-plugin-flowtype-rules-semi"><code>semi</code></a></li>
<li><a href="#eslint-plugin-flowtype-rules-sort-keys"><code>sort-keys</code></a></li>
<li><a href="#eslint-plugin-flowtype-rules-space-after-type-colon"><code>space-after-type-colon</code></a></li>
<li><a href="#eslint-plugin-flowtype-rules-space-before-generic-bracket"><code>space-before-generic-bracket</code></a></li>
<li><a href="#eslint-plugin-flowtype-rules-space-before-type-colon"><code>space-before-type-colon</code></a></li>
<li><a href="#eslint-plugin-flowtype-rules-type-id-match"><code>type-id-match</code></a></li>
<li><a href="#eslint-plugin-flowtype-rules-union-intersection-spacing"><code>union-intersection-spacing</code></a></li>
<li><a href="#eslint-plugin-flowtype-rules-use-flow-type"><code>use-flow-type</code></a></li>
<li><a href="#eslint-plugin-flowtype-rules-valid-syntax"><code>valid-syntax</code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a class="anchor" id="eslint-plugin-flowtype-installation"></a> </p><h2>Installation</h2>
<ol type="1">
<li>Install <a href="https://www.github.com/eslint/eslint">ESLint</a>.</li>
</ol>
<ol type="1">
<li>Install <a href="https://github.com/babel/babel-eslint"><code>babel-eslint</code></a> parser (ESLint parser <a href="https://github.com/eslint/eslint/issues/2157">does not support type annotations</a>).</li>
</ol>
<ol type="1">
<li>Install <a href="https://github.com/gajus/eslint-plugin-flowtype"><code>eslint-plugin-flowtype</code></a> plugin.</li>
</ol>
<div class="fragment"><div class="line">npm install eslint --save-dev</div><div class="line">npm install babel-eslint --save-dev</div><div class="line">npm install eslint-plugin-flowtype --save-dev</div></div><!-- fragment --><p><a class="anchor" id="eslint-plugin-flowtype-configuration"></a> </p><h2>Configuration</h2>
<ol type="1">
<li>Set <code>parser</code> property to <code>babel-eslint</code>.</li>
</ol>
<ol type="1">
<li>Add <code>plugins</code> section and specify <code>eslint-plugin-flowtype</code> as a plugin.</li>
</ol>
<ol type="1">
<li>Enable rules.</li>
</ol>
<div class="fragment"><div class="line">{</div><div class="line">  &quot;parser&quot;: &quot;babel-eslint&quot;,</div><div class="line">  &quot;plugins&quot;: [</div><div class="line">    &quot;flowtype&quot;</div><div class="line">  ],</div><div class="line">  &quot;rules&quot;: {</div><div class="line">    &quot;flowtype/boolean-style&quot;: [</div><div class="line">      2,</div><div class="line">      &quot;boolean&quot;</div><div class="line">    ],</div><div class="line">    &quot;flowtype/define-flow-type&quot;: 1,</div><div class="line">    &quot;flowtype/delimiter-dangle&quot;: [</div><div class="line">      2,</div><div class="line">      &quot;never&quot;</div><div class="line">    ],</div><div class="line">    &quot;flowtype/generic-spacing&quot;: [</div><div class="line">      2,</div><div class="line">      &quot;never&quot;</div><div class="line">    ],</div><div class="line">    &quot;flowtype/no-primitive-constructor-types&quot;: 2,</div><div class="line">    &quot;flowtype/no-types-missing-file-annotation&quot;: 2,</div><div class="line">    &quot;flowtype/no-weak-types&quot;: 2,</div><div class="line">    &quot;flowtype/object-type-delimiter&quot;: [</div><div class="line">      2,</div><div class="line">      &quot;comma&quot;</div><div class="line">    ],</div><div class="line">    &quot;flowtype/require-parameter-type&quot;: 2,</div><div class="line">    &quot;flowtype/require-return-type&quot;: [</div><div class="line">      2,</div><div class="line">      &quot;always&quot;,</div><div class="line">      {</div><div class="line">        &quot;annotateUndefined&quot;: &quot;never&quot;</div><div class="line">      }</div><div class="line">    ],</div><div class="line">    &quot;flowtype/require-valid-file-annotation&quot;: 2,</div><div class="line">    &quot;flowtype/semi&quot;: [</div><div class="line">      2,</div><div class="line">      &quot;always&quot;</div><div class="line">    ],</div><div class="line">    &quot;flowtype/space-after-type-colon&quot;: [</div><div class="line">      2,</div><div class="line">      &quot;always&quot;</div><div class="line">    ],</div><div class="line">    &quot;flowtype/space-before-generic-bracket&quot;: [</div><div class="line">      2,</div><div class="line">      &quot;never&quot;</div><div class="line">    ],</div><div class="line">    &quot;flowtype/space-before-type-colon&quot;: [</div><div class="line">      2,</div><div class="line">      &quot;never&quot;</div><div class="line">    ],</div><div class="line">    &quot;flowtype/type-id-match&quot;: [</div><div class="line">      2,</div><div class="line">      &quot;^([A-Z][a-z0-9]+)+Type$&quot;</div><div class="line">    ],</div><div class="line">    &quot;flowtype/union-intersection-spacing&quot;: [</div><div class="line">      2,</div><div class="line">      &quot;always&quot;</div><div class="line">    ],</div><div class="line">    &quot;flowtype/use-flow-type&quot;: 1,</div><div class="line">    &quot;flowtype/valid-syntax&quot;: 1</div><div class="line">  },</div><div class="line">  &quot;settings&quot;: {</div><div class="line">    &quot;flowtype&quot;: {</div><div class="line">      &quot;onlyFilesWithFlowAnnotation&quot;: false</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="eslint-plugin-flowtype-configuration-shareable-configurations"></a> </p><h3>Shareable configurations</h3>
<p><a class="anchor" id="eslint-plugin-flowtype-configuration-shareable-configurations-recommended"></a> </p><h4>Recommended</h4>
<p>This plugin exports a <a href="./src/configs/recommended.json">recommended configuration</a> that enforces Flow type good practices.</p>
<p>To enable this configuration use the extends property in your <code>.eslintrc</code> config file:</p>
<div class="fragment"><div class="line">{</div><div class="line">  &quot;extends&quot;: [</div><div class="line">    &quot;plugin:flowtype/recommended&quot;</div><div class="line">  ],</div><div class="line">  &quot;plugins&quot;: [</div><div class="line">    &quot;flowtype&quot;</div><div class="line">  ]</div><div class="line">}</div></div><!-- fragment --><p>See <a href="http://eslint.org/docs/user-guide/configuring#extending-configuration-files">ESLint documentation</a> for more information about extending configuration files.</p>
<p><a class="anchor" id="eslint-plugin-flowtype-settings"></a> </p><h2>Settings</h2>
<p><a class="anchor" id="eslint-plugin-flowtype-settings-onlyfileswithflowannotation"></a> </p><h3><code>onlyFilesWithFlowAnnotation</code></h3>
<p>When <code>true</code>, only checks files with a <a href="http://flowtype.org/docs/about-flow.html#gradual"><code>@flow</code> annotation</a> in the first comment.</p>
<div class="fragment"><div class="line">{</div><div class="line">  &quot;settings&quot;: {</div><div class="line">    &quot;flowtype&quot;: {</div><div class="line">      &quot;onlyFilesWithFlowAnnotation&quot;: true</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="eslint-plugin-flowtype-rules"></a> </p><h2>Rules</h2>
<p><a class="anchor" id="eslint-plugin-flowtype-rules-boolean-style"></a> </p><h3><code>boolean-style</code></h3>
<p><em>The <code>--fix</code> option on the command line automatically fixes problems reported by this rule.</em></p>
<p>Enforces a particular style for boolean type annotations. This rule takes one argument.</p>
<p>If it is &lsquo;'boolean&rsquo;<code>then a problem is raised when using</code>bool<code>instead of</code>boolean`.</p>
<p>If it is &lsquo;'bool&rsquo;<code>then a problem is raised when using</code>boolean<code>instead of</code>bool`.</p>
<p>The default value is &lsquo;'boolean&rsquo;`.</p>
<p>The following patterns are considered problems:</p>
<div class="fragment"><div class="line">type X = bool</div><div class="line">// Message: Use &quot;boolean&quot;, not &quot;bool&quot;</div><div class="line"></div><div class="line">// Options: [&quot;boolean&quot;]</div><div class="line">type X = bool</div><div class="line">// Message: Use &quot;boolean&quot;, not &quot;bool&quot;</div><div class="line"></div><div class="line">// Options: [&quot;bool&quot;]</div><div class="line">type X = boolean</div><div class="line">// Message: Use &quot;bool&quot;, not &quot;boolean&quot;</div></div><!-- fragment --><p>The following patterns are not considered problems:</p>
<div class="fragment"><div class="line">type X = boolean</div><div class="line"></div><div class="line">// Options: [&quot;boolean&quot;]</div><div class="line">type X = boolean</div><div class="line"></div><div class="line">// Options: [&quot;bool&quot;]</div><div class="line">type X = bool</div><div class="line"></div><div class="line">// Options: [&quot;boolean&quot;]</div><div class="line">type X = bool</div></div><!-- fragment --><p><a class="anchor" id="eslint-plugin-flowtype-rules-define-flow-type"></a> </p><h3><code>define-flow-type</code></h3>
<p>Marks Flow type identifiers as defined.</p>
<p>Used to suppress <a href="http://eslint.org/docs/rules/no-undef"><code>no-undef</code></a> reporting of type identifiers.</p>
<p>The following patterns are not considered problems:</p>
<div class="fragment"><div class="line">var a: AType</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2}</div><div class="line"></div><div class="line">var a: AType; var b: AType</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2}</div><div class="line"></div><div class="line">var a; (a: AType)</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2}</div><div class="line"></div><div class="line">var a: AType&lt;BType&gt;</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2}</div><div class="line"></div><div class="line">type A = AType</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2}</div><div class="line"></div><div class="line">function f(a: AType) {}</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2}</div><div class="line"></div><div class="line">function f(a: AType.a) {}</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2}</div><div class="line"></div><div class="line">function f(a: AType.a.b) {}</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2}</div><div class="line"></div><div class="line">function f(a): AType {}; var a: AType</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2}</div><div class="line"></div><div class="line">function f(a): AType {}</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2}</div><div class="line"></div><div class="line">class C { a: AType }</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2}</div><div class="line"></div><div class="line">class C { a: AType.a }</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2}</div><div class="line"></div><div class="line">class C { a: AType.a.b }</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2}</div><div class="line"></div><div class="line">class C implements AType {}</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2}</div><div class="line"></div><div class="line">interface AType {}</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2}</div><div class="line"></div><div class="line">({ a: ({b() {}}: AType) })</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2}</div><div class="line"></div><div class="line">type X = {Y&lt;AType&gt;(): BType}</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2}</div><div class="line"></div><div class="line">interface AType&lt;BType&gt; {}</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2}</div><div class="line"></div><div class="line">var a: AType</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2,&quot;no-use-before-define&quot;:[2,&quot;nofunc&quot;]}</div><div class="line"></div><div class="line">var a: AType; var b: AType</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2,&quot;no-use-before-define&quot;:[2,&quot;nofunc&quot;]}</div><div class="line"></div><div class="line">var a; (a: AType)</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2,&quot;no-use-before-define&quot;:[2,&quot;nofunc&quot;]}</div><div class="line"></div><div class="line">var a: AType&lt;BType&gt;</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2,&quot;no-use-before-define&quot;:[2,&quot;nofunc&quot;]}</div><div class="line"></div><div class="line">type A = AType</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2,&quot;no-use-before-define&quot;:[2,&quot;nofunc&quot;]}</div><div class="line"></div><div class="line">function f(a: AType) {}</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2,&quot;no-use-before-define&quot;:[2,&quot;nofunc&quot;]}</div><div class="line"></div><div class="line">function f(a: AType.a) {}</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2,&quot;no-use-before-define&quot;:[2,&quot;nofunc&quot;]}</div><div class="line"></div><div class="line">function f(a: AType.a.b) {}</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2,&quot;no-use-before-define&quot;:[2,&quot;nofunc&quot;]}</div><div class="line"></div><div class="line">function f(a): AType {}; var a: AType</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2,&quot;no-use-before-define&quot;:[2,&quot;nofunc&quot;]}</div><div class="line"></div><div class="line">function f(a): AType {}</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2,&quot;no-use-before-define&quot;:[2,&quot;nofunc&quot;]}</div><div class="line"></div><div class="line">class C { a: AType }</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2,&quot;no-use-before-define&quot;:[2,&quot;nofunc&quot;]}</div><div class="line"></div><div class="line">class C { a: AType.a }</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2,&quot;no-use-before-define&quot;:[2,&quot;nofunc&quot;]}</div><div class="line"></div><div class="line">class C { a: AType.a.b }</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2,&quot;no-use-before-define&quot;:[2,&quot;nofunc&quot;]}</div><div class="line"></div><div class="line">class C implements AType {}</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2,&quot;no-use-before-define&quot;:[2,&quot;nofunc&quot;]}</div><div class="line"></div><div class="line">interface AType {}</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2,&quot;no-use-before-define&quot;:[2,&quot;nofunc&quot;]}</div><div class="line"></div><div class="line">({ a: ({b() {}}: AType) })</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2,&quot;no-use-before-define&quot;:[2,&quot;nofunc&quot;]}</div><div class="line"></div><div class="line">type X = {Y&lt;AType&gt;(): BType}</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2,&quot;no-use-before-define&quot;:[2,&quot;nofunc&quot;]}</div><div class="line"></div><div class="line">interface AType&lt;BType&gt; {}</div><div class="line">// Additional rules: {&quot;no-undef&quot;:2,&quot;no-use-before-define&quot;:[2,&quot;nofunc&quot;]}</div></div><!-- fragment --><p><a class="anchor" id="eslint-plugin-flowtype-rules-delimiter-dangle"></a> </p><h3><code>delimiter-dangle</code></h3>
<p><em>The <code>--fix</code> option on the command line automatically fixes problems reported by this rule.</em></p>
<p>Enforces consistent use of trailing commas in Object and Tuple annotations.</p>
<p>This rule takes one argument which mirrors ESLint's default <code>comma-dangle</code> rule.</p>
<p>If it is &lsquo;'never&rsquo;` then a problem is raised when there is a trailing comma.</p>
<p>If it is &lsquo;'always&rsquo;` then a problem is raised when there is no trailing comma.</p>
<p>If it is &lsquo;'always-multiline&rsquo;` then a problem is raised when there is no trailing comma on a multi-line definition, or there <em>is</em> a trailing comma on a single-line definition.</p>
<p>If it is &lsquo;'only-multiline&rsquo;` then a problem is raised when there is a trailing comma on a single-line definition. It allows, but does not enforce, trailing commas on multi-line definitions.</p>
<p>The default value is &lsquo;'never&rsquo;`.</p>
<p>The following patterns are considered problems:</p>
<div class="fragment"><div class="line">type X = { foo: string, }</div><div class="line">// Message: Unexpected trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { foo: string, }</div><div class="line">// Message: Unexpected trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { foo: string; }</div><div class="line">// Message: Unexpected trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = {</div><div class="line">foo: string,</div><div class="line">}</div><div class="line">// Message: Unexpected trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { foo: string }</div><div class="line">// Message: Missing trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = {</div><div class="line">foo: string</div><div class="line">}</div><div class="line">// Message: Missing trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;always-multiline&quot;]</div><div class="line">type X = { foo: string, }</div><div class="line">// Message: Unexpected trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;always-multiline&quot;]</div><div class="line">type X = {</div><div class="line">foo: string</div><div class="line">}</div><div class="line">// Message: Missing trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;only-multiline&quot;]</div><div class="line">type X = { foo: string; }</div><div class="line">// Message: Unexpected trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { [key: string]: number, }</div><div class="line">// Message: Unexpected trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { [key: string]: number }</div><div class="line">// Message: Missing trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;always-multiline&quot;]</div><div class="line">type X = { [key: string]: number, }</div><div class="line">// Message: Unexpected trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;always-multiline&quot;]</div><div class="line">type X = {</div><div class="line">[key: string]: number</div><div class="line">}</div><div class="line">// Message: Missing trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;only-multiline&quot;]</div><div class="line">type X = { [key: string]: number; }</div><div class="line">// Message: Unexpected trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { [key: string]: number, foo: string, }</div><div class="line">// Message: Unexpected trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = {</div><div class="line">[key: string]: number,</div><div class="line">foo: string,</div><div class="line">}</div><div class="line">// Message: Unexpected trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = {</div><div class="line">[key: string]: number,</div><div class="line">aReallyLongPropertyNameHere: string,</div><div class="line">}</div><div class="line">// Message: Unexpected trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { [key: string]: number, foo: string }</div><div class="line">// Message: Missing trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = {</div><div class="line">[key: string]: number;</div><div class="line">foo: string</div><div class="line">}</div><div class="line">// Message: Missing trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;always-multiline&quot;]</div><div class="line">type X = { [key: string]: number, foo: string, }</div><div class="line">// Message: Unexpected trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;always-multiline&quot;]</div><div class="line">type X = {</div><div class="line">[key: string]: number,</div><div class="line">foo: string</div><div class="line">}</div><div class="line">// Message: Missing trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;only-multiline&quot;]</div><div class="line">type X = { [key: string]: number, foo: string, }</div><div class="line">// Message: Unexpected trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { foo: string, [key: string]: number, }</div><div class="line">// Message: Unexpected trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = {</div><div class="line">foo: string,</div><div class="line">[key: string]: number,</div><div class="line">}</div><div class="line">// Message: Unexpected trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = {</div><div class="line">aReallyLongPropertyNameHere: string,</div><div class="line">[key: string]: number,</div><div class="line">}</div><div class="line">// Message: Unexpected trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { foo: string, [key: string]: number }</div><div class="line">// Message: Missing trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { foo: string; [key: string]: number }</div><div class="line">// Message: Missing trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;always-multiline&quot;]</div><div class="line">type X = { foo: string, [key: string]: number; }</div><div class="line">// Message: Unexpected trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;always-multiline&quot;]</div><div class="line">type X = {</div><div class="line">foo: string,</div><div class="line">[key: string]: number</div><div class="line">}</div><div class="line">// Message: Missing trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;only-multiline&quot;]</div><div class="line">type X = { foo: string, [key: string]: number; }</div><div class="line">// Message: Unexpected trailing delimiter</div><div class="line"></div><div class="line">type X = [string, number,]</div><div class="line">// Message: Unexpected trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = [string, number,]</div><div class="line">// Message: Unexpected trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = [</div><div class="line">string,</div><div class="line">number,</div><div class="line">]</div><div class="line">// Message: Unexpected trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = [string, number]</div><div class="line">// Message: Missing trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = [</div><div class="line">string,</div><div class="line">number</div><div class="line">]</div><div class="line">// Message: Missing trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;always-multiline&quot;]</div><div class="line">type X = [string, number,]</div><div class="line">// Message: Unexpected trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;always-multiline&quot;]</div><div class="line">type X = [</div><div class="line">foo, string</div><div class="line">]</div><div class="line">// Message: Missing trailing delimiter</div><div class="line"></div><div class="line">// Options: [&quot;only-multiline&quot;]</div><div class="line">type X = [ number, string, ]</div><div class="line">// Message: Unexpected trailing delimiter</div></div><!-- fragment --><p>The following patterns are not considered problems:</p>
<div class="fragment"><div class="line">type X = { foo: string }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { foo: string }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { foo: string, }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { foo: string; }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = {</div><div class="line">foo: string</div><div class="line">}</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = {</div><div class="line">foo: string,</div><div class="line">}</div><div class="line"></div><div class="line">// Options: [&quot;always-multiline&quot;]</div><div class="line">type X = { foo: string }</div><div class="line"></div><div class="line">// Options: [&quot;always-multiline&quot;]</div><div class="line">type X = {</div><div class="line">foo: string,</div><div class="line">}</div><div class="line"></div><div class="line">// Options: [&quot;always-multiline&quot;]</div><div class="line">type X = {</div><div class="line">foo: string;</div><div class="line">}</div><div class="line"></div><div class="line">// Options: [&quot;only-multiline&quot;]</div><div class="line">type X = { foo: string }</div><div class="line"></div><div class="line">// Options: [&quot;only-multiline&quot;]</div><div class="line">type X = {</div><div class="line">foo: string</div><div class="line">}</div><div class="line"></div><div class="line">// Options: [&quot;only-multiline&quot;]</div><div class="line">type X = {</div><div class="line">foo: string,</div><div class="line">}</div><div class="line"></div><div class="line">// Options: [&quot;only-multiline&quot;]</div><div class="line">type X = {</div><div class="line">foo: string;</div><div class="line">}</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = {}</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = {}</div><div class="line"></div><div class="line">// Options: [&quot;always-multiline&quot;]</div><div class="line">type X = {}</div><div class="line"></div><div class="line">// Options: [&quot;only-multiline&quot;]</div><div class="line">type X = {}</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { [key: string]: number }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { [key: string]: number, }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { [key: string]: number; }</div><div class="line"></div><div class="line">// Options: [&quot;always-multiline&quot;]</div><div class="line">type X = { [key: string]: number }</div><div class="line"></div><div class="line">// Options: [&quot;always-multiline&quot;]</div><div class="line">type X = {</div><div class="line">[key: string]: number,</div><div class="line">}</div><div class="line"></div><div class="line">// Options: [&quot;only-multiline&quot;]</div><div class="line">type X = {</div><div class="line">[key: string]: number,</div><div class="line">}</div><div class="line"></div><div class="line">// Options: [&quot;only-multiline&quot;]</div><div class="line">type X = {</div><div class="line">[key: string]: number</div><div class="line">}</div><div class="line"></div><div class="line">// Options: [&quot;only-multiline&quot;]</div><div class="line">type X = { [key: string]: number }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { [key: string]: number, foo: string }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { [key: string]: number, foo: string, }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { [key: string]: number; foo: string; }</div><div class="line"></div><div class="line">// Options: [&quot;always-multiline&quot;]</div><div class="line">type X = { [key: string]: number, foo: string }</div><div class="line"></div><div class="line">// Options: [&quot;always-multiline&quot;]</div><div class="line">type X = {</div><div class="line">[key: string]: number,</div><div class="line">foo: string,</div><div class="line">}</div><div class="line"></div><div class="line">// Options: [&quot;only-multiline&quot;]</div><div class="line">type X = {</div><div class="line">[key: string]: number,</div><div class="line">foo: string,</div><div class="line">}</div><div class="line"></div><div class="line">// Options: [&quot;only-multiline&quot;]</div><div class="line">type X = {</div><div class="line">[key: string]: number;</div><div class="line">foo: string</div><div class="line">}</div><div class="line"></div><div class="line">// Options: [&quot;only-multiline&quot;]</div><div class="line">type X = { [key: string]: number, foo: string }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { foo: string, [key: string]: number }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { foo: string, [key: string]: number, }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { foo: string; [key: string]: number; }</div><div class="line"></div><div class="line">// Options: [&quot;always-multiline&quot;]</div><div class="line">type X = { foo: string, [key: string]: number }</div><div class="line"></div><div class="line">// Options: [&quot;always-multiline&quot;]</div><div class="line">type X = {</div><div class="line">foo: string,</div><div class="line">[key: string]: number,</div><div class="line">}</div><div class="line"></div><div class="line">// Options: [&quot;only-multiline&quot;]</div><div class="line">type X = {</div><div class="line">foo: string,</div><div class="line">[key: string]: number,</div><div class="line">}</div><div class="line"></div><div class="line">// Options: [&quot;only-multiline&quot;]</div><div class="line">type X = {</div><div class="line">foo: string;</div><div class="line">[key: string]: number</div><div class="line">}</div><div class="line"></div><div class="line">// Options: [&quot;only-multiline&quot;]</div><div class="line">type X = { foo: string, [key: string]: number }</div><div class="line"></div><div class="line">type X = [string, number]</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = [string, number]</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = [</div><div class="line">string,</div><div class="line">number</div><div class="line">]</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = [string, number,]</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = [</div><div class="line">string,</div><div class="line">number,</div><div class="line">]</div><div class="line"></div><div class="line">// Options: [&quot;always-multiline&quot;]</div><div class="line">type X = [ foo, string ]</div><div class="line"></div><div class="line">// Options: [&quot;always-multiline&quot;]</div><div class="line">type X = [</div><div class="line">foo, string,</div><div class="line">]</div><div class="line"></div><div class="line">// Options: [&quot;only-multiline&quot;]</div><div class="line">type X = [ number, string ]</div><div class="line"></div><div class="line">// Options: [&quot;only-multiline&quot;]</div><div class="line">type X = [</div><div class="line">number,</div><div class="line">string</div><div class="line">]</div><div class="line"></div><div class="line">// Options: [&quot;only-multiline&quot;]</div><div class="line">type X = [</div><div class="line">number,</div><div class="line">string,</div><div class="line">]</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = []</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = []</div><div class="line"></div><div class="line">// Options: [&quot;always-multiline&quot;]</div><div class="line">type X = []</div><div class="line"></div><div class="line">// Options: [&quot;only-multiline&quot;]</div><div class="line">type X = []</div></div><!-- fragment --><p><a class="anchor" id="eslint-plugin-flowtype-rules-generic-spacing"></a> </p><h3><code>generic-spacing</code></h3>
<p><em>The <code>--fix</code> option on the command line automatically fixes problems reported by this rule.</em></p>
<p>Enforces consistent spacing within generic type annotation parameters.</p>
<p>This rule takes one argument. If it is &lsquo;'never&rsquo;<code>then a problem is raised when there is a space surrounding the generic type parameters. If it is</code>'always'` then a problem is raised when there is no space surrounding the generic type parameters.</p>
<p>The default value is &lsquo;'never&rsquo;`.</p>
<p>The following patterns are considered problems:</p>
<div class="fragment"><div class="line">type X = Promise&lt; string&gt;</div><div class="line">// Message: There must be no space at start of &quot;Promise&quot; generic type annotation</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = Promise&lt;  string&gt;</div><div class="line">// Message: There must be no space at start of &quot;Promise&quot; generic type annotation</div><div class="line"></div><div class="line">type X = FooBar&lt;string &gt;</div><div class="line">// Message: There must be no space at end of &quot;FooBar&quot; generic type annotation</div><div class="line"></div><div class="line">type X = Promise&lt; string &gt;</div><div class="line">// Message: There must be no space at start of &quot;Promise&quot; generic type annotation</div><div class="line">// Message: There must be no space at end of &quot;Promise&quot; generic type annotation</div><div class="line"></div><div class="line">type X = Promise&lt; (foo), bar, (((baz))) &gt;</div><div class="line">// Message: There must be no space at start of &quot;Promise&quot; generic type annotation</div><div class="line">// Message: There must be no space at end of &quot;Promise&quot; generic type annotation</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = Promise&lt;string &gt;</div><div class="line">// Message: There must be a space at start of &quot;Promise&quot; generic type annotation</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = FooBar&lt; string&gt;</div><div class="line">// Message: There must be a space at end of &quot;FooBar&quot; generic type annotation</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = Promise&lt;string&gt;</div><div class="line">// Message: There must be a space at start of &quot;Promise&quot; generic type annotation</div><div class="line">// Message: There must be a space at end of &quot;Promise&quot; generic type annotation</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = Promise&lt;(foo), bar, (((baz)))&gt;</div><div class="line">// Message: There must be a space at start of &quot;Promise&quot; generic type annotation</div><div class="line">// Message: There must be a space at end of &quot;Promise&quot; generic type annotation</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = FooBar&lt;  string &gt;</div><div class="line">// Message: There must be one space at start of &quot;FooBar&quot; generic type annotation</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = FooBar&lt; string  &gt;</div><div class="line">// Message: There must be one space at end of &quot;FooBar&quot; generic type annotation</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = Promise&lt;  (foo), bar, (((baz)))  &gt;</div><div class="line">// Message: There must be one space at start of &quot;Promise&quot; generic type annotation</div><div class="line">// Message: There must be one space at end of &quot;Promise&quot; generic type annotation</div></div><!-- fragment --><p>The following patterns are not considered problems:</p>
<div class="fragment"><div class="line">type X = Promise&lt;string&gt;</div><div class="line"></div><div class="line">type X = Promise&lt;(string)&gt;</div><div class="line"></div><div class="line">type X = Promise&lt;(foo), bar, (((baz)))&gt;</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = Promise&lt; string &gt;</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = Promise&lt; (string) &gt;</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = Promise&lt; (foo), bar, (((baz))) &gt;</div></div><!-- fragment --><p><a class="anchor" id="eslint-plugin-flowtype-rules-no-dupe-keys"></a> </p><h3><code>no-dupe-keys</code></h3>
<p>Checks for duplicate properties in Object annotations.</p>
<p>This rule mirrors ESLint's <a href="http://eslint.org/docs/rules/no-dupe-keys">no-dupe-keys</a> rule.</p>
<div class="fragment"><div class="line">{</div><div class="line">    &quot;rules&quot;: {</div><div class="line">        &quot;flowtype/no-dupe-keys&quot;: 2</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The following patterns are considered problems:</p>
<div class="fragment"><div class="line">type f = { a: number, b: string, a: number }</div><div class="line">// Message: Duplicate property.</div><div class="line"></div><div class="line">type f = { a: number, b: string, a: string }</div><div class="line">// Message: Duplicate property.</div><div class="line"></div><div class="line">type f = { get(key: &quot;a&quot;): string, get(key: &quot;a&quot;): string }</div><div class="line">// Message: Duplicate property.</div><div class="line"></div><div class="line">type f = { get(key: 1): string, get(key: 1): string }</div><div class="line">// Message: Duplicate property.</div><div class="line"></div><div class="line">type f = { get(key: 1.1): string, get(key: 1.1): string }</div><div class="line">// Message: Duplicate property.</div><div class="line"></div><div class="line">type f = { get(key: true): string, get(key: true): string }</div><div class="line">// Message: Duplicate property.</div><div class="line"></div><div class="line">type f = { get(key: {a: 1}): string, get(key: {a: 1}):string }</div><div class="line">// Message: Duplicate property.</div><div class="line"></div><div class="line">var a = &quot;a&quot;; type f = { get(key: a): string, get(key: a): string }</div><div class="line">// Message: Duplicate property.</div><div class="line"></div><div class="line">var b = 1; type f = { get(key: b): string, get(key: b): string }</div><div class="line">// Message: Duplicate property.</div><div class="line"></div><div class="line">var c = true; type f = { get(key: c): string, get(key: c): string }</div><div class="line">// Message: Duplicate property.</div><div class="line"></div><div class="line">var d = {}; type f = { get(key: d): string, get(key: d): string }</div><div class="line">// Message: Duplicate property.</div><div class="line"></div><div class="line">var e = []; type f = { get(key: e): string, get(key: e): string }</div><div class="line">// Message: Duplicate property.</div><div class="line"></div><div class="line">var e = [1, &quot;a&quot;]; type f = { get(key: e): string, get(key: e): string }</div><div class="line">// Message: Duplicate property.</div><div class="line"></div><div class="line">function fn() {}; type f = { get(key: fn): string, get(key: fn): string }</div><div class="line">// Message: Duplicate property.</div></div><!-- fragment --><p>The following patterns are not considered problems:</p>
<div class="fragment"><div class="line">type FooType = { a: number, b: string, c: number }</div><div class="line"></div><div class="line">type FooType = { a: number, b: string, a: number }</div><div class="line"></div><div class="line">type f = { get(key: &quot;a&quot;): string, get(key: &quot;b&quot;): string }</div><div class="line"></div><div class="line">type f = { get(key: 1): string, get(key: 2): string }</div><div class="line"></div><div class="line">type f = { get(key: 1.1): string, get(key: 1.2): string }</div><div class="line"></div><div class="line">type f = { get(key: true): string, get(key: false): string }</div><div class="line"></div><div class="line">type f = { get(key: [&quot;a&quot;, 1]): string, get(key: [&quot;a&quot;, 2]): string }</div><div class="line"></div><div class="line">type f = { get(key: [&quot;a&quot;, [&quot;b&quot;, 1]]): string, get(key: [&quot;a&quot;, [&quot;b&quot;, 2]]): string }</div><div class="line"></div><div class="line">type f = { a: number, b: string, c: number }</div><div class="line"></div><div class="line">type f = { get(key: &quot;a&quot;): string, get(key: &quot;b&quot;): string }</div><div class="line"></div><div class="line">type f = { get(key: &quot;a&quot;): string, get(key: &quot;a&quot;, key2: &quot;b&quot;): string }</div><div class="line"></div><div class="line">type f = { get(key: &quot;a&quot;): string, get(key: 1): string }</div><div class="line"></div><div class="line">type f = { get(key: { a: 1 }): string, get(key: { a: 2 }): string}</div><div class="line"></div><div class="line">var a = {}; var b = {}; type f = { get(key: a): string, get(key: b): string }</div><div class="line"></div><div class="line">var a = 1; var b = 1; type f = { get(key: a): string, get(key: b): string }</div></div><!-- fragment --><p><a class="anchor" id="eslint-plugin-flowtype-rules-no-primitive-constructor-types"></a> </p><h3><code>no-primitive-constructor-types</code></h3>
<p>Disallows use of primitive constructors as types, such as <code>Boolean</code>, <code>Number</code> and <code>String</code>. <a href="https://flowtype.org/docs/builtins.html">See more</a>.</p>
<div class="fragment"><div class="line">{</div><div class="line">    &quot;rules&quot;: {</div><div class="line">        &quot;flowtype/no-primitive-constructor-types&quot;: 2</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The following patterns are considered problems:</p>
<div class="fragment"><div class="line">type x = Number</div><div class="line">// Message: Unexpected use of Number constructor type.</div><div class="line"></div><div class="line">type x = String</div><div class="line">// Message: Unexpected use of String constructor type.</div><div class="line"></div><div class="line">type x = Boolean</div><div class="line">// Message: Unexpected use of Boolean constructor type.</div><div class="line"></div><div class="line">type x = { a: Number }</div><div class="line">// Message: Unexpected use of Number constructor type.</div><div class="line"></div><div class="line">type x = { a: String }</div><div class="line">// Message: Unexpected use of String constructor type.</div><div class="line"></div><div class="line">type x = { a: Boolean }</div><div class="line">// Message: Unexpected use of Boolean constructor type.</div><div class="line"></div><div class="line">(x: Number) =&gt; {}</div><div class="line">// Message: Unexpected use of Number constructor type.</div><div class="line"></div><div class="line">(x: String) =&gt; {}</div><div class="line">// Message: Unexpected use of String constructor type.</div><div class="line"></div><div class="line">(x: Boolean) =&gt; {}</div><div class="line">// Message: Unexpected use of Boolean constructor type.</div></div><!-- fragment --><p>The following patterns are not considered problems:</p>
<div class="fragment"><div class="line">type x = number</div><div class="line"></div><div class="line">type x = string</div><div class="line"></div><div class="line">type x = boolean</div><div class="line"></div><div class="line">type x = { a: number }</div><div class="line"></div><div class="line">type x = { a: string }</div><div class="line"></div><div class="line">type x = { a: boolean }</div><div class="line"></div><div class="line">(x: number) =&gt; {}</div><div class="line"></div><div class="line">(x: string) =&gt; {}</div><div class="line"></div><div class="line">(x: boolean) =&gt; {}</div><div class="line"></div><div class="line">type x = MyNumber</div><div class="line"></div><div class="line">type x = MyString</div><div class="line"></div><div class="line">type x = MyBoolean</div></div><!-- fragment --><p><a class="anchor" id="eslint-plugin-flowtype-rules-no-types-missing-file-annotation"></a> </p><h3><code>no-types-missing-file-annotation</code></h3>
<p>Disallows Flow type imports, exports, aliases, and annotations in files missing a valid Flow file declaration (or a  annotation).</p>
<div class="fragment"><div class="line">{</div><div class="line">    &quot;rules&quot;: {</div><div class="line">        &quot;flowtype/no-types-missing-file-annotation&quot;: 2</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The following patterns are considered problems:</p>
<div class="fragment"><div class="line">const x: number = 42;</div><div class="line">// Message: Type annotations require valid Flow declaration.</div><div class="line"></div><div class="line">type FooType = number;</div><div class="line">// Message: Type aliases require valid Flow declaration.</div><div class="line"></div><div class="line">import type A from &quot;a&quot;</div><div class="line">// Message: Type imports require valid Flow declaration.</div><div class="line"></div><div class="line">import type {A} from &quot;a&quot;</div><div class="line">// Message: Type imports require valid Flow declaration.</div><div class="line"></div><div class="line">import {type A} from &quot;a&quot;</div><div class="line">// Message: Type imports require valid Flow declaration.</div><div class="line"></div><div class="line">export type {A} from &quot;a&quot;</div><div class="line">// Message: Type exports require valid Flow declaration.</div><div class="line"></div><div class="line">function t&lt;T&gt;(): T{}</div><div class="line">// Message: Type annotations require valid Flow declaration.</div></div><!-- fragment --><p>The following patterns are not considered problems:</p>
<div class="fragment"><div class="line">// @flow</div><div class="line">const x: number = 42;</div><div class="line"></div><div class="line">/* @flow weak */</div><div class="line">type FooType = number;</div><div class="line"></div><div class="line">/* @noflow */</div><div class="line">type FooType = number;</div><div class="line"></div><div class="line">/* @noflow */</div><div class="line">import type A from &quot;a&quot;</div><div class="line"></div><div class="line">/* @noflow */</div><div class="line">import {type A} from &quot;a&quot;</div><div class="line"></div><div class="line">/* @noflow */</div><div class="line">export type {A} from &quot;a&quot;</div></div><!-- fragment --><p><a class="anchor" id="eslint-plugin-flowtype-rules-no-weak-types"></a> </p><h3><code>no-weak-types</code></h3>
<p>Warns against weak type annotations <em>any</em>, <em>Object</em> and <em>Function</em>. These types can cause flow to silently skip over portions of your code, which would have otherwise caused type errors.</p>
<p>This rule optionally takes one argument, an object to configure which type warnings to enable. By default, all of the warnings are enabled. e.g. to disable the <code>any</code> warning (allowing it to exist in your code), while continuing to warn about <code>Object</code> and <code>Function</code>:</p>
<div class="fragment"><div class="line">{</div><div class="line">    &quot;rules&quot;: {</div><div class="line">        &quot;flowtype/no-weak-types&quot;: [2, {</div><div class="line">            &quot;any&quot;: false,</div><div class="line">            &quot;Object&quot;: true,</div><div class="line">            &quot;Function&quot;: true</div><div class="line">        }]</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">// or, the following is equivalent as default is true:</div><div class="line"></div><div class="line">{</div><div class="line">    &quot;rules&quot;: {</div><div class="line">        &quot;flowtype/no-weak-types&quot;: [2, {</div><div class="line">            &quot;any&quot;: false</div><div class="line">        }]</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The following patterns are considered problems:</p>
<div class="fragment"><div class="line">function foo(thing): any {}</div><div class="line">// Message: Unexpected use of weak type &quot;any&quot;</div><div class="line"></div><div class="line">function foo(thing): Promise&lt;any&gt; {}</div><div class="line">// Message: Unexpected use of weak type &quot;any&quot;</div><div class="line"></div><div class="line">function foo(thing): Promise&lt;Promise&lt;any&gt;&gt; {}</div><div class="line">// Message: Unexpected use of weak type &quot;any&quot;</div><div class="line"></div><div class="line">function foo(thing): Object {}</div><div class="line">// Message: Unexpected use of weak type &quot;Object&quot;</div><div class="line"></div><div class="line">function foo(thing): Promise&lt;Object&gt; {}</div><div class="line">// Message: Unexpected use of weak type &quot;Object&quot;</div><div class="line"></div><div class="line">function foo(thing): Promise&lt;Promise&lt;Object&gt;&gt; {}</div><div class="line">// Message: Unexpected use of weak type &quot;Object&quot;</div><div class="line"></div><div class="line">function foo(thing): Function {}</div><div class="line">// Message: Unexpected use of weak type &quot;Function&quot;</div><div class="line"></div><div class="line">function foo(thing): Promise&lt;Function&gt; {}</div><div class="line">// Message: Unexpected use of weak type &quot;Function&quot;</div><div class="line"></div><div class="line">function foo(thing): Promise&lt;Promise&lt;Function&gt;&gt; {}</div><div class="line">// Message: Unexpected use of weak type &quot;Function&quot;</div><div class="line"></div><div class="line">(foo: any) =&gt; {}</div><div class="line">// Message: Unexpected use of weak type &quot;any&quot;</div><div class="line"></div><div class="line">(foo: Function) =&gt; {}</div><div class="line">// Message: Unexpected use of weak type &quot;Function&quot;</div><div class="line"></div><div class="line">(foo?: any) =&gt; {}</div><div class="line">// Message: Unexpected use of weak type &quot;any&quot;</div><div class="line"></div><div class="line">(foo?: Function) =&gt; {}</div><div class="line">// Message: Unexpected use of weak type &quot;Function&quot;</div><div class="line"></div><div class="line">(foo: { a: any }) =&gt; {}</div><div class="line">// Message: Unexpected use of weak type &quot;any&quot;</div><div class="line"></div><div class="line">(foo: { a: Object }) =&gt; {}</div><div class="line">// Message: Unexpected use of weak type &quot;Object&quot;</div><div class="line"></div><div class="line">(foo: any[]) =&gt; {}</div><div class="line">// Message: Unexpected use of weak type &quot;any&quot;</div><div class="line"></div><div class="line">type Foo = any</div><div class="line">// Message: Unexpected use of weak type &quot;any&quot;</div><div class="line"></div><div class="line">type Foo = Function</div><div class="line">// Message: Unexpected use of weak type &quot;Function&quot;</div><div class="line"></div><div class="line">type Foo = { a: any }</div><div class="line">// Message: Unexpected use of weak type &quot;any&quot;</div><div class="line"></div><div class="line">type Foo = { a: Object }</div><div class="line">// Message: Unexpected use of weak type &quot;Object&quot;</div><div class="line"></div><div class="line">type Foo = { (a: Object): string }</div><div class="line">// Message: Unexpected use of weak type &quot;Object&quot;</div><div class="line"></div><div class="line">type Foo = { (a: string): Function }</div><div class="line">// Message: Unexpected use of weak type &quot;Function&quot;</div><div class="line"></div><div class="line">function foo(thing: any) {}</div><div class="line">// Message: Unexpected use of weak type &quot;any&quot;</div><div class="line"></div><div class="line">function foo(thing: Object) {}</div><div class="line">// Message: Unexpected use of weak type &quot;Object&quot;</div><div class="line"></div><div class="line">var foo: Function</div><div class="line">// Message: Unexpected use of weak type &quot;Function&quot;</div><div class="line"></div><div class="line">var foo: Object</div><div class="line">// Message: Unexpected use of weak type &quot;Object&quot;</div><div class="line"></div><div class="line">class Foo { props: any }</div><div class="line">// Message: Unexpected use of weak type &quot;any&quot;</div><div class="line"></div><div class="line">class Foo { props: Object }</div><div class="line">// Message: Unexpected use of weak type &quot;Object&quot;</div><div class="line"></div><div class="line">var foo: any</div><div class="line">// Message: Unexpected use of weak type &quot;any&quot;</div><div class="line"></div><div class="line">// Options: [{&quot;Function&quot;:false}]</div><div class="line">type X = any; type Y = Function; type Z = Object</div><div class="line">// Message: Unexpected use of weak type &quot;any&quot;</div><div class="line">// Message: Unexpected use of weak type &quot;Object&quot;</div><div class="line"></div><div class="line">// Options: [{&quot;Object&quot;:false,&quot;any&quot;:false}]</div><div class="line">type X = any; type Y = Function; type Z = Object</div><div class="line">// Message: Unexpected use of weak type &quot;Function&quot;</div></div><!-- fragment --><p>The following patterns are not considered problems:</p>
<div class="fragment"><div class="line">function foo(thing): string {}</div><div class="line"></div><div class="line">function foo(thing): Promise&lt;string&gt; {}</div><div class="line"></div><div class="line">function foo(thing): Promise&lt;Promise&lt;string&gt;&gt; {}</div><div class="line"></div><div class="line">(foo?: string) =&gt; {}</div><div class="line"></div><div class="line">(foo: ?string) =&gt; {}</div><div class="line"></div><div class="line">(foo: { a: string }) =&gt; {}</div><div class="line"></div><div class="line">(foo: { a: ?string }) =&gt; {}</div><div class="line"></div><div class="line">(foo: string[]) =&gt; {}</div><div class="line"></div><div class="line">type Foo = string</div><div class="line"></div><div class="line">type Foo = { a: string }</div><div class="line"></div><div class="line">type Foo = { (a: string): string }</div><div class="line"></div><div class="line">function foo(thing: string) {}</div><div class="line"></div><div class="line">var foo: string</div><div class="line"></div><div class="line">class Foo { props: string }</div><div class="line"></div><div class="line">// Options: [{&quot;Object&quot;:false,&quot;any&quot;:false}]</div><div class="line">type X = any; type Y = Object</div><div class="line"></div><div class="line">// Options: [{&quot;Function&quot;:false}]</div><div class="line">type X = Function</div><div class="line"></div><div class="line">function foo(thing): Function {}</div></div><!-- fragment --><p><a class="anchor" id="eslint-plugin-flowtype-rules-object-type-delimiter"></a> </p><h3><code>object-type-delimiter</code></h3>
<p><em>The <code>--fix</code> option on the command line automatically fixes problems reported by this rule.</em></p>
<p>Enforces consistent separators between properties in Flow object types.</p>
<p>This rule takes one argument.</p>
<p>If it is &lsquo;'comma&rsquo;<code>then a problem is raised when using</code>;` as a separator.</p>
<p>If it is &lsquo;'semicolon&rsquo;<code>then a problem is raised when using</code>,` as a separator.</p>
<p>The default value is &lsquo;'comma&rsquo;`.</p>
<p><em>This rule is ported from <code>babel/flow-object-type</code>, however the default option was changed.</em></p>
<p>The following patterns are considered problems:</p>
<div class="fragment"><div class="line">// Options: [&quot;semicolon&quot;]</div><div class="line">type Foo = { a: Foo, b: Bar }</div><div class="line">// Message: Prefer semicolons to commas in object and class types</div><div class="line"></div><div class="line">// Options: [&quot;comma&quot;]</div><div class="line">type Foo = { a: Foo; b: Bar }</div><div class="line">// Message: Prefer commas to semicolons in object and class types</div><div class="line"></div><div class="line">// Options: [&quot;semicolon&quot;]</div><div class="line">type Foo = { [a: string]: Foo, [b: string]: Bar }</div><div class="line">// Message: Prefer semicolons to commas in object and class types</div><div class="line"></div><div class="line">// Options: [&quot;comma&quot;]</div><div class="line">type Foo = { [a: string]: Foo; [b: string]: Bar }</div><div class="line">// Message: Prefer commas to semicolons in object and class types</div><div class="line"></div><div class="line">// Options: [&quot;semicolon&quot;]</div><div class="line">type Foo = { (): Foo, (): Bar }</div><div class="line">// Message: Prefer semicolons to commas in object and class types</div><div class="line"></div><div class="line">// Options: [&quot;comma&quot;]</div><div class="line">type Foo = { (): Foo; (): Bar }</div><div class="line">// Message: Prefer commas to semicolons in object and class types</div><div class="line"></div><div class="line">// Options: [&quot;semicolon&quot;]</div><div class="line">declare class Foo { a: Foo, }</div><div class="line">// Message: Prefer semicolons to commas in object and class types</div><div class="line"></div><div class="line">// Options: [&quot;comma&quot;]</div><div class="line">declare class Foo { a: Foo; }</div><div class="line">// Message: Prefer commas to semicolons in object and class types</div><div class="line"></div><div class="line">// Options: [&quot;semicolon&quot;]</div><div class="line">declare class Foo { [a: string]: Foo, }</div><div class="line">// Message: Prefer semicolons to commas in object and class types</div><div class="line"></div><div class="line">// Options: [&quot;comma&quot;]</div><div class="line">declare class Foo { a: Foo; }</div><div class="line">// Message: Prefer commas to semicolons in object and class types</div><div class="line"></div><div class="line">// Options: [&quot;semicolon&quot;]</div><div class="line">declare class Foo { (): Foo, }</div><div class="line">// Message: Prefer semicolons to commas in object and class types</div><div class="line"></div><div class="line">// Options: [&quot;comma&quot;]</div><div class="line">declare class Foo { (): Foo; }</div><div class="line">// Message: Prefer commas to semicolons in object and class types</div><div class="line"></div><div class="line">// Options: [&quot;semicolon&quot;]</div><div class="line">declare class Foo { static (): Foo, }</div><div class="line">// Message: Prefer semicolons to commas in object and class types</div><div class="line"></div><div class="line">// Options: [&quot;comma&quot;]</div><div class="line">declare class Foo { static (): Foo; }</div><div class="line">// Message: Prefer commas to semicolons in object and class types</div></div><!-- fragment --><p>The following patterns are not considered problems:</p>
<div class="fragment"><div class="line">// Options: [&quot;semicolon&quot;]</div><div class="line">type Foo = { a: Foo; b: Bar }</div><div class="line"></div><div class="line">// Options: [&quot;comma&quot;]</div><div class="line">type Foo = { a: Foo, b: Bar }</div><div class="line"></div><div class="line">// Options: [&quot;semicolon&quot;]</div><div class="line">type Foo = { [a: string]: Foo; [b: string]: Bar }</div><div class="line"></div><div class="line">// Options: [&quot;comma&quot;]</div><div class="line">type Foo = { [a: string]: Foo, [b: string]: Bar }</div><div class="line"></div><div class="line">// Options: [&quot;semicolon&quot;]</div><div class="line">type Foo = { (): Foo; (): Bar }</div><div class="line"></div><div class="line">// Options: [&quot;comma&quot;]</div><div class="line">type Foo = { (): Foo, (): Bar }</div><div class="line"></div><div class="line">type Foo = { a: Foo, b: Bar }</div><div class="line"></div><div class="line">type Foo = { [a: string]: Foo, [b: string]: Bar }</div><div class="line"></div><div class="line">type Foo = { (): Foo, (): Bar }</div><div class="line"></div><div class="line">// Options: [&quot;semicolon&quot;]</div><div class="line">declare class Foo { a: Foo; }</div><div class="line"></div><div class="line">// Options: [&quot;comma&quot;]</div><div class="line">declare class Foo { a: Foo, }</div><div class="line"></div><div class="line">// Options: [&quot;semicolon&quot;]</div><div class="line">declare class Foo { [a: string]: Foo; }</div><div class="line"></div><div class="line">// Options: [&quot;comma&quot;]</div><div class="line">declare class Foo { [a: string]: Foo, }</div><div class="line"></div><div class="line">// Options: [&quot;semicolon&quot;]</div><div class="line">declare class Foo { (): Foo; }</div><div class="line"></div><div class="line">// Options: [&quot;comma&quot;]</div><div class="line">declare class Foo { (): Foo, }</div><div class="line"></div><div class="line">// Options: [&quot;semicolon&quot;]</div><div class="line">type Foo = { a: Foo, b: Bar }</div></div><!-- fragment --><p><a class="anchor" id="eslint-plugin-flowtype-rules-require-parameter-type"></a> </p><h3><code>require-parameter-type</code></h3>
<p>Requires that all function parameters have type annotations.</p>
<p><a class="anchor" id="eslint-plugin-flowtype-rules-require-parameter-type-options"></a> </p><h4>Options</h4>
<p>You can skip all arrow functions by providing the <code>excludeArrowFunctions</code> option with <code>true</code>.</p>
<p>Alternatively, you can want to exclude only concise arrow functions (e.g. <code>x =&gt; x * 2</code>). Provide <code>excludeArrowFunctions</code> with <code>expressionsOnly</code> for this.</p>
<div class="fragment"><div class="line">{</div><div class="line">    &quot;rules&quot;: {</div><div class="line">        &quot;flowtype/require-parameter-type&quot;: [</div><div class="line">            2,</div><div class="line">            {</div><div class="line">              &quot;excludeArrowFunctions&quot;: true</div><div class="line">            }</div><div class="line">        ]</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">{</div><div class="line">    &quot;rules&quot;: {</div><div class="line">        &quot;flowtype/require-parameter-type&quot;: [</div><div class="line">            2,</div><div class="line">            {</div><div class="line">              &quot;excludeArrowFunctions&quot;: &quot;expressionsOnly&quot;</div><div class="line">            }</div><div class="line">        ]</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>You can exclude parameters that match a certain regex by using <code>excludeParameterMatch</code>.</p>
<div class="fragment"><div class="line">{</div><div class="line">    &quot;rules&quot;: {</div><div class="line">        &quot;flowtype/require-parameter-type&quot;: [</div><div class="line">            2,</div><div class="line">            {</div><div class="line">              &quot;excludeParameterMatch&quot;: &quot;^_&quot;</div><div class="line">            }</div><div class="line">        ]</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>This excludes all parameters that start with an underscore (<code>_</code>). The default pattern is <code>a^</code>, which doesn't match anything, i.e., all parameters are checked.</p>
<p>The following patterns are considered problems:</p>
<div class="fragment"><div class="line">(foo) =&gt; {}</div><div class="line">// Message: Missing &quot;foo&quot; parameter type annotation.</div><div class="line"></div><div class="line">function x(foo) {}</div><div class="line">// Message: Missing &quot;foo&quot; parameter type annotation.</div><div class="line"></div><div class="line">// Options: [{&quot;excludeArrowFunctions&quot;:true}]</div><div class="line">function x(foo) {}</div><div class="line">// Message: Missing &quot;foo&quot; parameter type annotation.</div><div class="line"></div><div class="line">(foo = &#39;FOO&#39;) =&gt; {}</div><div class="line">// Message: Missing &quot;foo&quot; parameter type annotation.</div><div class="line"></div><div class="line">(...foo) =&gt; {}</div><div class="line">// Message: Missing &quot;foo&quot; parameter type annotation.</div><div class="line"></div><div class="line">({foo}) =&gt; {}</div><div class="line">// Message: Missing &quot;{foo}&quot; parameter type annotation.</div><div class="line"></div><div class="line">([foo]) =&gt; {}</div><div class="line">// Message: Missing &quot;[foo]&quot; parameter type annotation.</div><div class="line"></div><div class="line">({foo = 1} = {}) =&gt; {}</div><div class="line">// Message: Missing &quot;{foo = 1}&quot; parameter type annotation.</div><div class="line"></div><div class="line">// @flow</div><div class="line">(foo) =&gt; {}</div><div class="line">// Message: Missing &quot;foo&quot; parameter type annotation.</div><div class="line"></div><div class="line">// Options: [{&quot;excludeArrowFunctions&quot;:&quot;expressionsOnly&quot;}]</div><div class="line">(foo) =&gt; {}</div><div class="line">// Message: Missing &quot;foo&quot; parameter type annotation.</div><div class="line"></div><div class="line">// Options: [{&quot;excludeArrowFunctions&quot;:&quot;expressionsOnly&quot;}]</div><div class="line">function x(foo) {}</div><div class="line">// Message: Missing &quot;foo&quot; parameter type annotation.</div><div class="line"></div><div class="line">// Options: [{&quot;excludeParameterMatch&quot;:&quot;^_&quot;}]</div><div class="line">(_foo: number, bar) =&gt; {}</div><div class="line">// Message: Missing &quot;bar&quot; parameter type annotation.</div><div class="line"></div><div class="line">// Options: [{&quot;excludeParameterMatch&quot;:&quot;^_&quot;}]</div><div class="line">(_foo, bar) =&gt; {}</div><div class="line">// Message: Missing &quot;bar&quot; parameter type annotation.</div></div><!-- fragment --><p>The following patterns are not considered problems:</p>
<div class="fragment"><div class="line">(foo: string) =&gt; {}</div><div class="line"></div><div class="line">(foo: string = &#39;FOO&#39;) =&gt; {}</div><div class="line"></div><div class="line">(...foo: string) =&gt; {}</div><div class="line"></div><div class="line">({foo}: {foo: string}) =&gt; {}</div><div class="line"></div><div class="line">([foo]: Array) =&gt; {}</div><div class="line"></div><div class="line">(foo) =&gt; {}</div><div class="line"></div><div class="line">// Options: [{&quot;excludeArrowFunctions&quot;:true}]</div><div class="line">(foo) =&gt; {}</div><div class="line"></div><div class="line">// Options: [{&quot;excludeArrowFunctions&quot;:&quot;expressionsOnly&quot;}]</div><div class="line">(foo) =&gt; 3</div><div class="line"></div><div class="line">// Options: [{&quot;excludeParameterMatch&quot;:&quot;^_&quot;}]</div><div class="line">(_foo, bar: string) =&gt; {}</div><div class="line"></div><div class="line">// Options: [{&quot;excludeParameterMatch&quot;:&quot;^_&quot;}]</div><div class="line">(_foo: number, bar: string) =&gt; {}</div><div class="line"></div><div class="line">(foo) =&gt; {}</div></div><!-- fragment --><p><a class="anchor" id="eslint-plugin-flowtype-rules-require-return-type"></a> </p><h3><code>require-return-type</code></h3>
<p>Requires that functions have return type annotation.</p>
<p><a class="anchor" id="eslint-plugin-flowtype-rules-require-return-type-options"></a> </p><h4>Options</h4>
<p>You can skip all arrow functions by providing the <code>excludeArrowFunctions</code> option with <code>true</code>.</p>
<p>Alternatively, you can exclude a concise arrow function (e.g. <code>() =&gt; 2</code>). Provide <code>excludeArrowFunctions</code> with <code>expressionsOnly</code> for this.</p>
<div class="fragment"><div class="line">{</div><div class="line">    &quot;rules&quot;: {</div><div class="line">        &quot;flowtype/require-return-type&quot;: [</div><div class="line">            2,</div><div class="line">            &quot;always&quot;,</div><div class="line">            {</div><div class="line">              &quot;excludeArrowFunctions&quot;: true</div><div class="line">            }</div><div class="line">        ]</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">{</div><div class="line">    &quot;rules&quot;: {</div><div class="line">        &quot;flowtype/require-return-type&quot;: [</div><div class="line">            2,</div><div class="line">            &quot;always&quot;,</div><div class="line">            {</div><div class="line">              &quot;excludeArrowFunctions&quot;: &quot;expressionsOnly&quot;</div><div class="line">            }</div><div class="line">        ]</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>You can exclude or include specific tests with the <code>includeOnlyMatching</code> and <code>excludeMatching</code> rules.</p>
<div class="fragment"><div class="line">{</div><div class="line">    &quot;rules&quot;: {</div><div class="line">        &quot;flowtype/require-return-type&quot;: [</div><div class="line">            2,</div><div class="line">            &quot;always&quot;,</div><div class="line">            {</div><div class="line">              &quot;includeOnlyMatching&quot;: [</div><div class="line">                  &quot;^F.*&quot;,</div><div class="line">                  &quot;Ba(r|z)&quot;</div><div class="line">              ]</div><div class="line">            }</div><div class="line">        ]</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">{</div><div class="line">    &quot;rules&quot;: {</div><div class="line">        &quot;flowtype/require-return-type&quot;: [</div><div class="line">            2,</div><div class="line">            &quot;always&quot;,</div><div class="line">            {</div><div class="line">              &quot;excludeMatching&quot;: [</div><div class="line">                  &quot;^F.*&quot;,</div><div class="line">                  &quot;Ba(r|z)&quot;</div><div class="line">              ]</div><div class="line">            }</div><div class="line">        ]</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Both rules take an array that can contain either strings or valid RegExp statements.</p>
<p>The following patterns are considered problems:</p>
<div class="fragment"><div class="line">(foo) =&gt; { return &quot;foo&quot;; }</div><div class="line">// Message: Missing return type annotation.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">(foo) =&gt; { return &quot;foo&quot;; }</div><div class="line">// Message: Missing return type annotation.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">(foo) =&gt; &quot;foo&quot;</div><div class="line">// Message: Missing return type annotation.</div><div class="line"></div><div class="line">(foo) =&gt; ({})</div><div class="line">// Message: Missing return type annotation.</div><div class="line"></div><div class="line">(foo): undefined =&gt; { return; }</div><div class="line">// Message: Must not annotate undefined return type.</div><div class="line"></div><div class="line">(foo): void =&gt; { return; }</div><div class="line">// Message: Must not annotate undefined return type.</div><div class="line"></div><div class="line">(foo): undefined =&gt; { return undefined; }</div><div class="line">// Message: Must not annotate undefined return type.</div><div class="line"></div><div class="line">(foo): void =&gt; { return void 0; }</div><div class="line">// Message: Must not annotate undefined return type.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;annotateUndefined&quot;:&quot;never&quot;}]</div><div class="line">(foo): undefined =&gt; { return; }</div><div class="line">// Message: Must not annotate undefined return type.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;annotateUndefined&quot;:&quot;never&quot;}]</div><div class="line">(foo): void =&gt; { return; }</div><div class="line">// Message: Must not annotate undefined return type.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;annotateUndefined&quot;:&quot;always&quot;}]</div><div class="line">(foo) =&gt; { return; }</div><div class="line">// Message: Must annotate undefined return type.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;annotateUndefined&quot;:&quot;never&quot;}]</div><div class="line">(foo): undefined =&gt; { return undefined; }</div><div class="line">// Message: Must not annotate undefined return type.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;annotateUndefined&quot;:&quot;always&quot;}]</div><div class="line">(foo) =&gt; { return undefined; }</div><div class="line">// Message: Must annotate undefined return type.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;annotateUndefined&quot;:&quot;always&quot;}]</div><div class="line">(foo) =&gt; { return void 0; }</div><div class="line">// Message: Must annotate undefined return type.</div><div class="line"></div><div class="line">// @flow</div><div class="line">(foo) =&gt; { return 1; }</div><div class="line">// Message: Missing return type annotation.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;annotateUndefined&quot;:&quot;always&quot;}]</div><div class="line">// @flow</div><div class="line"> (foo) =&gt; { return undefined; }</div><div class="line">// Message: Must annotate undefined return type.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">async () =&gt; { return 2; }</div><div class="line">// Message: Missing return type annotation.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;annotateUndefined&quot;:&quot;always&quot;}]</div><div class="line">async () =&gt; {}</div><div class="line">// Message: Missing return type annotation.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;annotateUndefined&quot;:&quot;always&quot;}]</div><div class="line">async function x() {}</div><div class="line">// Message: Missing return type annotation.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">async () =&gt; { return; }</div><div class="line">// Message: Missing return type annotation.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">function* x() {}</div><div class="line">// Message: Missing return type annotation.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;excludeArrowFunctions&quot;:&quot;expressionsOnly&quot;}]</div><div class="line">() =&gt; { return 3; }</div><div class="line">// Message: Missing return type annotation.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;excludeArrowFunctions&quot;:&quot;expressionsOnly&quot;}]</div><div class="line">async () =&gt; { return 4; }</div><div class="line">// Message: Missing return type annotation.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;includeOnlyMatching&quot;:[&quot;bar&quot;]}]</div><div class="line">function foo() { return 42; }</div><div class="line">function bar() { return 42; }</div><div class="line">// Message: Missing return type annotation.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;includeOnlyMatching&quot;:[&quot;bar&quot;]}]</div><div class="line">const foo = () =&gt; { return 42; };</div><div class="line">const bar = () =&gt; { return 42; }</div><div class="line">// Message: Missing return type annotation.</div></div><!-- fragment --><p>The following patterns are not considered problems:</p>
<div class="fragment"><div class="line">return;</div><div class="line"></div><div class="line">(foo): string =&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">(foo): string =&gt; {}</div><div class="line"></div><div class="line">(foo) =&gt; { return; }</div><div class="line"></div><div class="line">(foo): Object =&gt; ( {} )</div><div class="line"></div><div class="line">(foo) =&gt; { return undefined; }</div><div class="line"></div><div class="line">(foo) =&gt; { return void 0; }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;annotateUndefined&quot;:&quot;always&quot;}]</div><div class="line">(foo): undefined =&gt; { return; }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;annotateUndefined&quot;:&quot;always&quot;}]</div><div class="line">(foo): void =&gt; { return; }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;annotateUndefined&quot;:&quot;never&quot;}]</div><div class="line">(foo) =&gt; { return; }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;annotateUndefined&quot;:&quot;never&quot;}]</div><div class="line">(foo) =&gt; { return undefined; }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;annotateUndefined&quot;:&quot;never&quot;}]</div><div class="line">(foo) =&gt; { return void 0; }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;annotateUndefined&quot;:&quot;always&quot;}]</div><div class="line">(foo): undefined =&gt; { return undefined; }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;annotateUndefined&quot;:&quot;always&quot;}]</div><div class="line">(foo): void =&gt; { return void 0; }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">(foo) =&gt; { return 1; }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;annotateUndefined&quot;:&quot;always&quot;}]</div><div class="line">(foo) =&gt; { return undefined; }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;annotateUndefined&quot;:&quot;always&quot;}]</div><div class="line">async function doThing(): Promise&lt;void&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;annotateUndefined&quot;:&quot;always&quot;}]</div><div class="line">function* doThing(): Generator&lt;number, void, void&gt; { yield 2; }</div><div class="line"></div><div class="line">async (foo): Promise&lt;number&gt; =&gt; { return 3; }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;excludeArrowFunctions&quot;:true}]</div><div class="line">() =&gt; 3</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;excludeArrowFunctions&quot;:true}]</div><div class="line">() =&gt; { return 4; }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;excludeArrowFunctions&quot;:true}]</div><div class="line">() =&gt; undefined</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;annotateUndefined&quot;:&quot;always&quot;,&quot;excludeArrowFunctions&quot;:true}]</div><div class="line">() =&gt; undefined</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;annotateUndefined&quot;:&quot;always&quot;,&quot;excludeArrowFunctions&quot;:true}]</div><div class="line">() =&gt; { return undefined; }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;excludeArrowFunctions&quot;:&quot;expressionsOnly&quot;}]</div><div class="line">() =&gt; 3</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;excludeArrowFunctions&quot;:&quot;expressionsOnly&quot;}]</div><div class="line">async () =&gt; 3</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;excludeMatching&quot;:[&quot;foo&quot;]}]</div><div class="line">function foo() { return 42; }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;includeOnlyMatching&quot;:[&quot;bar&quot;]}]</div><div class="line">function foo() { return 42; }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;excludeMatching&quot;:[&quot;bar&quot;]}]</div><div class="line">function foo(): number { return 42; }</div><div class="line">function bar() { return 42; }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;includeOnlyMatching&quot;:[&quot;foo&quot;,&quot;baz&quot;]}]</div><div class="line">function foo(): number { return 42; }</div><div class="line">function bar() { return 42; }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;excludeMatching&quot;:[&quot;^b.*&quot;,&quot;qux&quot;]}]</div><div class="line">function foo(): number { return 42; }</div><div class="line">function bar() { return 42; }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;includeOnlyMatching&quot;:[&quot;^f.*&quot;]}]</div><div class="line">function foo(): number { return 42; }</div><div class="line">function bar() { return 42; }</div></div><!-- fragment --><p><a class="anchor" id="eslint-plugin-flowtype-rules-require-valid-file-annotation"></a> </p><h3><code>require-valid-file-annotation</code></h3>
<p>This rule validates Flow file annotations.</p>
<p>This rule can optionally report missing or missed placed annotations, common typos (e.g. <code>// @floww</code>), and enforce a consistant annotation style.</p>
<p><a class="anchor" id="eslint-plugin-flowtype-rules-require-valid-file-annotation-options"></a> </p><h4>Options</h4>
<p>The rule has a string option:</p>
<ul>
<li><code>"never"</code> (default): Never report files that are missing an <code>@flow</code> annotation.</li>
<li><code>"always"</code>: Always report files that are missing an <code>@flow</code> annotation</li>
</ul>
<p>This rule has an object option:</p>
<ul>
<li><code>"annotationStyle"</code> - Enforce a consistant file annotation style.<ul>
<li><code>"none"</code> (default): Either annotation style is accepted.</li>
<li><code>"line"</code>: Require single line annotations (i.e. <code>// @flow</code>).</li>
<li><code>"block"</code>: Require block annotations (i.e. <code>/* @flow */</code>).</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line">{</div><div class="line">  &quot;rules&quot;: {</div><div class="line">    &quot;flowtype/require-valid-file-annotation&quot;: [</div><div class="line">      2,</div><div class="line">      &quot;always&quot;</div><div class="line">    ]</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line">{</div><div class="line">  &quot;rules&quot;: {</div><div class="line">    &quot;flowtype/require-valid-file-annotation&quot;: [</div><div class="line">      2,</div><div class="line">      &quot;always&quot;, {</div><div class="line">        &quot;annotationStyle&quot;: &quot;block&quot;</div><div class="line">      }</div><div class="line">    ]</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>The following patterns are considered problems:</p>
<p>```js ;//  // Message: Flow file annotation not at the top of the file.</p>
<p>; //  // Message: Flow file annotation not at the top of the file.</p>
<p>//  // Message: Malformed Flow file annotation.</p>
<p>//  // Message: Malformed Flow file annotation.</p>
<p>//  // Message: Malformed Flow file annotation.</p>
<p>//  // Message: Misspelled or malformed Flow file annotation.</p>
<p>//  // Message: Misspelled or malformed Flow file annotation.</p>
<p>// Options: ["always"] a; // Message: Flow file annotation is missing.</p>
<p>// Options: ["always",{"annotationStyle":"line"}] /*  */ // Message: Flow file annotation style must be <code>// @flow</code></p>
<p>// Options: ["always",{"annotationStyle":"block"}] //  // Message: Flow file annotation style must be <code>/* @flow */</code></p>
<p>// Options: ["always",{"annotationStyle":"line"}] /*  */ // Message: Flow file annotation style must be <code>// @noflow</code></p>
<p>// Options: ["always",{"annotationStyle":"block"}] //  // Message: Flow file annotation style must be <code>/* @noflow */</code> </p><div class="fragment"><div class="line">The following patterns are not considered problems:</div><div class="line"></div><div class="line">```js</div><div class="line">a;</div><div class="line"></div><div class="line">// @flow</div><div class="line">a;</div><div class="line"></div><div class="line">//@flow</div><div class="line">a;</div><div class="line"></div><div class="line">//**@flow</div><div class="line">a;</div><div class="line"></div><div class="line">/* foo @flow bar */</div><div class="line">a;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// @flow</div><div class="line">a;</div><div class="line"></div><div class="line">// @flow</div><div class="line">// @FLow</div><div class="line"></div><div class="line">// @noflow</div><div class="line">a;</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">a;</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;annotationStyle&quot;:&quot;line&quot;}]</div><div class="line">// @flow</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;annotationStyle&quot;:&quot;block&quot;}]</div><div class="line">/* @flow */</div></div><!-- fragment --><p><a class="anchor" id="eslint-plugin-flowtype-rules-require-variable-type"></a> </p><h3><code>require-variable-type</code></h3>
<p>Requires that all variable declarators have type annotations.</p>
<p><a class="anchor" id="eslint-plugin-flowtype-rules-require-variable-type-options"></a> </p><h4>Options</h4>
<p>You can exclude variables that match a certain regex by using <code>excludeVariableMatch</code>.</p>
<p>This excludes all parameters that start with an underscore (<code>_</code>). The default pattern is <code>a^</code>, which doesn't match anything, i.e., all parameters are checked.</p>
<div class="fragment"><div class="line">{</div><div class="line">    &quot;rules&quot;: {</div><div class="line">        &quot;flowtype/require-variable-type&quot;: [</div><div class="line">            2,</div><div class="line">            {</div><div class="line">              &quot;excludeVariableMatch&quot;: &quot;^_&quot;</div><div class="line">            }</div><div class="line">        ]</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>You can choose specific variable types (<code>var</code>, <code>let</code>, and <code>const</code>) to ignore using <code>excludeVariableTypes</code>.</p>
<p>This excludes <code>var</code> and <code>let</code> declarations from needing type annotations, but forces <code>const</code> declarations to have it. By default, all declarations are checked.</p>
<div class="fragment"><div class="line">{</div><div class="line">    &quot;rules&quot;: {</div><div class="line">        &quot;flowtype/require-variable-type&quot;: [</div><div class="line">            2,</div><div class="line">            {</div><div class="line">              &quot;excludeVariableTypes&quot;: {</div><div class="line">                &quot;var&quot;: true,</div><div class="line">                &quot;let&quot;: true,</div><div class="line">                &quot;const&quot;: false,</div><div class="line">              }</div><div class="line">            }</div><div class="line">        ]</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The following patterns are considered problems:</p>
<div class="fragment"><div class="line">var foo = &quot;bar&quot;</div><div class="line">// Message: Missing &quot;foo&quot; variable type annotation.</div><div class="line"></div><div class="line">var foo : string = &quot;bar&quot;, bar = 1</div><div class="line">// Message: Missing &quot;bar&quot; variable type annotation.</div><div class="line"></div><div class="line">// Options: [{&quot;excludeVariableMatch&quot;:&quot;^_&quot;}]</div><div class="line">var _foo = &quot;bar&quot;, bar = 1</div><div class="line">// Message: Missing &quot;bar&quot; variable type annotation.</div><div class="line"></div><div class="line">// Options: [{&quot;excludeVariableTypes&quot;:{&quot;let&quot;:false,&quot;var&quot;:true}}]</div><div class="line">var foo = &quot;bar&quot;, bar = 1; const oob : string = &quot;oob&quot;; let hey = &quot;yah&quot;</div><div class="line">// Message: Missing &quot;hey&quot; variable type annotation.</div></div><!-- fragment --><p>The following patterns are not considered problems:</p>
<div class="fragment"><div class="line">var foo : string = &quot;bar&quot;</div><div class="line"></div><div class="line">var foo : string = &quot;bar&quot;, bar : number = 1</div><div class="line"></div><div class="line">// Options: [{&quot;excludeVariableMatch&quot;:&quot;^_&quot;}]</div><div class="line">var _foo = &quot;bar&quot;, bar : number = 1</div><div class="line"></div><div class="line">// Options: [{&quot;excludeVariableTypes&quot;:{&quot;var&quot;:true}}]</div><div class="line">var foo = &quot;bar&quot;, bar = 1</div><div class="line"></div><div class="line">// Options: [{&quot;excludeVariableTypes&quot;:{&quot;let&quot;:true,&quot;var&quot;:true}}]</div><div class="line">var foo = &quot;bar&quot;, bar = 1; const oob : string = &quot;oob&quot;; let hey = &quot;yah&quot;</div></div><!-- fragment --><p><a class="anchor" id="eslint-plugin-flowtype-rules-semi"></a> </p><h3><code>semi</code></h3>
<p><em>The <code>--fix</code> option on the command line automatically fixes problems reported by this rule.</em></p>
<p>Enforces consistent use of semicolons after type aliases.</p>
<p>This rule takes one argument. If it is &lsquo;'never&rsquo;<code>then a problem is raised when there is a semicolon after a type alias. If it is</code>'always'` then a problem is raised when there is no semicolon after a type alias.</p>
<p>The default value is &lsquo;'always&rsquo;`.</p>
<p>The following patterns are considered problems:</p>
<div class="fragment"><div class="line">// Options: []</div><div class="line">type FooType = {}</div><div class="line">// Message: Missing semicolon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type FooType = {}</div><div class="line">// Message: Missing semicolon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type FooType = {};</div><div class="line">// Message: Extra semicolon.</div></div><!-- fragment --><p>The following patterns are not considered problems:</p>
<div class="fragment"><div class="line">type FooType = {};</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type FooType = {};</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type FooType = { a: number;</div><div class="line"> b: string;</div><div class="line"> };</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type FooType = { a: number;</div><div class="line"> b: string;</div><div class="line"> }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type FooType = {}</div><div class="line"></div><div class="line">type FooType = {}</div></div><!-- fragment --><p><a class="anchor" id="eslint-plugin-flowtype-rules-sort-keys"></a> </p><h3><code>sort-keys</code></h3>
<p>Enforces sorting of Object annotations.</p>
<p>This rule mirrors ESlint's <a href="http://eslint.org/docs/rules/sort-keys">sort-keys</a> rule.</p>
<p><a class="anchor" id="eslint-plugin-flowtype-rules-sort-keys-options"></a> </p><h4>Options</h4>
<p>The first option specifies sort order.</p>
<ul>
<li><code>"asc"</code> (default) - enforce ascending sort order.</li>
<li><code>"desc"</code> - enforce descending sort order.</li>
</ul>
<p>The second option takes an object with two possible properties.</p>
<ul>
<li><code>caseSensitive</code> - if <code>true</code>, enforce case-sensitive sort order. Default is <code>true</code>.</li>
<li><code>natural</code> - if <code>true</code>, enforce <a href="https://en.wikipedia.org/wiki/Natural_sort_order">natural sort order</a>. Default is <code>false</code>.</li>
</ul>
<div class="fragment"><div class="line">{</div><div class="line">  &quot;rules&quot;: {</div><div class="line">    &quot;flowtype/sort-keys&quot;: [</div><div class="line">      2,</div><div class="line">      &quot;asc&quot;, {</div><div class="line">        &quot;caseSensitive&quot;: true,</div><div class="line">        &quot;natural&quot;: false</div><div class="line">      }</div><div class="line">    ]</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>The following patterns are considered problems:</p>
<div class="fragment"><div class="line">type FooType = { a: number, c: number, b: string }</div><div class="line">// Message: Expected type annotations to be in ascending order. &quot;b&quot; should be before &quot;c&quot;.</div><div class="line"></div><div class="line">type FooType = { a: number, b: number, C: number }</div><div class="line">// Message: Expected type annotations to be in ascending order. &quot;C&quot; should be before &quot;b&quot;.</div><div class="line"></div><div class="line">type FooType = { 1: number, 2: number, 10: number }</div><div class="line">// Message: Expected type annotations to be in ascending order. &quot;10&quot; should be before &quot;2&quot;.</div><div class="line"></div><div class="line">// Options: [&quot;desc&quot;]</div><div class="line">type FooType = { a: number, b: number }</div><div class="line">// Message: Expected type annotations to be in descending order. &quot;b&quot; should be before &quot;a&quot;.</div><div class="line"></div><div class="line">// Options: [&quot;desc&quot;]</div><div class="line">type FooType = { C: number, b: number, a: string }</div><div class="line">// Message: Expected type annotations to be in descending order. &quot;b&quot; should be before &quot;C&quot;.</div><div class="line"></div><div class="line">// Options: [&quot;desc&quot;]</div><div class="line">type FooType = { 10: number, 2: number, 1: number }</div><div class="line">// Message: Expected type annotations to be in descending order. &quot;2&quot; should be before &quot;10&quot;.</div><div class="line"></div><div class="line">// Options: [&quot;asc&quot;,{&quot;caseSensitive&quot;:false}]</div><div class="line">type FooType = { a: number, c: number, C: number, b: string }</div><div class="line">// Message: Expected type annotations to be in insensitive ascending order. &quot;b&quot; should be before &quot;C&quot;.</div><div class="line"></div><div class="line">// Options: [&quot;asc&quot;,{&quot;caseSensitive&quot;:false}]</div><div class="line">type FooType = { a: number, C: number, c: number, b: string }</div><div class="line">// Message: Expected type annotations to be in insensitive ascending order. &quot;b&quot; should be before &quot;c&quot;.</div><div class="line"></div><div class="line">// Options: [&quot;asc&quot;,{&quot;natural&quot;:true}]</div><div class="line">type FooType = { 1: number, 10: number, 2: boolean }</div><div class="line">// Message: Expected type annotations to be in natural ascending order. &quot;2&quot; should be before &quot;10&quot;.</div></div><!-- fragment --><p>The following patterns are not considered problems:</p>
<div class="fragment"><div class="line">type FooType = { a: number }</div><div class="line"></div><div class="line">type FooType = { a: number, b: number, c: (boolean | number) }</div><div class="line"></div><div class="line">type FooType = { C: number, a: string, b: foo }</div><div class="line"></div><div class="line">type FooType = { 1: number, 10: number, 2: boolean }</div><div class="line"></div><div class="line">// Options: [&quot;desc&quot;]</div><div class="line">type FooType = { c: number, b: number, a: number }</div><div class="line"></div><div class="line">// Options: [&quot;desc&quot;]</div><div class="line">type FooType = { b: string, a: {}, C: number }</div><div class="line"></div><div class="line">// Options: [&quot;desc&quot;]</div><div class="line">type FooType = { 2: number, 10: number, 1: boolean }</div><div class="line"></div><div class="line">// Options: [&quot;asc&quot;,{&quot;caseSensitive&quot;:false}]</div><div class="line">type FooType = { a: number, b: number, c: number, C: number }</div><div class="line"></div><div class="line">// Options: [&quot;asc&quot;,{&quot;caseSensitive&quot;:false}]</div><div class="line">type FooType = { a: number, b: number, C: number, c: number }</div><div class="line"></div><div class="line">// Options: [&quot;asc&quot;,{&quot;natural&quot;:true}]</div><div class="line">type FooType = { 1:number, 2: number, 10: number }</div><div class="line"></div><div class="line">type FooType = { b: number, a: number }</div></div><!-- fragment --><p><a class="anchor" id="eslint-plugin-flowtype-rules-space-after-type-colon"></a> </p><h3><code>space-after-type-colon</code></h3>
<p><em>The <code>--fix</code> option on the command line automatically fixes problems reported by this rule.</em></p>
<p>Enforces consistent spacing after the type annotation colon.</p>
<p><a class="anchor" id="eslint-plugin-flowtype-rules-space-after-type-colon-options"></a> </p><h4>Options</h4>
<p>This rule has a string argument.</p>
<ul>
<li><code>"always"</code> (default): Require a space after the type annotation colon (e.g. foo: BarType).</li>
<li><code>"never"</code>: Require no spaces after the type annotation colon (e.g. foo:BarType).</li>
</ul>
<p>This rule has an option object.</p>
<ul>
<li><code>"allowLineBreak"</code> - Allow a line break to count as a space following the annotation colon.<ul>
<li><code>"true"</code>: Enable</li>
<li><code>"false"</code>: Disable</li>
</ul>
</li>
</ul>
<p>{ "rules": { "flowtype/space-after-type-colon": [ 2, "always", { "allowLineBreak": false } ] } }</p>
<p>The following patterns are considered problems:</p>
<div class="fragment"><div class="line">// Options: [&quot;never&quot;]</div><div class="line">(foo: string) =&gt; {}</div><div class="line">// Message: There must be no space after &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">(foo:  string) =&gt; {}</div><div class="line">// Message: There must be 1 space after &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">(foo:(() =&gt; void)) =&gt; {}</div><div class="line">// Message: There must be a space after &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">(foo: (() =&gt; void)) =&gt; {}</div><div class="line">// Message: There must be no space after &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">(foo:  (() =&gt; void)) =&gt; {}</div><div class="line">// Message: There must be 1 space after &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">({ lorem, ipsum, dolor } :   SomeType) =&gt; {}</div><div class="line">// Message: There must be 1 space after &quot;{ lorem, ipsum, dolor }&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">(foo:{ a: string, b: number }) =&gt; {}</div><div class="line">// Message: There must be a space after &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">({ a, b } :{ a: string, b: number }) =&gt; {}</div><div class="line">// Message: There must be a space after &quot;{ a, b }&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">([ a, b ] :string[]) =&gt; {}</div><div class="line">// Message: There must be a space after &quot;[ a, b ]&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">(i?:number) =&gt; {}</div><div class="line">// Message: There must be a space after &quot;i&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">(i?:  number) =&gt; {}</div><div class="line">// Message: There must be 1 space after &quot;i&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">(i?: number) =&gt; {}</div><div class="line">// Message: There must be no space after &quot;i&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">(foo:</div><div class="line">  { a: string, b: number }) =&gt; {}</div><div class="line">// Message: There must be 1 space after &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">():Object =&gt; {}</div><div class="line">// Message: There must be a space after return type colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">(): Object =&gt; {}</div><div class="line">// Message: There must be no space after return type colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">():  Object =&gt; {}</div><div class="line">// Message: There must be 1 space after return type colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">():(() =&gt; void) =&gt; {}</div><div class="line">// Message: There must be a space after return type colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">(): (() =&gt; void) =&gt; {}</div><div class="line">// Message: There must be no space after return type colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">():  (() =&gt; void) =&gt; {}</div><div class="line">// Message: There must be 1 space after return type colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">export default function (foo: string) {}</div><div class="line">// Message: There must be no space after &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">function foo (foo: string) {}</div><div class="line">// Message: There must be no space after &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">(foo:string) =&gt; {}</div><div class="line">// Message: There must be a space after &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">function foo (foo:string) {}</div><div class="line">// Message: There must be a space after &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">async function foo({ lorem, ipsum, dolor }:SomeType) {}</div><div class="line">// Message: There must be a space after &quot;{ lorem, ipsum, dolor }&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">function x(i?:number) {}</div><div class="line">// Message: There must be a space after &quot;i&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">function x(i?:  number) {}</div><div class="line">// Message: There must be 1 space after &quot;i&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">function x(i?: number) {}</div><div class="line">// Message: There must be no space after &quot;i&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">function a():x {}</div><div class="line">// Message: There must be a space after return type colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">function a():  x {}</div><div class="line">// Message: There must be 1 space after return type colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">function a(): x {}</div><div class="line">// Message: There must be no space after return type colon.</div><div class="line"></div><div class="line">type X = (foo:number) =&gt; string</div><div class="line">// Message: There must be a space after &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = (foo: number) =&gt; string</div><div class="line">// Message: There must be no space after &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">type X = (foo:  number) =&gt; string</div><div class="line">// Message: There must be 1 space after &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">type X = (foo:?number) =&gt; string</div><div class="line">// Message: There must be a space after &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">type X = (foo:(number)) =&gt; string</div><div class="line">// Message: There must be a space after &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">type X = (foo:((number))) =&gt; string</div><div class="line">// Message: There must be a space after &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">type X = (foo:  ((number))) =&gt; string</div><div class="line">// Message: There must be 1 space after &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = (foo: ((number))) =&gt; string</div><div class="line">// Message: There must be no space after &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">type X = (foo:?(number)) =&gt; string</div><div class="line">// Message: There must be a space after &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">type TArrayPredicate = (el: T, i?:number) =&gt; boolean</div><div class="line">// Message: There must be a space after &quot;i&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">type TArrayPredicate = (el: T, i?:  number) =&gt; boolean</div><div class="line">// Message: There must be 1 space after &quot;i&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type TArrayPredicate = (el:T, i?: number) =&gt; boolean</div><div class="line">// Message: There must be no space after &quot;i&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">class X { foo:string }</div><div class="line">// Message: There must be a space after &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">class X { foo: string }</div><div class="line">// Message: There must be no space after &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">class X { foo:?string }</div><div class="line">// Message: There must be a space after &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">class X { foo: ?string }</div><div class="line">// Message: There must be no space after &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">class X { static foo:number }</div><div class="line">// Message: There must be a space after &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">class X { static foo: number }</div><div class="line">// Message: There must be no space after &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">class X { static foo :number }</div><div class="line">// Message: There must be a space after &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">class X { static foo : number }</div><div class="line">// Message: There must be no space after &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">declare class X { static foo:number }</div><div class="line">// Message: There must be a space after &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">declare class X { static foo: number }</div><div class="line">// Message: There must be no space after &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">declare class X { static foo :number }</div><div class="line">// Message: There must be a space after &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">declare class X { static foo : number }</div><div class="line">// Message: There must be no space after &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">class X { +foo:string }</div><div class="line">// Message: There must be a space after &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">class X { +foo:  string }</div><div class="line">// Message: There must be 1 space after &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">class X { +foo: string }</div><div class="line">// Message: There must be no space after &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">class X { static +foo:string }</div><div class="line">// Message: There must be a space after &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">class X { static +foo:  string }</div><div class="line">// Message: There must be 1 space after &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">class X { static +foo: string }</div><div class="line">// Message: There must be no space after &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">type X = { foo:string }</div><div class="line">// Message: There must be a space after &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { foo:string }</div><div class="line">// Message: There must be a space after &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { foo: string }</div><div class="line">// Message: There must be no space after &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">type X = { foo:  string }</div><div class="line">// Message: There must be 1 space after &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">type X = { foo?:string }</div><div class="line">// Message: There must be a space after &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { foo?: string }</div><div class="line">// Message: There must be no space after &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">type X = { foo?:?string }</div><div class="line">// Message: There must be a space after &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">type X = { foo?:  ?string }</div><div class="line">// Message: There must be 1 space after &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">type Foo = { barType:(string | () =&gt; void) }</div><div class="line">// Message: There must be a space after &quot;barType&quot; type annotation colon.</div><div class="line"></div><div class="line">type Foo = { barType:(((string | () =&gt; void))) }</div><div class="line">// Message: There must be a space after &quot;barType&quot; type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type Foo = { barType: (string | () =&gt; void) }</div><div class="line">// Message: There must be no space after &quot;barType&quot; type annotation colon.</div><div class="line"></div><div class="line">type Foo = { barType:  (string | () =&gt; void) }</div><div class="line">// Message: There must be 1 space after &quot;barType&quot; type annotation colon.</div><div class="line"></div><div class="line">type Foo = { barType:  ((string | () =&gt; void)) }</div><div class="line">// Message: There must be 1 space after &quot;barType&quot; type annotation colon.</div><div class="line"></div><div class="line">type X = { get:() =&gt; A; }</div><div class="line">// Message: There must be a space after &quot;get&quot; type annotation colon.</div><div class="line"></div><div class="line">type X = { get:&lt;X&gt;() =&gt; A; }</div><div class="line">// Message: There must be a space after &quot;get&quot; type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { get: () =&gt; A; }</div><div class="line">// Message: There must be no space after &quot;get&quot; type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { get: &lt;X&gt;() =&gt; A; }</div><div class="line">// Message: There must be no space after &quot;get&quot; type annotation colon.</div><div class="line"></div><div class="line">type X = { get:  () =&gt; A; }</div><div class="line">// Message: There must be 1 space after &quot;get&quot; type annotation colon.</div><div class="line"></div><div class="line">type X = { get:  &lt;X&gt;() =&gt; A; }</div><div class="line">// Message: There must be 1 space after &quot;get&quot; type annotation colon.</div><div class="line"></div><div class="line">type X = { +foo:string }</div><div class="line">// Message: There must be a space after &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">type X = { +foo:  string }</div><div class="line">// Message: There must be 1 space after &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { +foo: string }</div><div class="line">// Message: There must be no space after &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">type X = { +foo?:string }</div><div class="line">// Message: There must be a space after &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">type X = { +foo?:  string }</div><div class="line">// Message: There must be 1 space after &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { +foo?: string }</div><div class="line">// Message: There must be no space after &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { [a:b]: c }</div><div class="line">// Message: There must be a space after type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { [a: b]:c }</div><div class="line">// Message: There must be no space after type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { [a:    b]: c }</div><div class="line">// Message: There must be 1 space after type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { +[a:b]: c }</div><div class="line">// Message: There must be a space after type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { +[a: b]:c }</div><div class="line">// Message: There must be no space after type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { +[a:    b]: c }</div><div class="line">// Message: There must be 1 space after type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { [a: b]:c }</div><div class="line">// Message: There must be a space after type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { [a:b]: c }</div><div class="line">// Message: There must be no space after type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { [a: b]:    c }</div><div class="line">// Message: There must be 1 space after type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { [a:b]:c }</div><div class="line">// Message: There must be a space after type annotation colon.</div><div class="line">// Message: There must be a space after type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { [a: b]: c }</div><div class="line">// Message: There must be no space after type annotation colon.</div><div class="line">// Message: There must be no space after type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { [a:  b]:  c }</div><div class="line">// Message: There must be 1 space after type annotation colon.</div><div class="line">// Message: There must be 1 space after type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { [a:(b)]:(c) }</div><div class="line">// Message: There must be a space after type annotation colon.</div><div class="line">// Message: There must be a space after type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { [a: (b)]: (c) }</div><div class="line">// Message: There must be no space after type annotation colon.</div><div class="line">// Message: There must be no space after type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">const x = ({}: {})</div><div class="line">// Message: There must be no space after type cast colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">const x = ({}:{})</div><div class="line">// Message: There must be a space after type cast colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">const x = ({}:  {})</div><div class="line">// Message: There must be 1 space after type cast colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">((x): (string))</div><div class="line">// Message: There must be no space after type cast colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">((x):(string))</div><div class="line">// Message: There must be a space after type cast colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">((x):  (string))</div><div class="line">// Message: There must be 1 space after type cast colon.</div></div><!-- fragment --><p>The following patterns are not considered problems:</p>
<div class="fragment"><div class="line">(foo) =&gt; {}</div><div class="line"></div><div class="line">(foo: string) =&gt; {}</div><div class="line"></div><div class="line">(foo: (string|number)) =&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">(foo:string) =&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">(foo: string) =&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">(foo:(() =&gt; void)) =&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">(foo: (() =&gt; void)) =&gt; {}</div><div class="line"></div><div class="line">({ lorem, ipsum, dolor }: SomeType) =&gt; {}</div><div class="line"></div><div class="line">(foo: { a: string, b: number }) =&gt; {}</div><div class="line"></div><div class="line">({ a, b }: ?{ a: string, b: number }) =&gt; {}</div><div class="line"></div><div class="line">([ a, b ]: string[]) =&gt; {}</div><div class="line"></div><div class="line">(i?: number) =&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">(i?:number) =&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;allowLineBreak&quot;:true}]</div><div class="line">(foo:</div><div class="line">  { a: string, b: number }) =&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;,{&quot;allowLineBreak&quot;:true}]</div><div class="line">(foo:</div><div class="line">  { a: string, b: number }) =&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">():Object =&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">(): Object =&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">():(number | string) =&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">(): (number | string) =&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">():number|string =&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">(): number|string =&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">():(() =&gt; void) =&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">(): (() =&gt; void) =&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">():( () =&gt; void ) =&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">(): ( () =&gt; void ) =&gt; {}</div><div class="line"></div><div class="line">(): { a: number, b: string } =&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">() :{ a:number, b:string } =&gt; {}</div><div class="line"></div><div class="line">function x(foo: string) {}</div><div class="line"></div><div class="line">class Foo { constructor(foo: string) {} }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">function x(foo:string) {}</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">class Foo { constructor(foo:string) {} }</div><div class="line"></div><div class="line">async function foo({ lorem, ipsum, dolor }: SomeType) {}</div><div class="line"></div><div class="line">function x({ a, b }: { a: string, b: number }) {}</div><div class="line"></div><div class="line">function x(i?: number) {}</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">function x(i?:number) {}</div><div class="line"></div><div class="line">function a(): x {}</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">function a():x {}</div><div class="line"></div><div class="line">function a(): (number | string) {}</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">function a() :(number | string) {}</div><div class="line"></div><div class="line">type X = (foo: number) =&gt; string;</div><div class="line"></div><div class="line">type X = (foo : number) =&gt; string;</div><div class="line"></div><div class="line">type X = (foo: ?number) =&gt; string;</div><div class="line"></div><div class="line">type X = (foo? : ?number) =&gt; string;</div><div class="line"></div><div class="line">type X = (foo: ?{ x: number }) =&gt; string;</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = (foo:number) =&gt; string;</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = (foo:?{ x:number }) =&gt; string;</div><div class="line"></div><div class="line">type X = (foo: (number)) =&gt; string</div><div class="line"></div><div class="line">type X = (foo: ((number))) =&gt; string</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = (foo:((number))) =&gt; string</div><div class="line"></div><div class="line">type X = ?(foo: ((number))) =&gt; string</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = ?(foo:((number))) =&gt; string</div><div class="line"></div><div class="line">type TArrayPredicate = (el: T, i?: number) =&gt; boolean</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type TArrayPredicate = (el:T, i?:number) =&gt; boolean</div><div class="line"></div><div class="line">type X = (number) =&gt; string;</div><div class="line"></div><div class="line">type X = (?number) =&gt; string;</div><div class="line"></div><div class="line">type X = number =&gt; string;</div><div class="line"></div><div class="line">type X = ?number =&gt; string;</div><div class="line"></div><div class="line">type X = ({ foo: bar }) =&gt; string;</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = (number) =&gt; string;</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = (?number) =&gt; string;</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = number =&gt; string;</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = ?number =&gt; string;</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = ({ foo: bar }) =&gt; string;</div><div class="line"></div><div class="line">class Foo { bar }</div><div class="line"></div><div class="line">class Foo { bar = 3 }</div><div class="line"></div><div class="line">class Foo { bar: string }</div><div class="line"></div><div class="line">class Foo { bar: ?string }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">class Foo { bar:string }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">class Foo { bar:?string }</div><div class="line"></div><div class="line">class X { static foo : number }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">class X { static foo :number }</div><div class="line"></div><div class="line">declare class X { static foo : number }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">declare class X { static foo :number }</div><div class="line"></div><div class="line">class X { +foo: string }</div><div class="line"></div><div class="line">class X { static +foo: string }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">class X { +foo:string }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">class X { static +foo:string }</div><div class="line"></div><div class="line">type X = { foo: string }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { foo:string }</div><div class="line"></div><div class="line">type X = { foo?: string }</div><div class="line"></div><div class="line">type X = { foo?: ?string }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { foo?:?string }</div><div class="line"></div><div class="line">type Foo = { barType: (string | () =&gt; void) }</div><div class="line"></div><div class="line">type Foo = { barType: ((string | () =&gt; void)) }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type Foo = { barType:(string | () =&gt; void) }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type Foo = { barType:((string | () =&gt; void)) }</div><div class="line"></div><div class="line">type X = { get(): A; }</div><div class="line"></div><div class="line">type X = { get&lt;X&gt;(): A; }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { get(): A; }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { get&lt;X&gt;(): A; }</div><div class="line"></div><div class="line">type X = { get: () =&gt; A; }</div><div class="line"></div><div class="line">type X = { get: &lt;X&gt;() =&gt; A; }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { get:() =&gt; A; }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { get:&lt;X&gt;() =&gt; A; }</div><div class="line"></div><div class="line">type X = { +foo: string }</div><div class="line"></div><div class="line">type X = { +foo?: string }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { +foo:string }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { +foo?:string }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { [a: b]: c }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { [a:b]:c }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { +[a: b]: c }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { +[a:b]:c }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { [string]: c }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { [string]:c }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">const x = ({}:{})</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">const x = ({}: {})</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">((x):(string))</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">((x): (string))</div></div><!-- fragment --><p><a class="anchor" id="eslint-plugin-flowtype-rules-space-before-generic-bracket"></a> </p><h3><code>space-before-generic-bracket</code></h3>
<p><em>The <code>--fix</code> option on the command line automatically fixes problems reported by this rule.</em></p>
<p>Enforces consistent spacing before the opening <code>&lt;</code> of generic type annotation parameters.</p>
<p>This rule takes one argument. If it is &lsquo;'never&rsquo;<code>then a problem is raised when there is a space before the</code>&lt;<code>. If it is</code>'always'<code>then a problem is raised when there is no space before the</code>&lt;`.</p>
<p>The default value is &lsquo;'never&rsquo;`.</p>
<p>The following patterns are considered problems:</p>
<div class="fragment"><div class="line">type X = Promise &lt;string&gt;</div><div class="line">// Message: There must be no space before &quot;Promise&quot; generic type annotation bracket</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = Promise &lt;string&gt;</div><div class="line">// Message: There must be no space before &quot;Promise&quot; generic type annotation bracket</div><div class="line"></div><div class="line">type X = Promise  &lt;string&gt;</div><div class="line">// Message: There must be no space before &quot;Promise&quot; generic type annotation bracket</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = Promise&lt;string&gt;</div><div class="line">// Message: There must be a space before &quot;Promise&quot; generic type annotation bracket</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = Promise  &lt;string&gt;</div><div class="line">// Message: There must be one space before &quot;Promise&quot; generic type annotation bracket</div></div><!-- fragment --><p>The following patterns are not considered problems:</p>
<div class="fragment"><div class="line">type X = Promise&lt;string&gt;</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = Promise &lt;string&gt;</div></div><!-- fragment --><p><a class="anchor" id="eslint-plugin-flowtype-rules-space-before-type-colon"></a> </p><h3><code>space-before-type-colon</code></h3>
<p><em>The <code>--fix</code> option on the command line automatically fixes problems reported by this rule.</em></p>
<p>Enforces consistent spacing before the type annotation colon.</p>
<p>This rule takes one argument. If it is &lsquo;'always&rsquo;<code>then a problem is raised when there is no space before the type annotation colon. If it is</code>'never'<code>then a problem is raised when there is a space before the type annotation colon. The default value is</code>'never'`.</p>
<p>The following patterns are considered problems:</p>
<div class="fragment"><div class="line">// Options: [&quot;never&quot;]</div><div class="line">(foo : string) =&gt; {}</div><div class="line">// Message: There must be no space before &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">(foo ? : string) =&gt; {}</div><div class="line">// Message: There must be no space before &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">(foo: string) =&gt; {}</div><div class="line">// Message: There must be a space before &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">(foo  : string) =&gt; {}</div><div class="line">// Message: There must be 1 space before &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">(foo?: string) =&gt; {}</div><div class="line">// Message: There must be a space before &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">(foo ?  : string) =&gt; {}</div><div class="line">// Message: There must be 1 space before &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">(foo  ?: string) =&gt; {}</div><div class="line">// Message: There must be a space before &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">({ lorem, ipsum, dolor } : SomeType) =&gt; {}</div><div class="line">// Message: There must be no space before &quot;{ lorem, ipsum, dolor }&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">(foo : { a: string, b: number }) =&gt; {}</div><div class="line">// Message: There must be no space before &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">({ a, b } : { a: string, b: number }) =&gt; {}</div><div class="line">// Message: There must be no space before &quot;{ a, b }&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">([ a, b ] : string[]) =&gt; {}</div><div class="line">// Message: There must be no space before &quot;[ a, b ]&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">() : x =&gt; {}</div><div class="line">// Message: There must be no space before return type colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">(): x =&gt; {}</div><div class="line">// Message: There must be a space before return type colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">()  : x =&gt; {}</div><div class="line">// Message: There must be 1 space before return type colon.</div><div class="line"></div><div class="line">function x(foo : string) {}</div><div class="line">// Message: There must be no space before &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">function x(foo: string) {}</div><div class="line">// Message: There must be a space before &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">var x = function (foo : string) {}</div><div class="line">// Message: There must be no space before &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">var x = function (foo: string) {}</div><div class="line">// Message: There must be a space before &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">class Foo { constructor(foo : string ) {} }</div><div class="line">// Message: There must be no space before &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">class Foo { constructor(foo: string ) {} }</div><div class="line">// Message: There must be a space before &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">async function foo({ lorem, ipsum, dolor } : SomeType) {}</div><div class="line">// Message: There must be no space before &quot;{ lorem, ipsum, dolor }&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">function a() : x {}</div><div class="line">// Message: There must be no space before return type colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">function a(): x {}</div><div class="line">// Message: There must be a space before return type colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">function a()  : x {}</div><div class="line">// Message: There must be 1 space before return type colon.</div><div class="line"></div><div class="line">type X = (foo :string) =&gt; string;</div><div class="line">// Message: There must be no space before &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = (foo:string) =&gt; string;</div><div class="line">// Message: There must be a space before &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = (foo  :string) =&gt; string;</div><div class="line">// Message: There must be 1 space before &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">type X = (foo? :string) =&gt; string;</div><div class="line">// Message: There must be no space before &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">type X = (foo?     :string) =&gt; string;</div><div class="line">// Message: There must be no space before &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = (foo?:string) =&gt; string;</div><div class="line">// Message: There must be a space before &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">type X = (foo? :?string) =&gt; string;</div><div class="line">// Message: There must be no space before &quot;foo&quot; parameter type annotation colon.</div><div class="line"></div><div class="line">class X { foo :string }</div><div class="line">// Message: There must be no space before &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">class X { foo: string }</div><div class="line">// Message: There must be a space before &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">class X { foo :?string }</div><div class="line">// Message: There must be no space before &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">class X { foo: ?string }</div><div class="line">// Message: There must be a space before &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">class X { static foo : number }</div><div class="line">// Message: There must be no space before &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">class X { static foo :number }</div><div class="line">// Message: There must be no space before &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">class X { static foo: number }</div><div class="line">// Message: There must be a space before &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">class X { static foo:number }</div><div class="line">// Message: There must be a space before &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">declare class Foo { static bar :number; }</div><div class="line">// Message: There must be no space before &quot;bar&quot; type annotation colon.</div><div class="line"></div><div class="line">declare class Foo { static bar : number; }</div><div class="line">// Message: There must be no space before &quot;bar&quot; type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">declare class Foo { static bar:number; }</div><div class="line">// Message: There must be a space before &quot;bar&quot; type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">declare class Foo { static bar: number; }</div><div class="line">// Message: There must be a space before &quot;bar&quot; type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">class X { +foo: string }</div><div class="line">// Message: There must be a space before &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">class X { +foo  : string }</div><div class="line">// Message: There must be 1 space before &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">class X { +foo : string }</div><div class="line">// Message: There must be no space before &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">class X { static +foo: string }</div><div class="line">// Message: There must be a space before &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">class X { static +foo  : string }</div><div class="line">// Message: There must be 1 space before &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">class X { static +foo : string }</div><div class="line">// Message: There must be no space before &quot;foo&quot; class property type annotation colon.</div><div class="line"></div><div class="line">type X = { foo : string }</div><div class="line">// Message: There must be no space before &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { foo : string }</div><div class="line">// Message: There must be no space before &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { foo: string }</div><div class="line">// Message: There must be a space before &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { foo  : string }</div><div class="line">// Message: There must be 1 space before &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">type X = { foo? : string }</div><div class="line">// Message: There must be no space before &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { foo?: string }</div><div class="line">// Message: There must be a space before &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { foo?  : string }</div><div class="line">// Message: There must be 1 space before &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { foo   ?: string }</div><div class="line">// Message: There must be a space before &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { +foo: string }</div><div class="line">// Message: There must be a space before &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { +foo  : string }</div><div class="line">// Message: There must be 1 space before &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { +foo : string }</div><div class="line">// Message: There must be no space before &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { +foo?: string }</div><div class="line">// Message: There must be a space before &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { +foo?  : string }</div><div class="line">// Message: There must be 1 space before &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { +foo? : string }</div><div class="line">// Message: There must be no space before &quot;foo&quot; type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { [a: b] : c }</div><div class="line">// Message: There must be a space before type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { [a : b]: c }</div><div class="line">// Message: There must be no space before type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { [a  : b] : c }</div><div class="line">// Message: There must be 1 space before type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { +[a:b] : c }</div><div class="line">// Message: There must be a space before type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { +[a : b]: c }</div><div class="line">// Message: There must be no space before type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { +[a  : b] : c }</div><div class="line">// Message: There must be 1 space before type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { [a : b]: c }</div><div class="line">// Message: There must be a space before type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { [a: b] : c }</div><div class="line">// Message: There must be no space before type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { [a : b]  : c }</div><div class="line">// Message: There must be 1 space before type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { [a:b]:c }</div><div class="line">// Message: There must be a space before type annotation colon.</div><div class="line">// Message: There must be a space before type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { [a : b] : c }</div><div class="line">// Message: There must be no space before type annotation colon.</div><div class="line">// Message: There must be no space before type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { [a  : b]  : c }</div><div class="line">// Message: There must be 1 space before type annotation colon.</div><div class="line">// Message: There must be 1 space before type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { [a:(b)]:(c) }</div><div class="line">// Message: There must be a space before type annotation colon.</div><div class="line">// Message: There must be a space before type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { [a : (b)] : (c) }</div><div class="line">// Message: There must be no space before type annotation colon.</div><div class="line">// Message: There must be no space before type annotation colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">const x = ({} :{})</div><div class="line">// Message: There must be no space before type cast colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">const x = ({}:{})</div><div class="line">// Message: There must be a space before type cast colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">const x = ({}  :{})</div><div class="line">// Message: There must be 1 space before type cast colon.</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">((x) : string)</div><div class="line">// Message: There must be no space before type cast colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">((x): string)</div><div class="line">// Message: There must be a space before type cast colon.</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">((x)  : string)</div><div class="line">// Message: There must be 1 space before type cast colon.</div></div><!-- fragment --><p>The following patterns are not considered problems:</p>
<div class="fragment"><div class="line">(foo) =&gt; {}</div><div class="line"></div><div class="line">(foo: string) =&gt; {}</div><div class="line"></div><div class="line">(foo?: string) =&gt; {}</div><div class="line"></div><div class="line">(foo ?: string) =&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">(foo: string) =&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">(foo : string) =&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">(foo? : string) =&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">(foo ? : string) =&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">(foo  ? : string) =&gt; {}</div><div class="line"></div><div class="line">({ lorem, ipsum, dolor }: SomeType) =&gt; {}</div><div class="line"></div><div class="line">(foo: { a: string, b: number }) =&gt; {}</div><div class="line"></div><div class="line">({ a, b }: ?{ a: string, b: number }) =&gt; {}</div><div class="line"></div><div class="line">(): { a: number, b: string } =&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">() : { a : number, b : string } =&gt; {}</div><div class="line"></div><div class="line">([ a, b ]: string[]) =&gt; {}</div><div class="line"></div><div class="line">(): x =&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">() : x =&gt; {}</div><div class="line"></div><div class="line">(): (number | string) =&gt; {}</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">() : (number | string) =&gt; {}</div><div class="line"></div><div class="line">function x(foo: string) {}</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">function x(foo : string) {}</div><div class="line"></div><div class="line">var x = function (foo: string) {}</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">var x = function (foo : string) {}</div><div class="line"></div><div class="line">class X { foo({ bar }: Props = this.props) {} }</div><div class="line"></div><div class="line">class Foo { constructor(foo: string ) {} }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">class Foo { constructor(foo : string ) {} }</div><div class="line"></div><div class="line">async function foo({ lorem, ipsum, dolor }: SomeType) {}</div><div class="line"></div><div class="line">function x({ a, b }: { a: string, b: number }) {}</div><div class="line"></div><div class="line">function a(): x {}</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">function a() : x {}</div><div class="line"></div><div class="line">function a(): (number | string) {}</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">function a() : (number | string) {}</div><div class="line"></div><div class="line">type X = (foo:string) =&gt; number;</div><div class="line"></div><div class="line">type X = (foo: string) =&gt; number;</div><div class="line"></div><div class="line">type X = (foo: ?string) =&gt; number;</div><div class="line"></div><div class="line">type X = (foo?: string) =&gt; number;</div><div class="line"></div><div class="line">type X = (foo?: ?string) =&gt; number;</div><div class="line"></div><div class="line">type X = (foo   ?: string) =&gt; number;</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = (foo? : string) =&gt; number</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = (foo? : ?string) =&gt; number</div><div class="line"></div><div class="line">type X = (number) =&gt; string;</div><div class="line"></div><div class="line">type X = (?number) =&gt; string;</div><div class="line"></div><div class="line">type X = number =&gt; string;</div><div class="line"></div><div class="line">type X = ?number =&gt; string;</div><div class="line"></div><div class="line">type X = ({ foo: bar }) =&gt; string;</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = (number) =&gt; string;</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = (?number) =&gt; string;</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = number =&gt; string;</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = ?number =&gt; string;</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = ({ foo : bar }) =&gt; string;</div><div class="line"></div><div class="line">class Foo { bar }</div><div class="line"></div><div class="line">class Foo { bar = 3 }</div><div class="line"></div><div class="line">class Foo { bar: string }</div><div class="line"></div><div class="line">class Foo { bar: ?string }</div><div class="line"></div><div class="line">class Foo { bar:?string }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">class Foo { bar : string }</div><div class="line"></div><div class="line">class X { static foo:number }</div><div class="line"></div><div class="line">class X { static foo: number }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">class X { static foo :number }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">class X { static foo : number }</div><div class="line"></div><div class="line">declare class Foo { static bar:number; }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">declare class Foo { static bar :number; }</div><div class="line"></div><div class="line">declare class Foo { static bar: number; }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">declare class Foo { static bar : number; }</div><div class="line"></div><div class="line">class X { +foo: string }</div><div class="line"></div><div class="line">class X { static +foo: string }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">class X { +foo : string }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">class X { static +foo : string }</div><div class="line"></div><div class="line">type X = { foo: string }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { foo : string }</div><div class="line"></div><div class="line">type X = { foo?: string }</div><div class="line"></div><div class="line">type X = { foo   ?: string }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { foo? : string }</div><div class="line"></div><div class="line">type X = { +foo: string }</div><div class="line"></div><div class="line">type X = { +foo?: string }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { +foo : string }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { +foo? : string }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { [a : b] : c }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { [a:b]:c }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { [string] : c }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { [string]:c }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { +[a : b] : c }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { +[a:b]:c }</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = { [a : (b)] : (c) }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = { [a:(b)]:(c) }</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">const x = ({}:{})</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">const x = ({} :{})</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">((x): string)</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">((x) : string)</div></div><!-- fragment --><p><a class="anchor" id="eslint-plugin-flowtype-rules-type-id-match"></a> </p><h3><code>type-id-match</code></h3>
<p>Enforces a consistent naming pattern for type aliases.</p>
<p><a class="anchor" id="eslint-plugin-flowtype-rules-type-id-match-options"></a> </p><h4>Options</h4>
<p>This rule needs a text RegExp to operate with Its signature is as follows:</p>
<div class="fragment"><div class="line">{</div><div class="line">    &quot;rules&quot;: {</div><div class="line">        &quot;flowtype/type-id-match&quot;: [</div><div class="line">            2,</div><div class="line">            &quot;^([A-Z][a-z0-9]*)+Type$&quot;</div><div class="line">        ]</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>&lsquo;&rsquo;^([A-Z][a-z0-9]*)+Type$'` is the default pattern.</p>
<p>The following patterns are considered problems:</p>
<div class="fragment"><div class="line">type foo = {};</div><div class="line">// Message: Type identifier &#39;foo&#39; does not match pattern &#39;/^([A-Z][a-z0-9]*)+Type$/&#39;.</div><div class="line"></div><div class="line">// Options: [&quot;^foo$&quot;]</div><div class="line">type FooType = {};</div><div class="line">// Message: Type identifier &#39;FooType&#39; does not match pattern &#39;/^foo$/&#39;.</div></div><!-- fragment --><p>The following patterns are not considered problems:</p>
<div class="fragment"><div class="line">type FooType = {};</div><div class="line"></div><div class="line">// Options: [&quot;^foo$&quot;]</div><div class="line">type foo = {};</div><div class="line"></div><div class="line">type foo = {};</div></div><!-- fragment --><p><a class="anchor" id="eslint-plugin-flowtype-rules-union-intersection-spacing"></a> </p><h3><code>union-intersection-spacing</code></h3>
<p><em>The <code>--fix</code> option on the command line automatically fixes problems reported by this rule.</em></p>
<p>Enforces consistent spacing around union and intersection type separators (<code>|</code> and <code>&amp;</code>).</p>
<p>This rule takes one argument. If it is &lsquo;'always&rsquo;<code>then a problem is raised when there is no space around the separator. If it is</code>'never'` then a problem is raised when there is a space around the separator.</p>
<p>The default value is &lsquo;'always&rsquo;`.</p>
<p>The following patterns are considered problems:</p>
<div class="fragment"><div class="line">type X = string| number;</div><div class="line">// Message: There must be a space before union type annotation separator</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = string| number;</div><div class="line">// Message: There must be a space before union type annotation separator</div><div class="line"></div><div class="line">type X = string |number;</div><div class="line">// Message: There must be a space after union type annotation separator</div><div class="line"></div><div class="line">type X = string|number;</div><div class="line">// Message: There must be a space before union type annotation separator</div><div class="line">// Message: There must be a space after union type annotation separator</div><div class="line"></div><div class="line">type X = {x: string}|{y: number};</div><div class="line">// Message: There must be a space before union type annotation separator</div><div class="line">// Message: There must be a space after union type annotation separator</div><div class="line"></div><div class="line">type X = string | number |boolean;</div><div class="line">// Message: There must be a space after union type annotation separator</div><div class="line"></div><div class="line">type X = string|number|boolean;</div><div class="line">// Message: There must be a space before union type annotation separator</div><div class="line">// Message: There must be a space after union type annotation separator</div><div class="line">// Message: There must be a space before union type annotation separator</div><div class="line">// Message: There must be a space after union type annotation separator</div><div class="line"></div><div class="line">type X = (string)| number;</div><div class="line">// Message: There must be a space before union type annotation separator</div><div class="line"></div><div class="line">type X = ((string))|(number | foo);</div><div class="line">// Message: There must be a space before union type annotation separator</div><div class="line">// Message: There must be a space after union type annotation separator</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = string |number;</div><div class="line">// Message: There must be no space before union type annotation separator</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = string| number;</div><div class="line">// Message: There must be no space after union type annotation separator</div><div class="line"></div><div class="line">type X = string&amp; number;</div><div class="line">// Message: There must be a space before intersection type annotation separator</div><div class="line"></div><div class="line">// Options: [&quot;always&quot;]</div><div class="line">type X = string&amp; number;</div><div class="line">// Message: There must be a space before intersection type annotation separator</div><div class="line"></div><div class="line">type X = string &amp;number;</div><div class="line">// Message: There must be a space after intersection type annotation separator</div><div class="line"></div><div class="line">type X = {x: string}&amp;{y: number};</div><div class="line">// Message: There must be a space before intersection type annotation separator</div><div class="line">// Message: There must be a space after intersection type annotation separator</div><div class="line"></div><div class="line">type X = string&amp;number;</div><div class="line">// Message: There must be a space before intersection type annotation separator</div><div class="line">// Message: There must be a space after intersection type annotation separator</div><div class="line"></div><div class="line">type X = string &amp; number &amp;boolean;</div><div class="line">// Message: There must be a space after intersection type annotation separator</div><div class="line"></div><div class="line">type X = string&amp;number&amp;boolean;</div><div class="line">// Message: There must be a space before intersection type annotation separator</div><div class="line">// Message: There must be a space after intersection type annotation separator</div><div class="line">// Message: There must be a space before intersection type annotation separator</div><div class="line">// Message: There must be a space after intersection type annotation separator</div><div class="line"></div><div class="line">type X = (string)&amp; number;</div><div class="line">// Message: There must be a space before intersection type annotation separator</div><div class="line"></div><div class="line">type X = ((string))&amp;(number &amp; foo);</div><div class="line">// Message: There must be a space before intersection type annotation separator</div><div class="line">// Message: There must be a space after intersection type annotation separator</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = string &amp;number;</div><div class="line">// Message: There must be no space before intersection type annotation separator</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = string&amp; number;</div><div class="line">// Message: There must be no space after intersection type annotation separator</div></div><!-- fragment --><p>The following patterns are not considered problems:</p>
<div class="fragment"><div class="line">type X = string | number;</div><div class="line"></div><div class="line">type X = string | number | boolean;</div><div class="line"></div><div class="line">type X = (string) | number;</div><div class="line"></div><div class="line">type X = ((string)) | (number | foo);</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = string|number</div><div class="line"></div><div class="line">type X =</div><div class="line">| string</div><div class="line">| number</div><div class="line"></div><div class="line">function x() {</div><div class="line">type X =</div><div class="line">| string</div><div class="line">| number</div><div class="line">}</div><div class="line"></div><div class="line">type X = string| number;</div><div class="line"></div><div class="line">type X = string &amp; number;</div><div class="line"></div><div class="line">type X = string &amp; number &amp; boolean;</div><div class="line"></div><div class="line">type X = (string) &amp; number;</div><div class="line"></div><div class="line">type X = ((string)) &amp; (number &amp; foo);</div><div class="line"></div><div class="line">// Options: [&quot;never&quot;]</div><div class="line">type X = string&amp;number</div><div class="line"></div><div class="line">type X =</div><div class="line">&amp; string</div><div class="line">&amp; number</div><div class="line"></div><div class="line">function x() {</div><div class="line">type X =</div><div class="line">&amp; string</div><div class="line">&amp; number</div><div class="line">}</div><div class="line"></div><div class="line">type X = string&amp; number;</div></div><!-- fragment --><p><a class="anchor" id="eslint-plugin-flowtype-rules-use-flow-type"></a> </p><h3><code>use-flow-type</code></h3>
<p>Marks Flow <a href="https://flowtype.org/docs/type-aliases.html">type alias</a> declarations as used.</p>
<p>Used to suppress <a href="http://eslint.org/docs/rules/no-unused-vars"><code>no-unused-vars</code></a> errors that are triggered by type aliases.</p>
<p>The following patterns are not considered problems:</p>
<div class="fragment"><div class="line">declare class A {}</div><div class="line">// Additional rules: {&quot;no-unused-vars&quot;:1}</div><div class="line"></div><div class="line">declare function A(): Y</div><div class="line">// Additional rules: {&quot;no-unused-vars&quot;:1}</div><div class="line"></div><div class="line">declare module A {}</div><div class="line">// Additional rules: {&quot;no-unused-vars&quot;:1}</div><div class="line"></div><div class="line">declare module A { declare var a: Y }</div><div class="line">// Additional rules: {&quot;no-unused-vars&quot;:1}</div><div class="line"></div><div class="line">declare var A: Y</div><div class="line">// Additional rules: {&quot;no-unused-vars&quot;:1}</div><div class="line"></div><div class="line">import type A from &quot;a&quot;; (function&lt;T: A&gt;(): T {})</div><div class="line">// Additional rules: {&quot;no-unused-vars&quot;:1}</div><div class="line"></div><div class="line">(function&lt;T: A&gt;(): T {}); import type A from &quot;a&quot;</div><div class="line">// Additional rules: {&quot;no-unused-vars&quot;:1}</div><div class="line"></div><div class="line">import type {A} from &quot;a&quot;; (function&lt;T: A&gt;(): T {})</div><div class="line">// Additional rules: {&quot;no-unused-vars&quot;:1}</div><div class="line"></div><div class="line">(function&lt;T: A&gt;(): T {}); import type {A} from &quot;a&quot;</div><div class="line">// Additional rules: {&quot;no-unused-vars&quot;:1}</div><div class="line"></div><div class="line">(function&lt;T: A&gt;(): T {}); import type {a as A} from &quot;a&quot;</div><div class="line">// Additional rules: {&quot;no-unused-vars&quot;:1}</div><div class="line"></div><div class="line">type A = {}; function x&lt;Y: A&gt;(i: Y) { i }; x()</div><div class="line">// Additional rules: {&quot;no-unused-vars&quot;:1}</div><div class="line"></div><div class="line">function x&lt;Y: A&gt;(i: Y) { i }; type A = {}; x()</div><div class="line">// Additional rules: {&quot;no-unused-vars&quot;:1}</div><div class="line"></div><div class="line">type A = {}; function x&lt;Y: A.B.C&gt;(i: Y) { i }; x()</div><div class="line">// Additional rules: {&quot;no-unused-vars&quot;:1}</div><div class="line"></div><div class="line">function x&lt;Y: A.B.C&gt;(i: Y) { i }; type A = {}; x()</div><div class="line">// Additional rules: {&quot;no-unused-vars&quot;:1}</div></div><!-- fragment --><p><a class="anchor" id="eslint-plugin-flowtype-rules-valid-syntax"></a> </p><h3><code>valid-syntax</code></h3>
<p><b>Deprecated</b> Babylon (the Babel parser) v6.10.0 fixes parsing of the invalid syntax this plugin warned against.</p>
<p>Checks for simple Flow syntax errors. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者 &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
