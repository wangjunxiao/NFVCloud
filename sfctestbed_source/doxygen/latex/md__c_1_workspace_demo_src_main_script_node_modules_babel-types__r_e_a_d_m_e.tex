\begin{quote}
This module contains methods for building A\+S\+Ts manually and for checking the types of A\+ST nodes. \end{quote}


\subsection*{Install}


\begin{DoxyCode}
npm install --save-dev babel-types
\end{DoxyCode}


\subsection*{A\+PI}

\#\#\# any\+Type\+Annotation 
\begin{DoxyCode}
t.anyTypeAnnotation()
\end{DoxyCode}


See also {\ttfamily t.\+is\+Any\+Type\+Annotation(node, opts)} and {\ttfamily t.\+assert\+Any\+Type\+Annotation(node, opts)}.

Aliases\+: {\ttfamily Flow}, {\ttfamily Flow\+Base\+Annotation}





\#\#\# array\+Expression 
\begin{DoxyCode}
t.arrayExpression(elements)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Array\+Expression(node, opts)} and {\ttfamily t.\+assert\+Array\+Expression(node, opts)}.

Aliases\+: {\ttfamily Expression}


\begin{DoxyItemize}
\item {\ttfamily elements}\+: {\ttfamily Array$<$null $\vert$ Expression $\vert$ Spread\+Element$>$} (default\+: {\ttfamily \mbox{[}\mbox{]}}) 


\end{DoxyItemize}

\#\#\# array\+Pattern 
\begin{DoxyCode}
t.arrayPattern(elements, typeAnnotation)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Array\+Pattern(node, opts)} and {\ttfamily t.\+assert\+Array\+Pattern(node, opts)}.

Aliases\+: {\ttfamily Pattern}, {\ttfamily L\+Val}


\begin{DoxyItemize}
\item {\ttfamily elements}\+: {\ttfamily Array$<$Identifier $\vert$ Pattern $\vert$ Rest\+Element$>$} (required)
\item {\ttfamily type\+Annotation} (required)
\item {\ttfamily decorators}\+: {\ttfamily Array$<$Decorator$>$} (default\+: {\ttfamily null}) 


\end{DoxyItemize}

\#\#\# array\+Type\+Annotation 
\begin{DoxyCode}
t.arrayTypeAnnotation(elementType)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Array\+Type\+Annotation(node, opts)} and {\ttfamily t.\+assert\+Array\+Type\+Annotation(node, opts)}.

Aliases\+: {\ttfamily Flow}


\begin{DoxyItemize}
\item {\ttfamily element\+Type} (required) 


\end{DoxyItemize}

\#\#\# arrow\+Function\+Expression 
\begin{DoxyCode}
t.arrowFunctionExpression(params, body, async)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Arrow\+Function\+Expression(node, opts)} and {\ttfamily t.\+assert\+Arrow\+Function\+Expression(node, opts)}.

Aliases\+: {\ttfamily Scopable}, {\ttfamily Function}, {\ttfamily Block\+Parent}, {\ttfamily Function\+Parent}, {\ttfamily Expression}, {\ttfamily Pureish}


\begin{DoxyItemize}
\item {\ttfamily params}\+: {\ttfamily Array$<$L\+Val$>$} (required)
\item {\ttfamily body}\+: {\ttfamily Block\+Statement $\vert$ Expression} (required)
\item {\ttfamily async}\+: {\ttfamily boolean} (default\+: {\ttfamily false})
\item {\ttfamily return\+Type} (default\+: {\ttfamily null})
\item {\ttfamily type\+Parameters} (default\+: {\ttfamily null}) 


\end{DoxyItemize}

\#\#\# assignment\+Expression 
\begin{DoxyCode}
t.assignmentExpression(operator, left, right)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Assignment\+Expression(node, opts)} and {\ttfamily t.\+assert\+Assignment\+Expression(node, opts)}.

Aliases\+: {\ttfamily Expression}


\begin{DoxyItemize}
\item {\ttfamily operator}\+: {\ttfamily string} (required)
\item {\ttfamily left}\+: {\ttfamily L\+Val} (required)
\item {\ttfamily right}\+: {\ttfamily Expression} (required) 


\end{DoxyItemize}

\#\#\# assignment\+Pattern 
\begin{DoxyCode}
t.assignmentPattern(left, right)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Assignment\+Pattern(node, opts)} and {\ttfamily t.\+assert\+Assignment\+Pattern(node, opts)}.

Aliases\+: {\ttfamily Pattern}, {\ttfamily L\+Val}


\begin{DoxyItemize}
\item {\ttfamily left}\+: {\ttfamily Identifier} (required)
\item {\ttfamily right}\+: {\ttfamily Expression} (required)
\item {\ttfamily decorators}\+: {\ttfamily Array$<$Decorator$>$} (default\+: {\ttfamily null}) 


\end{DoxyItemize}

\#\#\# await\+Expression 
\begin{DoxyCode}
t.awaitExpression(argument)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Await\+Expression(node, opts)} and {\ttfamily t.\+assert\+Await\+Expression(node, opts)}.

Aliases\+: {\ttfamily Expression}, {\ttfamily Terminatorless}


\begin{DoxyItemize}
\item {\ttfamily argument}\+: {\ttfamily Expression} (required) 


\end{DoxyItemize}

\#\#\# binary\+Expression 
\begin{DoxyCode}
t.binaryExpression(operator, left, right)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Binary\+Expression(node, opts)} and {\ttfamily t.\+assert\+Binary\+Expression(node, opts)}.

Aliases\+: {\ttfamily Binary}, {\ttfamily Expression}


\begin{DoxyItemize}
\item {\ttfamily operator}\+: `'+\textquotesingle{} $\vert$ \textquotesingle{}-\/\textquotesingle{} $\vert$ \textquotesingle{}/\textquotesingle{} $\vert$ \textquotesingle{}\textquotesingle{} $\vert$ \textquotesingle{}$\ast$\textquotesingle{} $\vert$ \textquotesingle{}$\ast$$\ast$\textquotesingle{} $\vert$ \textquotesingle{}\&\textquotesingle{} $\vert$ \textquotesingle{}$\vert$\textquotesingle{} $\vert$ \textquotesingle{}$>$$>$\textquotesingle{} $\vert$ \textquotesingle{}$>$$>$$>$\textquotesingle{} $\vert$ \textquotesingle{}$<$$<$\textquotesingle{} $\vert$ \textquotesingle{}$^\wedge$\textquotesingle{} $\vert$ \textquotesingle{}==\textquotesingle{} $\vert$ \textquotesingle{}===\textquotesingle{} $\vert$ \textquotesingle{}!=\textquotesingle{} $\vert$ \textquotesingle{}!==\textquotesingle{} $\vert$ \textquotesingle{}in\textquotesingle{} $\vert$ \textquotesingle{}instanceof\textquotesingle{} $\vert$ \textquotesingle{}$>$\textquotesingle{} $\vert$ \textquotesingle{}$<$\textquotesingle{} $\vert$ \textquotesingle{}$>$=\textquotesingle{} $\vert$ \textquotesingle{}$<$=\textquotesingle{}{\ttfamily (required) -\/}left{\ttfamily \+:}Expression$<$tt$>$(required) -\/right{\ttfamily \+:}Expression\`{} (required) 


\end{DoxyItemize}

\#\#\# bind\+Expression 
\begin{DoxyCode}
t.bindExpression(object, callee)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Bind\+Expression(node, opts)} and {\ttfamily t.\+assert\+Bind\+Expression(node, opts)}.

Aliases\+: {\ttfamily Expression}


\begin{DoxyItemize}
\item {\ttfamily object} (required)
\item {\ttfamily callee} (required) 


\end{DoxyItemize}

\#\#\# block\+Statement 
\begin{DoxyCode}
t.blockStatement(body, directives)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Block\+Statement(node, opts)} and {\ttfamily t.\+assert\+Block\+Statement(node, opts)}.

Aliases\+: {\ttfamily Scopable}, {\ttfamily Block\+Parent}, {\ttfamily Block}, {\ttfamily Statement}


\begin{DoxyItemize}
\item {\ttfamily body}\+: {\ttfamily Array$<$Statement$>$} (required)
\item {\ttfamily directives}\+: {\ttfamily Array$<$Directive$>$} (default\+: {\ttfamily \mbox{[}\mbox{]}}) 


\end{DoxyItemize}

\#\#\# boolean\+Literal 
\begin{DoxyCode}
t.booleanLiteral(value)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Boolean\+Literal(node, opts)} and {\ttfamily t.\+assert\+Boolean\+Literal(node, opts)}.

Aliases\+: {\ttfamily Expression}, {\ttfamily Pureish}, {\ttfamily Literal}, {\ttfamily Immutable}


\begin{DoxyItemize}
\item {\ttfamily value}\+: {\ttfamily boolean} (required) 


\end{DoxyItemize}

\#\#\# boolean\+Literal\+Type\+Annotation 
\begin{DoxyCode}
t.booleanLiteralTypeAnnotation()
\end{DoxyCode}


See also {\ttfamily t.\+is\+Boolean\+Literal\+Type\+Annotation(node, opts)} and {\ttfamily t.\+assert\+Boolean\+Literal\+Type\+Annotation(node, opts)}.

Aliases\+: {\ttfamily Flow}





\#\#\# boolean\+Type\+Annotation 
\begin{DoxyCode}
t.booleanTypeAnnotation()
\end{DoxyCode}


See also {\ttfamily t.\+is\+Boolean\+Type\+Annotation(node, opts)} and {\ttfamily t.\+assert\+Boolean\+Type\+Annotation(node, opts)}.

Aliases\+: {\ttfamily Flow}, {\ttfamily Flow\+Base\+Annotation}





\#\#\# break\+Statement 
\begin{DoxyCode}
t.breakStatement(label)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Break\+Statement(node, opts)} and {\ttfamily t.\+assert\+Break\+Statement(node, opts)}.

Aliases\+: {\ttfamily Statement}, {\ttfamily Terminatorless}, {\ttfamily Completion\+Statement}


\begin{DoxyItemize}
\item {\ttfamily label}\+: {\ttfamily Identifier} (default\+: {\ttfamily null}) 


\end{DoxyItemize}

\#\#\# call\+Expression 
\begin{DoxyCode}
t.callExpression(callee, arguments)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Call\+Expression(node, opts)} and {\ttfamily t.\+assert\+Call\+Expression(node, opts)}.

Aliases\+: {\ttfamily Expression}


\begin{DoxyItemize}
\item {\ttfamily callee}\+: {\ttfamily Expression} (required)
\item {\ttfamily arguments}\+: {\ttfamily Array$<$Expression $\vert$ Spread\+Element$>$} (required) 


\end{DoxyItemize}

\#\#\# catch\+Clause 
\begin{DoxyCode}
t.catchClause(param, body)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Catch\+Clause(node, opts)} and {\ttfamily t.\+assert\+Catch\+Clause(node, opts)}.

Aliases\+: {\ttfamily Scopable}


\begin{DoxyItemize}
\item {\ttfamily param}\+: {\ttfamily Identifier} (required)
\item {\ttfamily body}\+: {\ttfamily Block\+Statement} (required) 


\end{DoxyItemize}

\#\#\# class\+Body 
\begin{DoxyCode}
t.classBody(body)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Class\+Body(node, opts)} and {\ttfamily t.\+assert\+Class\+Body(node, opts)}.


\begin{DoxyItemize}
\item {\ttfamily body}\+: {\ttfamily Array$<$Class\+Method $\vert$ Class\+Property$>$} (required) 


\end{DoxyItemize}

\#\#\# class\+Declaration 
\begin{DoxyCode}
t.classDeclaration(id, superClass, body, decorators)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Class\+Declaration(node, opts)} and {\ttfamily t.\+assert\+Class\+Declaration(node, opts)}.

Aliases\+: {\ttfamily Scopable}, {\ttfamily Class}, {\ttfamily Statement}, {\ttfamily Declaration}, {\ttfamily Pureish}


\begin{DoxyItemize}
\item {\ttfamily id}\+: {\ttfamily Identifier} (required)
\item {\ttfamily super\+Class}\+: {\ttfamily Expression} (default\+: {\ttfamily null})
\item {\ttfamily body}\+: {\ttfamily Class\+Body} (required)
\item {\ttfamily decorators}\+: {\ttfamily Array$<$Decorator$>$} (required)
\item {\ttfamily implements} (default\+: {\ttfamily null})
\item {\ttfamily mixins} (default\+: {\ttfamily null})
\item {\ttfamily super\+Type\+Parameters} (default\+: {\ttfamily null})
\item {\ttfamily type\+Parameters} (default\+: {\ttfamily null}) 


\end{DoxyItemize}

\#\#\# class\+Expression 
\begin{DoxyCode}
t.classExpression(id, superClass, body, decorators)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Class\+Expression(node, opts)} and {\ttfamily t.\+assert\+Class\+Expression(node, opts)}.

Aliases\+: {\ttfamily Scopable}, {\ttfamily Class}, {\ttfamily Expression}, {\ttfamily Pureish}


\begin{DoxyItemize}
\item {\ttfamily id}\+: {\ttfamily Identifier} (default\+: {\ttfamily null})
\item {\ttfamily super\+Class}\+: {\ttfamily Expression} (default\+: {\ttfamily null})
\item {\ttfamily body}\+: {\ttfamily Class\+Body} (required)
\item {\ttfamily decorators}\+: {\ttfamily Array$<$Decorator$>$} (required)
\item {\ttfamily implements} (default\+: {\ttfamily null})
\item {\ttfamily mixins} (default\+: {\ttfamily null})
\item {\ttfamily super\+Type\+Parameters} (default\+: {\ttfamily null})
\item {\ttfamily type\+Parameters} (default\+: {\ttfamily null}) 


\end{DoxyItemize}

\#\#\# class\+Implements 
\begin{DoxyCode}
t.classImplements(id, typeParameters)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Class\+Implements(node, opts)} and {\ttfamily t.\+assert\+Class\+Implements(node, opts)}.

Aliases\+: {\ttfamily Flow}


\begin{DoxyItemize}
\item {\ttfamily id} (required)
\item {\ttfamily type\+Parameters} (required) 


\end{DoxyItemize}

\#\#\# class\+Method 
\begin{DoxyCode}
t.classMethod(kind, key, params, body, computed, static)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Class\+Method(node, opts)} and {\ttfamily t.\+assert\+Class\+Method(node, opts)}.

Aliases\+: {\ttfamily Function}, {\ttfamily Scopable}, {\ttfamily Block\+Parent}, {\ttfamily Function\+Parent}, {\ttfamily Method}


\begin{DoxyItemize}
\item {\ttfamily kind}\+: {\ttfamily \char`\"{}get\char`\"{} $\vert$ \char`\"{}set\char`\"{} $\vert$ \char`\"{}method\char`\"{} $\vert$ \char`\"{}constructor\char`\"{}} (default\+: `\textquotesingle{}method'{\ttfamily ) -\/}key{\ttfamily if computed then}Expression{\ttfamily else}Identifier $\vert$ Literal$<$tt$>$(required) -\/params{\ttfamily \+:}Array$<$\+L\+Val$>${\ttfamily (required) -\/}body{\ttfamily \+:}Block\+Statement$<$tt$>$(required) -\/computed{\ttfamily \+:}boolean{\ttfamily (default\+:}false{\ttfamily ) -\/}static{\ttfamily \+:}boolean{\ttfamily (default\+:}false{\ttfamily ) -\/}async{\ttfamily \+:}boolean{\ttfamily (default\+:}false{\ttfamily ) -\/}decorators{\ttfamily (default\+:}null{\ttfamily ) -\/}generator{\ttfamily \+:}boolean{\ttfamily (default\+:}false{\ttfamily ) -\/}return\+Type{\ttfamily (default\+:}null{\ttfamily ) -\/}type\+Parameters{\ttfamily (default\+:}null\`{}) 


\end{DoxyItemize}

\#\#\# class\+Property 
\begin{DoxyCode}
t.classProperty(key, value, typeAnnotation, decorators, computed)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Class\+Property(node, opts)} and {\ttfamily t.\+assert\+Class\+Property(node, opts)}.

Aliases\+: {\ttfamily Property}


\begin{DoxyItemize}
\item {\ttfamily key} (required)
\item {\ttfamily value} (required)
\item {\ttfamily type\+Annotation} (required)
\item {\ttfamily decorators} (required)
\item {\ttfamily computed}\+: {\ttfamily boolean} (default\+: {\ttfamily false}) 


\end{DoxyItemize}

\#\#\# conditional\+Expression 
\begin{DoxyCode}
t.conditionalExpression(test, consequent, alternate)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Conditional\+Expression(node, opts)} and {\ttfamily t.\+assert\+Conditional\+Expression(node, opts)}.

Aliases\+: {\ttfamily Expression}, {\ttfamily Conditional}


\begin{DoxyItemize}
\item {\ttfamily test}\+: {\ttfamily Expression} (required)
\item {\ttfamily consequent}\+: {\ttfamily Expression} (required)
\item {\ttfamily alternate}\+: {\ttfamily Expression} (required) 


\end{DoxyItemize}

\#\#\# continue\+Statement 
\begin{DoxyCode}
t.continueStatement(label)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Continue\+Statement(node, opts)} and {\ttfamily t.\+assert\+Continue\+Statement(node, opts)}.

Aliases\+: {\ttfamily Statement}, {\ttfamily Terminatorless}, {\ttfamily Completion\+Statement}


\begin{DoxyItemize}
\item {\ttfamily label}\+: {\ttfamily Identifier} (default\+: {\ttfamily null}) 


\end{DoxyItemize}

\#\#\# debugger\+Statement 
\begin{DoxyCode}
t.debuggerStatement()
\end{DoxyCode}


See also {\ttfamily t.\+is\+Debugger\+Statement(node, opts)} and {\ttfamily t.\+assert\+Debugger\+Statement(node, opts)}.

Aliases\+: {\ttfamily Statement}





\#\#\# declare\+Class 
\begin{DoxyCode}
t.declareClass(id, typeParameters, extends, body)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Declare\+Class(node, opts)} and {\ttfamily t.\+assert\+Declare\+Class(node, opts)}.

Aliases\+: {\ttfamily Flow}, {\ttfamily Flow\+Declaration}, {\ttfamily Statement}, {\ttfamily Declaration}


\begin{DoxyItemize}
\item {\ttfamily id} (required)
\item {\ttfamily type\+Parameters} (required)
\item {\ttfamily extends} (required)
\item {\ttfamily body} (required) 


\end{DoxyItemize}

\#\#\# declare\+Function 
\begin{DoxyCode}
t.declareFunction(id)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Declare\+Function(node, opts)} and {\ttfamily t.\+assert\+Declare\+Function(node, opts)}.

Aliases\+: {\ttfamily Flow}, {\ttfamily Flow\+Declaration}, {\ttfamily Statement}, {\ttfamily Declaration}


\begin{DoxyItemize}
\item {\ttfamily id} (required) 


\end{DoxyItemize}

\#\#\# declare\+Interface 
\begin{DoxyCode}
t.declareInterface(id, typeParameters, extends, body)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Declare\+Interface(node, opts)} and {\ttfamily t.\+assert\+Declare\+Interface(node, opts)}.

Aliases\+: {\ttfamily Flow}, {\ttfamily Flow\+Declaration}, {\ttfamily Statement}, {\ttfamily Declaration}


\begin{DoxyItemize}
\item {\ttfamily id} (required)
\item {\ttfamily type\+Parameters} (required)
\item {\ttfamily extends} (required)
\item {\ttfamily body} (required) 


\end{DoxyItemize}

\#\#\# declare\+Module 
\begin{DoxyCode}
t.declareModule(id, body)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Declare\+Module(node, opts)} and {\ttfamily t.\+assert\+Declare\+Module(node, opts)}.

Aliases\+: {\ttfamily Flow}, {\ttfamily Flow\+Declaration}, {\ttfamily Statement}, {\ttfamily Declaration}


\begin{DoxyItemize}
\item {\ttfamily id} (required)
\item {\ttfamily body} (required) 


\end{DoxyItemize}

\#\#\# declare\+Module\+Exports 
\begin{DoxyCode}
t.declareModuleExports(typeAnnotation)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Declare\+Module\+Exports(node, opts)} and {\ttfamily t.\+assert\+Declare\+Module\+Exports(node, opts)}.

Aliases\+: {\ttfamily Flow}, {\ttfamily Flow\+Declaration}, {\ttfamily Statement}, {\ttfamily Declaration}


\begin{DoxyItemize}
\item {\ttfamily type\+Annotation} (required) 


\end{DoxyItemize}

\#\#\# declare\+Type\+Alias 
\begin{DoxyCode}
t.declareTypeAlias(id, typeParameters, right)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Declare\+Type\+Alias(node, opts)} and {\ttfamily t.\+assert\+Declare\+Type\+Alias(node, opts)}.

Aliases\+: {\ttfamily Flow}, {\ttfamily Flow\+Declaration}, {\ttfamily Statement}, {\ttfamily Declaration}


\begin{DoxyItemize}
\item {\ttfamily id} (required)
\item {\ttfamily type\+Parameters} (required)
\item {\ttfamily right} (required) 


\end{DoxyItemize}

\#\#\# declare\+Variable 
\begin{DoxyCode}
t.declareVariable(id)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Declare\+Variable(node, opts)} and {\ttfamily t.\+assert\+Declare\+Variable(node, opts)}.

Aliases\+: {\ttfamily Flow}, {\ttfamily Flow\+Declaration}, {\ttfamily Statement}, {\ttfamily Declaration}


\begin{DoxyItemize}
\item {\ttfamily id} (required) 


\end{DoxyItemize}

\#\#\# decorator 
\begin{DoxyCode}
t.decorator(expression)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Decorator(node, opts)} and {\ttfamily t.\+assert\+Decorator(node, opts)}.


\begin{DoxyItemize}
\item {\ttfamily expression}\+: {\ttfamily Expression} (required) 


\end{DoxyItemize}

\#\#\# directive 
\begin{DoxyCode}
t.directive(value)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Directive(node, opts)} and {\ttfamily t.\+assert\+Directive(node, opts)}.


\begin{DoxyItemize}
\item {\ttfamily value}\+: {\ttfamily Directive\+Literal} (required) 


\end{DoxyItemize}

\#\#\# directive\+Literal 
\begin{DoxyCode}
t.directiveLiteral(value)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Directive\+Literal(node, opts)} and {\ttfamily t.\+assert\+Directive\+Literal(node, opts)}.


\begin{DoxyItemize}
\item {\ttfamily value}\+: {\ttfamily string} (required) 


\end{DoxyItemize}

\#\#\# do\+Expression 
\begin{DoxyCode}
t.doExpression(body)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Do\+Expression(node, opts)} and {\ttfamily t.\+assert\+Do\+Expression(node, opts)}.

Aliases\+: {\ttfamily Expression}


\begin{DoxyItemize}
\item {\ttfamily body}\+: {\ttfamily Block\+Statement} (required) 


\end{DoxyItemize}

\#\#\# do\+While\+Statement 
\begin{DoxyCode}
t.doWhileStatement(test, body)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Do\+While\+Statement(node, opts)} and {\ttfamily t.\+assert\+Do\+While\+Statement(node, opts)}.

Aliases\+: {\ttfamily Statement}, {\ttfamily Block\+Parent}, {\ttfamily Loop}, {\ttfamily While}, {\ttfamily Scopable}


\begin{DoxyItemize}
\item {\ttfamily test}\+: {\ttfamily Expression} (required)
\item {\ttfamily body}\+: {\ttfamily Statement} (required) 


\end{DoxyItemize}

\#\#\# empty\+Statement 
\begin{DoxyCode}
t.emptyStatement()
\end{DoxyCode}


See also {\ttfamily t.\+is\+Empty\+Statement(node, opts)} and {\ttfamily t.\+assert\+Empty\+Statement(node, opts)}.

Aliases\+: {\ttfamily Statement}





\#\#\# empty\+Type\+Annotation 
\begin{DoxyCode}
t.emptyTypeAnnotation()
\end{DoxyCode}


See also {\ttfamily t.\+is\+Empty\+Type\+Annotation(node, opts)} and {\ttfamily t.\+assert\+Empty\+Type\+Annotation(node, opts)}.

Aliases\+: {\ttfamily Flow}, {\ttfamily Flow\+Base\+Annotation}





\#\#\# existential\+Type\+Param 
\begin{DoxyCode}
t.existentialTypeParam()
\end{DoxyCode}


See also {\ttfamily t.\+is\+Existential\+Type\+Param(node, opts)} and {\ttfamily t.\+assert\+Existential\+Type\+Param(node, opts)}.

Aliases\+: {\ttfamily Flow}





\#\#\# export\+All\+Declaration 
\begin{DoxyCode}
t.exportAllDeclaration(source)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Export\+All\+Declaration(node, opts)} and {\ttfamily t.\+assert\+Export\+All\+Declaration(node, opts)}.

Aliases\+: {\ttfamily Statement}, {\ttfamily Declaration}, {\ttfamily Module\+Declaration}, {\ttfamily Export\+Declaration}


\begin{DoxyItemize}
\item {\ttfamily source}\+: {\ttfamily String\+Literal} (required) 


\end{DoxyItemize}

\#\#\# export\+Default\+Declaration 
\begin{DoxyCode}
t.exportDefaultDeclaration(declaration)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Export\+Default\+Declaration(node, opts)} and {\ttfamily t.\+assert\+Export\+Default\+Declaration(node, opts)}.

Aliases\+: {\ttfamily Statement}, {\ttfamily Declaration}, {\ttfamily Module\+Declaration}, {\ttfamily Export\+Declaration}


\begin{DoxyItemize}
\item {\ttfamily declaration}\+: {\ttfamily Function\+Declaration $\vert$ Class\+Declaration $\vert$ Expression} (required) 


\end{DoxyItemize}

\#\#\# export\+Default\+Specifier 
\begin{DoxyCode}
t.exportDefaultSpecifier(exported)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Export\+Default\+Specifier(node, opts)} and {\ttfamily t.\+assert\+Export\+Default\+Specifier(node, opts)}.

Aliases\+: {\ttfamily Module\+Specifier}


\begin{DoxyItemize}
\item {\ttfamily exported}\+: {\ttfamily Identifier} (required) 


\end{DoxyItemize}

\#\#\# export\+Named\+Declaration 
\begin{DoxyCode}
t.exportNamedDeclaration(declaration, specifiers, source)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Export\+Named\+Declaration(node, opts)} and {\ttfamily t.\+assert\+Export\+Named\+Declaration(node, opts)}.

Aliases\+: {\ttfamily Statement}, {\ttfamily Declaration}, {\ttfamily Module\+Declaration}, {\ttfamily Export\+Declaration}


\begin{DoxyItemize}
\item {\ttfamily declaration}\+: {\ttfamily Declaration} (default\+: {\ttfamily null})
\item {\ttfamily specifiers}\+: {\ttfamily Array$<$Export\+Specifier$>$} (required)
\item {\ttfamily source}\+: {\ttfamily String\+Literal} (default\+: {\ttfamily null}) 


\end{DoxyItemize}

\#\#\# export\+Namespace\+Specifier 
\begin{DoxyCode}
t.exportNamespaceSpecifier(exported)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Export\+Namespace\+Specifier(node, opts)} and {\ttfamily t.\+assert\+Export\+Namespace\+Specifier(node, opts)}.

Aliases\+: {\ttfamily Module\+Specifier}


\begin{DoxyItemize}
\item {\ttfamily exported}\+: {\ttfamily Identifier} (required) 


\end{DoxyItemize}

\#\#\# export\+Specifier 
\begin{DoxyCode}
t.exportSpecifier(local, exported)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Export\+Specifier(node, opts)} and {\ttfamily t.\+assert\+Export\+Specifier(node, opts)}.

Aliases\+: {\ttfamily Module\+Specifier}


\begin{DoxyItemize}
\item {\ttfamily local}\+: {\ttfamily Identifier} (required)
\item {\ttfamily exported}\+: {\ttfamily Identifier} (required) 


\end{DoxyItemize}

\#\#\# expression\+Statement 
\begin{DoxyCode}
t.expressionStatement(expression)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Expression\+Statement(node, opts)} and {\ttfamily t.\+assert\+Expression\+Statement(node, opts)}.

Aliases\+: {\ttfamily Statement}, {\ttfamily Expression\+Wrapper}


\begin{DoxyItemize}
\item {\ttfamily expression}\+: {\ttfamily Expression} (required) 


\end{DoxyItemize}

\#\#\# file 
\begin{DoxyCode}
t.file(program, comments, tokens)
\end{DoxyCode}


See also {\ttfamily t.\+is\+File(node, opts)} and {\ttfamily t.\+assert\+File(node, opts)}.


\begin{DoxyItemize}
\item {\ttfamily program}\+: {\ttfamily Program} (required)
\item {\ttfamily comments} (required)
\item {\ttfamily tokens} (required) 


\end{DoxyItemize}

\#\#\# for\+Await\+Statement 
\begin{DoxyCode}
t.forAwaitStatement(left, right, body)
\end{DoxyCode}


See also {\ttfamily t.\+is\+For\+Await\+Statement(node, opts)} and {\ttfamily t.\+assert\+For\+Await\+Statement(node, opts)}.

Aliases\+: {\ttfamily Scopable}, {\ttfamily Statement}, {\ttfamily For}, {\ttfamily Block\+Parent}, {\ttfamily Loop}, {\ttfamily For\+X\+Statement}


\begin{DoxyItemize}
\item {\ttfamily left}\+: {\ttfamily Variable\+Declaration $\vert$ L\+Val} (required)
\item {\ttfamily right}\+: {\ttfamily Expression} (required)
\item {\ttfamily body}\+: {\ttfamily Statement} (required) 


\end{DoxyItemize}

\#\#\# for\+In\+Statement 
\begin{DoxyCode}
t.forInStatement(left, right, body)
\end{DoxyCode}


See also {\ttfamily t.\+is\+For\+In\+Statement(node, opts)} and {\ttfamily t.\+assert\+For\+In\+Statement(node, opts)}.

Aliases\+: {\ttfamily Scopable}, {\ttfamily Statement}, {\ttfamily For}, {\ttfamily Block\+Parent}, {\ttfamily Loop}, {\ttfamily For\+X\+Statement}


\begin{DoxyItemize}
\item {\ttfamily left}\+: {\ttfamily Variable\+Declaration $\vert$ L\+Val} (required)
\item {\ttfamily right}\+: {\ttfamily Expression} (required)
\item {\ttfamily body}\+: {\ttfamily Statement} (required) 


\end{DoxyItemize}

\#\#\# for\+Of\+Statement 
\begin{DoxyCode}
t.forOfStatement(left, right, body)
\end{DoxyCode}


See also {\ttfamily t.\+is\+For\+Of\+Statement(node, opts)} and {\ttfamily t.\+assert\+For\+Of\+Statement(node, opts)}.

Aliases\+: {\ttfamily Scopable}, {\ttfamily Statement}, {\ttfamily For}, {\ttfamily Block\+Parent}, {\ttfamily Loop}, {\ttfamily For\+X\+Statement}


\begin{DoxyItemize}
\item {\ttfamily left}\+: {\ttfamily Variable\+Declaration $\vert$ L\+Val} (required)
\item {\ttfamily right}\+: {\ttfamily Expression} (required)
\item {\ttfamily body}\+: {\ttfamily Statement} (required) 


\end{DoxyItemize}

\#\#\# for\+Statement 
\begin{DoxyCode}
t.forStatement(init, test, update, body)
\end{DoxyCode}


See also {\ttfamily t.\+is\+For\+Statement(node, opts)} and {\ttfamily t.\+assert\+For\+Statement(node, opts)}.

Aliases\+: {\ttfamily Scopable}, {\ttfamily Statement}, {\ttfamily For}, {\ttfamily Block\+Parent}, {\ttfamily Loop}


\begin{DoxyItemize}
\item {\ttfamily init}\+: {\ttfamily Variable\+Declaration $\vert$ Expression} (default\+: {\ttfamily null})
\item {\ttfamily test}\+: {\ttfamily Expression} (default\+: {\ttfamily null})
\item {\ttfamily update}\+: {\ttfamily Expression} (default\+: {\ttfamily null})
\item {\ttfamily body}\+: {\ttfamily Statement} (required) 


\end{DoxyItemize}

\#\#\# function\+Declaration 
\begin{DoxyCode}
t.functionDeclaration(id, params, body, generator, async)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Function\+Declaration(node, opts)} and {\ttfamily t.\+assert\+Function\+Declaration(node, opts)}.

Aliases\+: {\ttfamily Scopable}, {\ttfamily Function}, {\ttfamily Block\+Parent}, {\ttfamily Function\+Parent}, {\ttfamily Statement}, {\ttfamily Pureish}, {\ttfamily Declaration}


\begin{DoxyItemize}
\item {\ttfamily id}\+: {\ttfamily Identifier} (required)
\item {\ttfamily params}\+: {\ttfamily Array$<$L\+Val$>$} (required)
\item {\ttfamily body}\+: {\ttfamily Block\+Statement} (required)
\item {\ttfamily generator}\+: {\ttfamily boolean} (default\+: {\ttfamily false})
\item {\ttfamily async}\+: {\ttfamily boolean} (default\+: {\ttfamily false})
\item {\ttfamily return\+Type} (default\+: {\ttfamily null})
\item {\ttfamily type\+Parameters} (default\+: {\ttfamily null}) 


\end{DoxyItemize}

\#\#\# function\+Expression 
\begin{DoxyCode}
t.functionExpression(id, params, body, generator, async)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Function\+Expression(node, opts)} and {\ttfamily t.\+assert\+Function\+Expression(node, opts)}.

Aliases\+: {\ttfamily Scopable}, {\ttfamily Function}, {\ttfamily Block\+Parent}, {\ttfamily Function\+Parent}, {\ttfamily Expression}, {\ttfamily Pureish}


\begin{DoxyItemize}
\item {\ttfamily id}\+: {\ttfamily Identifier} (default\+: {\ttfamily null})
\item {\ttfamily params}\+: {\ttfamily Array$<$L\+Val$>$} (required)
\item {\ttfamily body}\+: {\ttfamily Block\+Statement} (required)
\item {\ttfamily generator}\+: {\ttfamily boolean} (default\+: {\ttfamily false})
\item {\ttfamily async}\+: {\ttfamily boolean} (default\+: {\ttfamily false})
\item {\ttfamily return\+Type} (default\+: {\ttfamily null})
\item {\ttfamily type\+Parameters} (default\+: {\ttfamily null}) 


\end{DoxyItemize}

\#\#\# function\+Type\+Annotation 
\begin{DoxyCode}
t.functionTypeAnnotation(typeParameters, params, rest, returnType)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Function\+Type\+Annotation(node, opts)} and {\ttfamily t.\+assert\+Function\+Type\+Annotation(node, opts)}.

Aliases\+: {\ttfamily Flow}


\begin{DoxyItemize}
\item {\ttfamily type\+Parameters} (required)
\item {\ttfamily params} (required)
\item {\ttfamily rest} (required)
\item {\ttfamily return\+Type} (required) 


\end{DoxyItemize}

\#\#\# function\+Type\+Param 
\begin{DoxyCode}
t.functionTypeParam(name, typeAnnotation)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Function\+Type\+Param(node, opts)} and {\ttfamily t.\+assert\+Function\+Type\+Param(node, opts)}.

Aliases\+: {\ttfamily Flow}


\begin{DoxyItemize}
\item {\ttfamily name} (required)
\item {\ttfamily type\+Annotation} (required) 


\end{DoxyItemize}

\#\#\# generic\+Type\+Annotation 
\begin{DoxyCode}
t.genericTypeAnnotation(id, typeParameters)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Generic\+Type\+Annotation(node, opts)} and {\ttfamily t.\+assert\+Generic\+Type\+Annotation(node, opts)}.

Aliases\+: {\ttfamily Flow}


\begin{DoxyItemize}
\item {\ttfamily id} (required)
\item {\ttfamily type\+Parameters} (required) 


\end{DoxyItemize}

\#\#\# identifier 
\begin{DoxyCode}
t.identifier(name)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Identifier(node, opts)} and {\ttfamily t.\+assert\+Identifier(node, opts)}.

Aliases\+: {\ttfamily Expression}, {\ttfamily L\+Val}


\begin{DoxyItemize}
\item {\ttfamily name}{\ttfamily string} (required)
\item {\ttfamily decorators}\+: {\ttfamily Array$<$Decorator$>$} (default\+: {\ttfamily null})
\item {\ttfamily type\+Annotation} (default\+: {\ttfamily null}) 


\end{DoxyItemize}

\#\#\# if\+Statement 
\begin{DoxyCode}
t.ifStatement(test, consequent, alternate)
\end{DoxyCode}


See also {\ttfamily t.\+is\+If\+Statement(node, opts)} and {\ttfamily t.\+assert\+If\+Statement(node, opts)}.

Aliases\+: {\ttfamily Statement}, {\ttfamily Conditional}


\begin{DoxyItemize}
\item {\ttfamily test}\+: {\ttfamily Expression} (required)
\item {\ttfamily consequent}\+: {\ttfamily Statement} (required)
\item {\ttfamily alternate}\+: {\ttfamily Statement} (default\+: {\ttfamily null}) 


\end{DoxyItemize}

\#\#\# import 
\begin{DoxyCode}
t.import()
\end{DoxyCode}


See also {\ttfamily t.\+is\+Import(node, opts)} and {\ttfamily t.\+assert\+Import(node, opts)}.

Aliases\+: {\ttfamily Expression}





\#\#\# import\+Declaration 
\begin{DoxyCode}
t.importDeclaration(specifiers, source)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Import\+Declaration(node, opts)} and {\ttfamily t.\+assert\+Import\+Declaration(node, opts)}.

Aliases\+: {\ttfamily Statement}, {\ttfamily Declaration}, {\ttfamily Module\+Declaration}


\begin{DoxyItemize}
\item {\ttfamily specifiers}\+: {\ttfamily Array$<$Import\+Specifier $\vert$ Import\+Default\+Specifier $\vert$ Import\+Namespace\+Specifier$>$} (required)
\item {\ttfamily source}\+: {\ttfamily String\+Literal} (required) 


\end{DoxyItemize}

\#\#\# import\+Default\+Specifier 
\begin{DoxyCode}
t.importDefaultSpecifier(local)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Import\+Default\+Specifier(node, opts)} and {\ttfamily t.\+assert\+Import\+Default\+Specifier(node, opts)}.

Aliases\+: {\ttfamily Module\+Specifier}


\begin{DoxyItemize}
\item {\ttfamily local}\+: {\ttfamily Identifier} (required) 


\end{DoxyItemize}

\#\#\# import\+Namespace\+Specifier 
\begin{DoxyCode}
t.importNamespaceSpecifier(local)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Import\+Namespace\+Specifier(node, opts)} and {\ttfamily t.\+assert\+Import\+Namespace\+Specifier(node, opts)}.

Aliases\+: {\ttfamily Module\+Specifier}


\begin{DoxyItemize}
\item {\ttfamily local}\+: {\ttfamily Identifier} (required) 


\end{DoxyItemize}

\#\#\# import\+Specifier 
\begin{DoxyCode}
t.importSpecifier(local, imported)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Import\+Specifier(node, opts)} and {\ttfamily t.\+assert\+Import\+Specifier(node, opts)}.

Aliases\+: {\ttfamily Module\+Specifier}


\begin{DoxyItemize}
\item {\ttfamily local}\+: {\ttfamily Identifier} (required)
\item {\ttfamily imported}\+: {\ttfamily Identifier} (required)
\item {\ttfamily import\+Kind}\+: `null $\vert$ \textquotesingle{}type' $\vert$ \textquotesingle{}typeof\textquotesingle{}{\ttfamily (default\+:}null\`{}) 


\end{DoxyItemize}

\#\#\# interface\+Declaration 
\begin{DoxyCode}
t.interfaceDeclaration(id, typeParameters, extends, body)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Interface\+Declaration(node, opts)} and {\ttfamily t.\+assert\+Interface\+Declaration(node, opts)}.

Aliases\+: {\ttfamily Flow}, {\ttfamily Flow\+Declaration}, {\ttfamily Statement}, {\ttfamily Declaration}


\begin{DoxyItemize}
\item {\ttfamily id} (required)
\item {\ttfamily type\+Parameters} (required)
\item {\ttfamily extends} (required)
\item {\ttfamily body} (required) 


\end{DoxyItemize}

\#\#\# interface\+Extends 
\begin{DoxyCode}
t.interfaceExtends(id, typeParameters)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Interface\+Extends(node, opts)} and {\ttfamily t.\+assert\+Interface\+Extends(node, opts)}.

Aliases\+: {\ttfamily Flow}


\begin{DoxyItemize}
\item {\ttfamily id} (required)
\item {\ttfamily type\+Parameters} (required) 


\end{DoxyItemize}

\#\#\# intersection\+Type\+Annotation 
\begin{DoxyCode}
t.intersectionTypeAnnotation(types)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Intersection\+Type\+Annotation(node, opts)} and {\ttfamily t.\+assert\+Intersection\+Type\+Annotation(node, opts)}.

Aliases\+: {\ttfamily Flow}


\begin{DoxyItemize}
\item {\ttfamily types} (required) 


\end{DoxyItemize}

\#\#\# j\+S\+X\+Attribute 
\begin{DoxyCode}
t.jSXAttribute(name, value)
\end{DoxyCode}


See also {\ttfamily t.\+is\+J\+S\+X\+Attribute(node, opts)} and {\ttfamily t.\+assert\+J\+S\+X\+Attribute(node, opts)}.

Aliases\+: {\ttfamily J\+SX}, {\ttfamily Immutable}


\begin{DoxyItemize}
\item {\ttfamily name}\+: {\ttfamily J\+S\+X\+Identifier $\vert$ J\+S\+X\+Namespaced\+Name} (required)
\item {\ttfamily value}\+: {\ttfamily J\+S\+X\+Element $\vert$ String\+Literal $\vert$ J\+S\+X\+Expression\+Container} (default\+: {\ttfamily null}) 


\end{DoxyItemize}

\#\#\# j\+S\+X\+Closing\+Element 
\begin{DoxyCode}
t.jSXClosingElement(name)
\end{DoxyCode}


See also {\ttfamily t.\+is\+J\+S\+X\+Closing\+Element(node, opts)} and {\ttfamily t.\+assert\+J\+S\+X\+Closing\+Element(node, opts)}.

Aliases\+: {\ttfamily J\+SX}, {\ttfamily Immutable}


\begin{DoxyItemize}
\item {\ttfamily name}\+: {\ttfamily J\+S\+X\+Identifier $\vert$ J\+S\+X\+Member\+Expression} (required) 


\end{DoxyItemize}

\#\#\# j\+S\+X\+Element 
\begin{DoxyCode}
t.jSXElement(openingElement, closingElement, children, selfClosing)
\end{DoxyCode}


See also {\ttfamily t.\+is\+J\+S\+X\+Element(node, opts)} and {\ttfamily t.\+assert\+J\+S\+X\+Element(node, opts)}.

Aliases\+: {\ttfamily J\+SX}, {\ttfamily Immutable}, {\ttfamily Expression}


\begin{DoxyItemize}
\item {\ttfamily opening\+Element}\+: {\ttfamily J\+S\+X\+Opening\+Element} (required)
\item {\ttfamily closing\+Element}\+: {\ttfamily J\+S\+X\+Closing\+Element} (default\+: {\ttfamily null})
\item {\ttfamily children}\+: {\ttfamily Array$<$J\+S\+X\+Text $\vert$ J\+S\+X\+Expression\+Container $\vert$ J\+S\+X\+Spread\+Child $\vert$ J\+S\+X\+Element$>$} (required)
\item {\ttfamily self\+Closing} (required) 


\end{DoxyItemize}

\#\#\# j\+S\+X\+Empty\+Expression 
\begin{DoxyCode}
t.jSXEmptyExpression()
\end{DoxyCode}


See also {\ttfamily t.\+is\+J\+S\+X\+Empty\+Expression(node, opts)} and {\ttfamily t.\+assert\+J\+S\+X\+Empty\+Expression(node, opts)}.

Aliases\+: {\ttfamily J\+SX}, {\ttfamily Expression}





\#\#\# j\+S\+X\+Expression\+Container 
\begin{DoxyCode}
t.jSXExpressionContainer(expression)
\end{DoxyCode}


See also {\ttfamily t.\+is\+J\+S\+X\+Expression\+Container(node, opts)} and {\ttfamily t.\+assert\+J\+S\+X\+Expression\+Container(node, opts)}.

Aliases\+: {\ttfamily J\+SX}, {\ttfamily Immutable}


\begin{DoxyItemize}
\item {\ttfamily expression}\+: {\ttfamily Expression} (required) 


\end{DoxyItemize}

\#\#\# j\+S\+X\+Identifier 
\begin{DoxyCode}
t.jSXIdentifier(name)
\end{DoxyCode}


See also {\ttfamily t.\+is\+J\+S\+X\+Identifier(node, opts)} and {\ttfamily t.\+assert\+J\+S\+X\+Identifier(node, opts)}.

Aliases\+: {\ttfamily J\+SX}, {\ttfamily Expression}


\begin{DoxyItemize}
\item {\ttfamily name}\+: {\ttfamily string} (required) 


\end{DoxyItemize}

\#\#\# j\+S\+X\+Member\+Expression 
\begin{DoxyCode}
t.jSXMemberExpression(object, property)
\end{DoxyCode}


See also {\ttfamily t.\+is\+J\+S\+X\+Member\+Expression(node, opts)} and {\ttfamily t.\+assert\+J\+S\+X\+Member\+Expression(node, opts)}.

Aliases\+: {\ttfamily J\+SX}, {\ttfamily Expression}


\begin{DoxyItemize}
\item {\ttfamily object}\+: {\ttfamily J\+S\+X\+Member\+Expression $\vert$ J\+S\+X\+Identifier} (required)
\item {\ttfamily property}\+: {\ttfamily J\+S\+X\+Identifier} (required) 


\end{DoxyItemize}

\#\#\# j\+S\+X\+Namespaced\+Name 
\begin{DoxyCode}
t.jSXNamespacedName(namespace, name)
\end{DoxyCode}


See also {\ttfamily t.\+is\+J\+S\+X\+Namespaced\+Name(node, opts)} and {\ttfamily t.\+assert\+J\+S\+X\+Namespaced\+Name(node, opts)}.

Aliases\+: {\ttfamily J\+SX}


\begin{DoxyItemize}
\item {\ttfamily namespace}\+: {\ttfamily J\+S\+X\+Identifier} (required)
\item {\ttfamily name}\+: {\ttfamily J\+S\+X\+Identifier} (required) 


\end{DoxyItemize}

\#\#\# j\+S\+X\+Opening\+Element 
\begin{DoxyCode}
t.jSXOpeningElement(name, attributes, selfClosing)
\end{DoxyCode}


See also {\ttfamily t.\+is\+J\+S\+X\+Opening\+Element(node, opts)} and {\ttfamily t.\+assert\+J\+S\+X\+Opening\+Element(node, opts)}.

Aliases\+: {\ttfamily J\+SX}, {\ttfamily Immutable}


\begin{DoxyItemize}
\item {\ttfamily name}\+: {\ttfamily J\+S\+X\+Identifier $\vert$ J\+S\+X\+Member\+Expression} (required)
\item {\ttfamily attributes}\+: {\ttfamily Array$<$J\+S\+X\+Attribute $\vert$ J\+S\+X\+Spread\+Attribute$>$} (required)
\item {\ttfamily self\+Closing}\+: {\ttfamily boolean} (default\+: {\ttfamily false}) 


\end{DoxyItemize}

\#\#\# j\+S\+X\+Spread\+Attribute 
\begin{DoxyCode}
t.jSXSpreadAttribute(argument)
\end{DoxyCode}


See also {\ttfamily t.\+is\+J\+S\+X\+Spread\+Attribute(node, opts)} and {\ttfamily t.\+assert\+J\+S\+X\+Spread\+Attribute(node, opts)}.

Aliases\+: {\ttfamily J\+SX}


\begin{DoxyItemize}
\item {\ttfamily argument}\+: {\ttfamily Expression} (required) 


\end{DoxyItemize}

\#\#\# j\+S\+X\+Spread\+Child 
\begin{DoxyCode}
t.jSXSpreadChild(expression)
\end{DoxyCode}


See also {\ttfamily t.\+is\+J\+S\+X\+Spread\+Child(node, opts)} and {\ttfamily t.\+assert\+J\+S\+X\+Spread\+Child(node, opts)}.

Aliases\+: {\ttfamily J\+SX}, {\ttfamily Immutable}


\begin{DoxyItemize}
\item {\ttfamily expression}\+: {\ttfamily Expression} (required) 


\end{DoxyItemize}

\#\#\# j\+S\+X\+Text 
\begin{DoxyCode}
t.jSXText(value)
\end{DoxyCode}


See also {\ttfamily t.\+is\+J\+S\+X\+Text(node, opts)} and {\ttfamily t.\+assert\+J\+S\+X\+Text(node, opts)}.

Aliases\+: {\ttfamily J\+SX}, {\ttfamily Immutable}


\begin{DoxyItemize}
\item {\ttfamily value}\+: {\ttfamily string} (required) 


\end{DoxyItemize}

\#\#\# labeled\+Statement 
\begin{DoxyCode}
t.labeledStatement(label, body)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Labeled\+Statement(node, opts)} and {\ttfamily t.\+assert\+Labeled\+Statement(node, opts)}.

Aliases\+: {\ttfamily Statement}


\begin{DoxyItemize}
\item {\ttfamily label}\+: {\ttfamily Identifier} (required)
\item {\ttfamily body}\+: {\ttfamily Statement} (required) 


\end{DoxyItemize}

\#\#\# logical\+Expression 
\begin{DoxyCode}
t.logicalExpression(operator, left, right)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Logical\+Expression(node, opts)} and {\ttfamily t.\+assert\+Logical\+Expression(node, opts)}.

Aliases\+: {\ttfamily Binary}, {\ttfamily Expression}


\begin{DoxyItemize}
\item {\ttfamily operator}\+: `'$\vert$$\vert$\textquotesingle{} $\vert$ \textquotesingle{}\&\&\textquotesingle{}{\ttfamily (required) -\/}left{\ttfamily \+:}Expression$<$tt$>$(required) -\/right{\ttfamily \+:}Expression\`{} (required) 


\end{DoxyItemize}

\#\#\# member\+Expression 
\begin{DoxyCode}
t.memberExpression(object, property, computed)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Member\+Expression(node, opts)} and {\ttfamily t.\+assert\+Member\+Expression(node, opts)}.

Aliases\+: {\ttfamily Expression}, {\ttfamily L\+Val}


\begin{DoxyItemize}
\item {\ttfamily object}\+: {\ttfamily Expression} (required)
\item {\ttfamily property}if computed then {\ttfamily Expression} else {\ttfamily Identifier} (required)
\item {\ttfamily computed}\+: {\ttfamily boolean} (default\+: {\ttfamily false}) 


\end{DoxyItemize}

\#\#\# meta\+Property 
\begin{DoxyCode}
t.metaProperty(meta, property)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Meta\+Property(node, opts)} and {\ttfamily t.\+assert\+Meta\+Property(node, opts)}.

Aliases\+: {\ttfamily Expression}


\begin{DoxyItemize}
\item {\ttfamily meta}\+: {\ttfamily string} (required)
\item {\ttfamily property}\+: {\ttfamily string} (required) 


\end{DoxyItemize}

\#\#\# mixed\+Type\+Annotation 
\begin{DoxyCode}
t.mixedTypeAnnotation()
\end{DoxyCode}


See also {\ttfamily t.\+is\+Mixed\+Type\+Annotation(node, opts)} and {\ttfamily t.\+assert\+Mixed\+Type\+Annotation(node, opts)}.

Aliases\+: {\ttfamily Flow}, {\ttfamily Flow\+Base\+Annotation}





\#\#\# new\+Expression 
\begin{DoxyCode}
t.newExpression(callee, arguments)
\end{DoxyCode}


See also {\ttfamily t.\+is\+New\+Expression(node, opts)} and {\ttfamily t.\+assert\+New\+Expression(node, opts)}.

Aliases\+: {\ttfamily Expression}


\begin{DoxyItemize}
\item {\ttfamily callee}\+: {\ttfamily Expression} (required)
\item {\ttfamily arguments}\+: {\ttfamily Array$<$Expression $\vert$ Spread\+Element$>$} (required) 


\end{DoxyItemize}

\#\#\# noop 
\begin{DoxyCode}
t.noop()
\end{DoxyCode}


See also {\ttfamily t.\+is\+Noop(node, opts)} and {\ttfamily t.\+assert\+Noop(node, opts)}.





\#\#\# null\+Literal 
\begin{DoxyCode}
t.nullLiteral()
\end{DoxyCode}


See also {\ttfamily t.\+is\+Null\+Literal(node, opts)} and {\ttfamily t.\+assert\+Null\+Literal(node, opts)}.

Aliases\+: {\ttfamily Expression}, {\ttfamily Pureish}, {\ttfamily Literal}, {\ttfamily Immutable}





\#\#\# null\+Literal\+Type\+Annotation 
\begin{DoxyCode}
t.nullLiteralTypeAnnotation()
\end{DoxyCode}


See also {\ttfamily t.\+is\+Null\+Literal\+Type\+Annotation(node, opts)} and {\ttfamily t.\+assert\+Null\+Literal\+Type\+Annotation(node, opts)}.

Aliases\+: {\ttfamily Flow}, {\ttfamily Flow\+Base\+Annotation}





\#\#\# nullable\+Type\+Annotation 
\begin{DoxyCode}
t.nullableTypeAnnotation(typeAnnotation)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Nullable\+Type\+Annotation(node, opts)} and {\ttfamily t.\+assert\+Nullable\+Type\+Annotation(node, opts)}.

Aliases\+: {\ttfamily Flow}


\begin{DoxyItemize}
\item {\ttfamily type\+Annotation} (required) 


\end{DoxyItemize}

\#\#\# number\+Type\+Annotation 
\begin{DoxyCode}
t.numberTypeAnnotation()
\end{DoxyCode}


See also {\ttfamily t.\+is\+Number\+Type\+Annotation(node, opts)} and {\ttfamily t.\+assert\+Number\+Type\+Annotation(node, opts)}.

Aliases\+: {\ttfamily Flow}, {\ttfamily Flow\+Base\+Annotation}





\#\#\# numeric\+Literal 
\begin{DoxyCode}
t.numericLiteral(value)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Numeric\+Literal(node, opts)} and {\ttfamily t.\+assert\+Numeric\+Literal(node, opts)}.

Aliases\+: {\ttfamily Expression}, {\ttfamily Pureish}, {\ttfamily Literal}, {\ttfamily Immutable}


\begin{DoxyItemize}
\item {\ttfamily value}\+: {\ttfamily number} (required) 


\end{DoxyItemize}

\#\#\# numeric\+Literal\+Type\+Annotation 
\begin{DoxyCode}
t.numericLiteralTypeAnnotation()
\end{DoxyCode}


See also {\ttfamily t.\+is\+Numeric\+Literal\+Type\+Annotation(node, opts)} and {\ttfamily t.\+assert\+Numeric\+Literal\+Type\+Annotation(node, opts)}.

Aliases\+: {\ttfamily Flow}





\#\#\# object\+Expression 
\begin{DoxyCode}
t.objectExpression(properties)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Object\+Expression(node, opts)} and {\ttfamily t.\+assert\+Object\+Expression(node, opts)}.

Aliases\+: {\ttfamily Expression}


\begin{DoxyItemize}
\item {\ttfamily properties}\+: {\ttfamily Array$<$Object\+Method $\vert$ Object\+Property $\vert$ Spread\+Property$>$} (required) 


\end{DoxyItemize}

\#\#\# object\+Method 
\begin{DoxyCode}
t.objectMethod(kind, key, params, body, computed)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Object\+Method(node, opts)} and {\ttfamily t.\+assert\+Object\+Method(node, opts)}.

Aliases\+: {\ttfamily User\+Whitespacable}, {\ttfamily Function}, {\ttfamily Scopable}, {\ttfamily Block\+Parent}, {\ttfamily Function\+Parent}, {\ttfamily Method}, {\ttfamily Object\+Member}


\begin{DoxyItemize}
\item {\ttfamily kind}\+: {\ttfamily \char`\"{}method\char`\"{} $\vert$ \char`\"{}get\char`\"{} $\vert$ \char`\"{}set\char`\"{}} (default\+: `\textquotesingle{}method'{\ttfamily ) -\/}key{\ttfamily if computed then}Expression{\ttfamily else}Identifier $\vert$ Literal$<$tt$>$(required) -\/params$<$tt$>$(required) -\/body{\ttfamily \+:}Block\+Statement$<$tt$>$(required) -\/computed{\ttfamily \+:}boolean{\ttfamily (default\+:}false{\ttfamily ) -\/}async{\ttfamily \+:}boolean{\ttfamily (default\+:}false{\ttfamily ) -\/}decorators{\ttfamily \+:}Array$<$\+Decorator$>${\ttfamily (default\+:}null{\ttfamily ) -\/}generator{\ttfamily \+:}boolean{\ttfamily (default\+:}false{\ttfamily ) -\/}return\+Type{\ttfamily (default\+:}null{\ttfamily ) -\/}type\+Parameters{\ttfamily (default\+:}null\`{}) 


\end{DoxyItemize}

\#\#\# object\+Pattern 
\begin{DoxyCode}
t.objectPattern(properties, typeAnnotation)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Object\+Pattern(node, opts)} and {\ttfamily t.\+assert\+Object\+Pattern(node, opts)}.

Aliases\+: {\ttfamily Pattern}, {\ttfamily L\+Val}


\begin{DoxyItemize}
\item {\ttfamily properties}\+: {\ttfamily Array$<$Rest\+Property $\vert$ Property$>$} (required)
\item {\ttfamily type\+Annotation} (required)
\item {\ttfamily decorators}\+: {\ttfamily Array$<$Decorator$>$} (default\+: {\ttfamily null}) 


\end{DoxyItemize}

\#\#\# object\+Property 
\begin{DoxyCode}
t.objectProperty(key, value, computed, shorthand, decorators)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Object\+Property(node, opts)} and {\ttfamily t.\+assert\+Object\+Property(node, opts)}.

Aliases\+: {\ttfamily User\+Whitespacable}, {\ttfamily Property}, {\ttfamily Object\+Member}


\begin{DoxyItemize}
\item {\ttfamily key}if computed then {\ttfamily Expression} else {\ttfamily Identifier $\vert$ Literal} (required)
\item {\ttfamily value}\+: {\ttfamily Expression $\vert$ Pattern $\vert$ Rest\+Element} (required)
\item {\ttfamily computed}\+: {\ttfamily boolean} (default\+: {\ttfamily false})
\item {\ttfamily shorthand}\+: {\ttfamily boolean} (default\+: {\ttfamily false})
\item {\ttfamily decorators}\+: {\ttfamily Array$<$Decorator$>$} (default\+: {\ttfamily null}) 


\end{DoxyItemize}

\#\#\# object\+Type\+Annotation 
\begin{DoxyCode}
t.objectTypeAnnotation(properties, indexers, callProperties)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Object\+Type\+Annotation(node, opts)} and {\ttfamily t.\+assert\+Object\+Type\+Annotation(node, opts)}.

Aliases\+: {\ttfamily Flow}


\begin{DoxyItemize}
\item {\ttfamily properties} (required)
\item {\ttfamily indexers} (required)
\item {\ttfamily call\+Properties} (required) 


\end{DoxyItemize}

\#\#\# object\+Type\+Call\+Property 
\begin{DoxyCode}
t.objectTypeCallProperty(value)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Object\+Type\+Call\+Property(node, opts)} and {\ttfamily t.\+assert\+Object\+Type\+Call\+Property(node, opts)}.

Aliases\+: {\ttfamily Flow}, {\ttfamily User\+Whitespacable}


\begin{DoxyItemize}
\item {\ttfamily value} (required) 


\end{DoxyItemize}

\#\#\# object\+Type\+Indexer 
\begin{DoxyCode}
t.objectTypeIndexer(id, key, value)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Object\+Type\+Indexer(node, opts)} and {\ttfamily t.\+assert\+Object\+Type\+Indexer(node, opts)}.

Aliases\+: {\ttfamily Flow}, {\ttfamily User\+Whitespacable}


\begin{DoxyItemize}
\item {\ttfamily id} (required)
\item {\ttfamily key} (required)
\item {\ttfamily value} (required) 


\end{DoxyItemize}

\#\#\# object\+Type\+Property 
\begin{DoxyCode}
t.objectTypeProperty(key, value)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Object\+Type\+Property(node, opts)} and {\ttfamily t.\+assert\+Object\+Type\+Property(node, opts)}.

Aliases\+: {\ttfamily Flow}, {\ttfamily User\+Whitespacable}


\begin{DoxyItemize}
\item {\ttfamily key} (required)
\item {\ttfamily value} (required) 


\end{DoxyItemize}

\#\#\# object\+Type\+Spread\+Property 
\begin{DoxyCode}
t.objectTypeSpreadProperty(argument)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Object\+Type\+Spread\+Property(node, opts)} and {\ttfamily t.\+assert\+Object\+Type\+Spread\+Property(node, opts)}.

Aliases\+: {\ttfamily Flow}, {\ttfamily User\+Whitespacable}


\begin{DoxyItemize}
\item {\ttfamily argument} (required) 


\end{DoxyItemize}

\#\#\# parenthesized\+Expression 
\begin{DoxyCode}
t.parenthesizedExpression(expression)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Parenthesized\+Expression(node, opts)} and {\ttfamily t.\+assert\+Parenthesized\+Expression(node, opts)}.

Aliases\+: {\ttfamily Expression}, {\ttfamily Expression\+Wrapper}


\begin{DoxyItemize}
\item {\ttfamily expression}\+: {\ttfamily Expression} (required) 


\end{DoxyItemize}

\#\#\# program 
\begin{DoxyCode}
t.program(body, directives)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Program(node, opts)} and {\ttfamily t.\+assert\+Program(node, opts)}.

Aliases\+: {\ttfamily Scopable}, {\ttfamily Block\+Parent}, {\ttfamily Block}, {\ttfamily Function\+Parent}


\begin{DoxyItemize}
\item {\ttfamily body}\+: {\ttfamily Array$<$Statement$>$} (required)
\item {\ttfamily directives}\+: {\ttfamily Array$<$Directive$>$} (default\+: {\ttfamily \mbox{[}\mbox{]}}) 


\end{DoxyItemize}

\#\#\# qualified\+Type\+Identifier 
\begin{DoxyCode}
t.qualifiedTypeIdentifier(id, qualification)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Qualified\+Type\+Identifier(node, opts)} and {\ttfamily t.\+assert\+Qualified\+Type\+Identifier(node, opts)}.

Aliases\+: {\ttfamily Flow}


\begin{DoxyItemize}
\item {\ttfamily id} (required)
\item {\ttfamily qualification} (required) 


\end{DoxyItemize}

\#\#\# reg\+Exp\+Literal 
\begin{DoxyCode}
t.regExpLiteral(pattern, flags)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Reg\+Exp\+Literal(node, opts)} and {\ttfamily t.\+assert\+Reg\+Exp\+Literal(node, opts)}.

Aliases\+: {\ttfamily Expression}, {\ttfamily Literal}


\begin{DoxyItemize}
\item {\ttfamily pattern}\+: {\ttfamily string} (required)
\item {\ttfamily flags}\+: {\ttfamily string} (default\+: `'\textquotesingle{}\`{}) 


\end{DoxyItemize}

\#\#\# rest\+Element 
\begin{DoxyCode}
t.restElement(argument, typeAnnotation)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Rest\+Element(node, opts)} and {\ttfamily t.\+assert\+Rest\+Element(node, opts)}.

Aliases\+: {\ttfamily L\+Val}


\begin{DoxyItemize}
\item {\ttfamily argument}\+: {\ttfamily L\+Val} (required)
\item {\ttfamily type\+Annotation} (required)
\item {\ttfamily decorators}\+: {\ttfamily Array$<$Decorator$>$} (default\+: {\ttfamily null}) 


\end{DoxyItemize}

\#\#\# rest\+Property 
\begin{DoxyCode}
t.restProperty(argument)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Rest\+Property(node, opts)} and {\ttfamily t.\+assert\+Rest\+Property(node, opts)}.

Aliases\+: {\ttfamily Unary\+Like}


\begin{DoxyItemize}
\item {\ttfamily argument}\+: {\ttfamily L\+Val} (required) 


\end{DoxyItemize}

\#\#\# return\+Statement 
\begin{DoxyCode}
t.returnStatement(argument)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Return\+Statement(node, opts)} and {\ttfamily t.\+assert\+Return\+Statement(node, opts)}.

Aliases\+: {\ttfamily Statement}, {\ttfamily Terminatorless}, {\ttfamily Completion\+Statement}


\begin{DoxyItemize}
\item {\ttfamily argument}\+: {\ttfamily Expression} (default\+: {\ttfamily null}) 


\end{DoxyItemize}

\#\#\# sequence\+Expression 
\begin{DoxyCode}
t.sequenceExpression(expressions)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Sequence\+Expression(node, opts)} and {\ttfamily t.\+assert\+Sequence\+Expression(node, opts)}.

Aliases\+: {\ttfamily Expression}


\begin{DoxyItemize}
\item {\ttfamily expressions}\+: {\ttfamily Array$<$Expression$>$} (required) 


\end{DoxyItemize}

\#\#\# spread\+Element 
\begin{DoxyCode}
t.spreadElement(argument)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Spread\+Element(node, opts)} and {\ttfamily t.\+assert\+Spread\+Element(node, opts)}.

Aliases\+: {\ttfamily Unary\+Like}


\begin{DoxyItemize}
\item {\ttfamily argument}\+: {\ttfamily Expression} (required) 


\end{DoxyItemize}

\#\#\# spread\+Property 
\begin{DoxyCode}
t.spreadProperty(argument)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Spread\+Property(node, opts)} and {\ttfamily t.\+assert\+Spread\+Property(node, opts)}.

Aliases\+: {\ttfamily Unary\+Like}


\begin{DoxyItemize}
\item {\ttfamily argument}\+: {\ttfamily Expression} (required) 


\end{DoxyItemize}

\#\#\# string\+Literal 
\begin{DoxyCode}
t.stringLiteral(value)
\end{DoxyCode}


See also {\ttfamily t.\+is\+String\+Literal(node, opts)} and {\ttfamily t.\+assert\+String\+Literal(node, opts)}.

Aliases\+: {\ttfamily Expression}, {\ttfamily Pureish}, {\ttfamily Literal}, {\ttfamily Immutable}


\begin{DoxyItemize}
\item {\ttfamily value}\+: {\ttfamily string} (required) 


\end{DoxyItemize}

\#\#\# string\+Literal\+Type\+Annotation 
\begin{DoxyCode}
t.stringLiteralTypeAnnotation()
\end{DoxyCode}


See also {\ttfamily t.\+is\+String\+Literal\+Type\+Annotation(node, opts)} and {\ttfamily t.\+assert\+String\+Literal\+Type\+Annotation(node, opts)}.

Aliases\+: {\ttfamily Flow}





\#\#\# string\+Type\+Annotation 
\begin{DoxyCode}
t.stringTypeAnnotation()
\end{DoxyCode}


See also {\ttfamily t.\+is\+String\+Type\+Annotation(node, opts)} and {\ttfamily t.\+assert\+String\+Type\+Annotation(node, opts)}.

Aliases\+: {\ttfamily Flow}, {\ttfamily Flow\+Base\+Annotation}





\#\#\# super 
\begin{DoxyCode}
t.super()
\end{DoxyCode}


See also {\ttfamily t.\+is\+Super(node, opts)} and {\ttfamily t.\+assert\+Super(node, opts)}.

Aliases\+: {\ttfamily Expression}





\#\#\# switch\+Case 
\begin{DoxyCode}
t.switchCase(test, consequent)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Switch\+Case(node, opts)} and {\ttfamily t.\+assert\+Switch\+Case(node, opts)}.


\begin{DoxyItemize}
\item {\ttfamily test}\+: {\ttfamily Expression} (default\+: {\ttfamily null})
\item {\ttfamily consequent}\+: {\ttfamily Array$<$Statement$>$} (required) 


\end{DoxyItemize}

\#\#\# switch\+Statement 
\begin{DoxyCode}
t.switchStatement(discriminant, cases)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Switch\+Statement(node, opts)} and {\ttfamily t.\+assert\+Switch\+Statement(node, opts)}.

Aliases\+: {\ttfamily Statement}, {\ttfamily Block\+Parent}, {\ttfamily Scopable}


\begin{DoxyItemize}
\item {\ttfamily discriminant}\+: {\ttfamily Expression} (required)
\item {\ttfamily cases}\+: {\ttfamily Array$<$Switch\+Case$>$} (required) 


\end{DoxyItemize}

\#\#\# tagged\+Template\+Expression 
\begin{DoxyCode}
t.taggedTemplateExpression(tag, quasi)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Tagged\+Template\+Expression(node, opts)} and {\ttfamily t.\+assert\+Tagged\+Template\+Expression(node, opts)}.

Aliases\+: {\ttfamily Expression}


\begin{DoxyItemize}
\item {\ttfamily tag}\+: {\ttfamily Expression} (required)
\item {\ttfamily quasi}\+: {\ttfamily Template\+Literal} (required) 


\end{DoxyItemize}

\#\#\# template\+Element 
\begin{DoxyCode}
t.templateElement(value, tail)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Template\+Element(node, opts)} and {\ttfamily t.\+assert\+Template\+Element(node, opts)}.


\begin{DoxyItemize}
\item {\ttfamily value} (required)
\item {\ttfamily tail}\+: {\ttfamily boolean} (default\+: {\ttfamily false}) 


\end{DoxyItemize}

\#\#\# template\+Literal 
\begin{DoxyCode}
t.templateLiteral(quasis, expressions)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Template\+Literal(node, opts)} and {\ttfamily t.\+assert\+Template\+Literal(node, opts)}.

Aliases\+: {\ttfamily Expression}, {\ttfamily Literal}


\begin{DoxyItemize}
\item {\ttfamily quasis}\+: {\ttfamily Array$<$Template\+Element$>$} (required)
\item {\ttfamily expressions}\+: {\ttfamily Array$<$Expression$>$} (required) 


\end{DoxyItemize}

\#\#\# this\+Expression 
\begin{DoxyCode}
t.thisExpression()
\end{DoxyCode}


See also {\ttfamily t.\+is\+This\+Expression(node, opts)} and {\ttfamily t.\+assert\+This\+Expression(node, opts)}.

Aliases\+: {\ttfamily Expression}





\#\#\# this\+Type\+Annotation 
\begin{DoxyCode}
t.thisTypeAnnotation()
\end{DoxyCode}


See also {\ttfamily t.\+is\+This\+Type\+Annotation(node, opts)} and {\ttfamily t.\+assert\+This\+Type\+Annotation(node, opts)}.

Aliases\+: {\ttfamily Flow}, {\ttfamily Flow\+Base\+Annotation}





\#\#\# throw\+Statement 
\begin{DoxyCode}
t.throwStatement(argument)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Throw\+Statement(node, opts)} and {\ttfamily t.\+assert\+Throw\+Statement(node, opts)}.

Aliases\+: {\ttfamily Statement}, {\ttfamily Terminatorless}, {\ttfamily Completion\+Statement}


\begin{DoxyItemize}
\item {\ttfamily argument}\+: {\ttfamily Expression} (required) 


\end{DoxyItemize}

\#\#\# try\+Statement 
\begin{DoxyCode}
t.tryStatement(block, handler, finalizer)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Try\+Statement(node, opts)} and {\ttfamily t.\+assert\+Try\+Statement(node, opts)}.

Aliases\+: {\ttfamily Statement}


\begin{DoxyItemize}
\item {\ttfamily block} (required)
\item {\ttfamily handler} (default\+: {\ttfamily null})
\item {\ttfamily finalizer}\+: {\ttfamily Block\+Statement} (default\+: {\ttfamily null})
\item {\ttfamily body}\+: {\ttfamily Block\+Statement} (default\+: {\ttfamily null}) 


\end{DoxyItemize}

\#\#\# tuple\+Type\+Annotation 
\begin{DoxyCode}
t.tupleTypeAnnotation(types)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Tuple\+Type\+Annotation(node, opts)} and {\ttfamily t.\+assert\+Tuple\+Type\+Annotation(node, opts)}.

Aliases\+: {\ttfamily Flow}


\begin{DoxyItemize}
\item {\ttfamily types} (required) 


\end{DoxyItemize}

\#\#\# type\+Alias 
\begin{DoxyCode}
t.typeAlias(id, typeParameters, right)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Type\+Alias(node, opts)} and {\ttfamily t.\+assert\+Type\+Alias(node, opts)}.

Aliases\+: {\ttfamily Flow}, {\ttfamily Flow\+Declaration}, {\ttfamily Statement}, {\ttfamily Declaration}


\begin{DoxyItemize}
\item {\ttfamily id} (required)
\item {\ttfamily type\+Parameters} (required)
\item {\ttfamily right} (required) 


\end{DoxyItemize}

\#\#\# type\+Annotation 
\begin{DoxyCode}
t.typeAnnotation(typeAnnotation)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Type\+Annotation(node, opts)} and {\ttfamily t.\+assert\+Type\+Annotation(node, opts)}.

Aliases\+: {\ttfamily Flow}


\begin{DoxyItemize}
\item {\ttfamily type\+Annotation} (required) 


\end{DoxyItemize}

\#\#\# type\+Cast\+Expression 
\begin{DoxyCode}
t.typeCastExpression(expression, typeAnnotation)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Type\+Cast\+Expression(node, opts)} and {\ttfamily t.\+assert\+Type\+Cast\+Expression(node, opts)}.

Aliases\+: {\ttfamily Flow}, {\ttfamily Expression\+Wrapper}, {\ttfamily Expression}


\begin{DoxyItemize}
\item {\ttfamily expression} (required)
\item {\ttfamily type\+Annotation} (required) 


\end{DoxyItemize}

\#\#\# type\+Parameter 
\begin{DoxyCode}
t.typeParameter(bound)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Type\+Parameter(node, opts)} and {\ttfamily t.\+assert\+Type\+Parameter(node, opts)}.

Aliases\+: {\ttfamily Flow}


\begin{DoxyItemize}
\item {\ttfamily bound} (required) 


\end{DoxyItemize}

\#\#\# type\+Parameter\+Declaration 
\begin{DoxyCode}
t.typeParameterDeclaration(params)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Type\+Parameter\+Declaration(node, opts)} and {\ttfamily t.\+assert\+Type\+Parameter\+Declaration(node, opts)}.

Aliases\+: {\ttfamily Flow}


\begin{DoxyItemize}
\item {\ttfamily params} (required) 


\end{DoxyItemize}

\#\#\# type\+Parameter\+Instantiation 
\begin{DoxyCode}
t.typeParameterInstantiation(params)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Type\+Parameter\+Instantiation(node, opts)} and {\ttfamily t.\+assert\+Type\+Parameter\+Instantiation(node, opts)}.

Aliases\+: {\ttfamily Flow}


\begin{DoxyItemize}
\item {\ttfamily params} (required) 


\end{DoxyItemize}

\#\#\# typeof\+Type\+Annotation 
\begin{DoxyCode}
t.typeofTypeAnnotation(argument)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Typeof\+Type\+Annotation(node, opts)} and {\ttfamily t.\+assert\+Typeof\+Type\+Annotation(node, opts)}.

Aliases\+: {\ttfamily Flow}


\begin{DoxyItemize}
\item {\ttfamily argument} (required) 


\end{DoxyItemize}

\#\#\# unary\+Expression 
\begin{DoxyCode}
t.unaryExpression(operator, argument, prefix)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Unary\+Expression(node, opts)} and {\ttfamily t.\+assert\+Unary\+Expression(node, opts)}.

Aliases\+: {\ttfamily Unary\+Like}, {\ttfamily Expression}


\begin{DoxyItemize}
\item {\ttfamily operator}\+: `\textquotesingle{}void' $\vert$ \textquotesingle{}delete\textquotesingle{} $\vert$ \textquotesingle{}!\textquotesingle{} $\vert$ \textquotesingle{}+\textquotesingle{} $\vert$ \textquotesingle{}-\/\textquotesingle{} $\vert$ \textquotesingle{}++\textquotesingle{} $\vert$ \textquotesingle{}--\textquotesingle{} $\vert$ \textquotesingle{}$\sim$\textquotesingle{} $\vert$ \textquotesingle{}typeof\textquotesingle{}{\ttfamily (required) -\/}argument{\ttfamily \+:}Expression$<$tt$>$(required) -\/prefix{\ttfamily \+:}boolean{\ttfamily (default\+:}true\`{}) 


\end{DoxyItemize}

\#\#\# union\+Type\+Annotation 
\begin{DoxyCode}
t.unionTypeAnnotation(types)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Union\+Type\+Annotation(node, opts)} and {\ttfamily t.\+assert\+Union\+Type\+Annotation(node, opts)}.

Aliases\+: {\ttfamily Flow}


\begin{DoxyItemize}
\item {\ttfamily types} (required) 


\end{DoxyItemize}

\#\#\# update\+Expression 
\begin{DoxyCode}
t.updateExpression(operator, argument, prefix)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Update\+Expression(node, opts)} and {\ttfamily t.\+assert\+Update\+Expression(node, opts)}.

Aliases\+: {\ttfamily Expression}


\begin{DoxyItemize}
\item {\ttfamily operator}\+: `'++\textquotesingle{} $\vert$ \textquotesingle{}--\textquotesingle{}{\ttfamily (required) -\/}argument{\ttfamily \+:}Expression$<$tt$>$(required) -\/prefix{\ttfamily \+:}boolean{\ttfamily (default\+:}false\`{}) 


\end{DoxyItemize}

\#\#\# variable\+Declaration 
\begin{DoxyCode}
t.variableDeclaration(kind, declarations)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Variable\+Declaration(node, opts)} and {\ttfamily t.\+assert\+Variable\+Declaration(node, opts)}.

Aliases\+: {\ttfamily Statement}, {\ttfamily Declaration}


\begin{DoxyItemize}
\item {\ttfamily kind}\+: {\ttfamily \char`\"{}var\char`\"{} $\vert$ \char`\"{}let\char`\"{} $\vert$ \char`\"{}const\char`\"{}} (required)
\item {\ttfamily declarations}\+: {\ttfamily Array$<$Variable\+Declarator$>$} (required) 


\end{DoxyItemize}

\#\#\# variable\+Declarator 
\begin{DoxyCode}
t.variableDeclarator(id, init)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Variable\+Declarator(node, opts)} and {\ttfamily t.\+assert\+Variable\+Declarator(node, opts)}.


\begin{DoxyItemize}
\item {\ttfamily id}\+: {\ttfamily L\+Val} (required)
\item {\ttfamily init}\+: {\ttfamily Expression} (default\+: {\ttfamily null}) 


\end{DoxyItemize}

\#\#\# void\+Type\+Annotation 
\begin{DoxyCode}
t.voidTypeAnnotation()
\end{DoxyCode}


See also {\ttfamily t.\+is\+Void\+Type\+Annotation(node, opts)} and {\ttfamily t.\+assert\+Void\+Type\+Annotation(node, opts)}.

Aliases\+: {\ttfamily Flow}, {\ttfamily Flow\+Base\+Annotation}





\#\#\# while\+Statement 
\begin{DoxyCode}
t.whileStatement(test, body)
\end{DoxyCode}


See also {\ttfamily t.\+is\+While\+Statement(node, opts)} and {\ttfamily t.\+assert\+While\+Statement(node, opts)}.

Aliases\+: {\ttfamily Statement}, {\ttfamily Block\+Parent}, {\ttfamily Loop}, {\ttfamily While}, {\ttfamily Scopable}


\begin{DoxyItemize}
\item {\ttfamily test}\+: {\ttfamily Expression} (required)
\item {\ttfamily body}\+: {\ttfamily Block\+Statement $\vert$ Statement} (required) 


\end{DoxyItemize}

\#\#\# with\+Statement 
\begin{DoxyCode}
t.withStatement(object, body)
\end{DoxyCode}


See also {\ttfamily t.\+is\+With\+Statement(node, opts)} and {\ttfamily t.\+assert\+With\+Statement(node, opts)}.

Aliases\+: {\ttfamily Statement}


\begin{DoxyItemize}
\item {\ttfamily object} (required)
\item {\ttfamily body}\+: {\ttfamily Block\+Statement $\vert$ Statement} (required) 


\end{DoxyItemize}

\#\#\# yield\+Expression 
\begin{DoxyCode}
t.yieldExpression(argument, delegate)
\end{DoxyCode}


See also {\ttfamily t.\+is\+Yield\+Expression(node, opts)} and {\ttfamily t.\+assert\+Yield\+Expression(node, opts)}.

Aliases\+: {\ttfamily Expression}, {\ttfamily Terminatorless}


\begin{DoxyItemize}
\item {\ttfamily argument}\+: {\ttfamily Expression} (default\+: {\ttfamily null})
\item {\ttfamily delegate}\+: {\ttfamily boolean} (default\+: {\ttfamily false}) 

 
\end{DoxyItemize}