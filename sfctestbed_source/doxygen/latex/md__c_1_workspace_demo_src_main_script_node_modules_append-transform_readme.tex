\begin{quote}
Install a transform to {\ttfamily require.\+extensions} that always runs last, even if additional extensions are added later. \end{quote}


The \href{https://gist.github.com/jamestalmage/df922691475cff66c7e6}{\tt typical require extension} looks something like this\+:


\begin{DoxyCode}
var myTransform = require('my-transform');

var oldExtension = require.extensions['.js'];
require.extensions['.js'] = function (module, filename) \{
  var oldCompile = module.\_compile;
  module.\_compile = function (code, filename) \{
    code = myTransform(code);
    module.\_compile = oldCompile;
    module.\_compile(code, filename);
  \};  
  oldExtension(module, filename);
\};
\end{DoxyCode}


In {\bfseries almost} all cases, that is sufficient and is the method that should be used (check out \href{https://www.npmjs.com/package/pirates}{\tt {\ttfamily pirates}} for an easy way to do it correctly). In {\bfseries rare} cases you must ensure your transform remains the last one, even if other transforms are added later. For example, {\ttfamily nyc} uses this module to ensure its transform is applied last so it can capture the final source-\/map information, and ensure any language extensions it can\textquotesingle{}t understand are already transpiled (E\+S2015 via {\ttfamily babel} for instance).

{\itshape W\+A\+R\+N\+I\+NG\+:} You should be sure you {\itshape actually} need this, as it takes control away from the user. Your transform remains the last one applied, even as users continue to add more transforms. This is potentially confusing. Coverage libraries like {\ttfamily nyc} (and {\ttfamily istanbul} on which it relies) have valid reasons for doing this, but you should prefer conventional transform installation via \href{https://www.npmjs.com/package/pirates}{\tt {\ttfamily pirates}}.

References\+:
\begin{DoxyItemize}
\item \href{https://gist.github.com/jamestalmage/df922691475cff66c7e6}{\tt Detailed Breakdown of How Require Extensions Work}
\item The \href{https://github.com/jamestalmage/append-transform/blob/master/test/execution-order.js}{\tt test suite} provides a good overview of how this library manipulates the order in which transforms are applied.
\end{DoxyItemize}

\subsection*{Install}


\begin{DoxyCode}
$ npm install --save append-transform
\end{DoxyCode}


\subsection*{Usage}


\begin{DoxyCode}
var appendTransform = require('append-transform');
var myTransform = require('my-transform');

appendTransform(function (code, filename) \{
  if (myTransform.shouldTransform(filename)) \{
    code = myTransform.transform(code);
  \}
  return code;
\});
\end{DoxyCode}


\subsection*{A\+PI}

\subsubsection*{append\+Transform(transform\+Fn, \mbox{[}extension\mbox{]})}

\paragraph*{transform\+Fn}

Type\+: {\ttfamily function(code\+: string, filename\+: string)} ~\newline
$\ast$\+Required$\ast$

A callback that modifies the incoming {\ttfamily code} argument in some way, and returns the transformed result. {\ttfamily filename} is provided to filter which files the transform applies to. If a transform should not manipulate a particular file, just return {\ttfamily code} without modifying it. It is fairly common to avoid transforming files in {\ttfamily node\+\_\+modules}. In that case you may want to use \href{https://www.npmjs.com/package/node-modules-regexp}{\tt {\ttfamily node-\/modules-\/regexp}} to help reliably detect {\ttfamily node\+\_\+modules} paths and avoid transforming them.

\paragraph*{extension}

Type\+: {\ttfamily string} ~\newline
Default\+: {\ttfamily \char`\"{}.\+js\char`\"{}}

The extension for the types of files this transform is capable of handling.

\subsection*{License}

M\+IT Â© \href{http://github.com/jamestalmage}{\tt James Talmage} 