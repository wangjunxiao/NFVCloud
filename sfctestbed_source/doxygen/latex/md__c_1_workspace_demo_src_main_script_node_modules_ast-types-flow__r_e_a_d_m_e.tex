Flow types for the Javascript A\+ST. Based off of \href{https://github.com/benjamn/ast-types}{\tt benjamn/ast-\/types}.

\subsection*{Usage}

First install {\ttfamily ast-\/types-\/flow} via npm, then you can import any of the types that are exported.


\begin{DoxyCode}
/* @flow */

import type \{Node\} from 'ast-types-flow';

function getName(node: Node): string \{
  switch (node.type) \{
    case 'Identifier':
      return node.name;

    case 'ClassDeclaration':
      return node.id.name; // Error, id could be null.

    case 'FunctionDeclaration':
      return node.id.name; // Fine if it's always there.

    case 'FunctionExpression':
      if (node.id) \{
        return node.id.name; // Can refine id to make sure it exists.
      \} else \{
        return 'Unknown';
      \}

    case 'Literal':
      return node.name; // Error, Literals don't have names, don't be silly.
  \}
  return 'Unknown';
\}
\end{DoxyCode}


\subsection*{How it works}

A notion of \char`\"{}extends\char`\"{} is added to the Flow syntax via comments. A transform is included that will compile the source code into useful disjoint union types based on how the different types extend each other. For example\+:


\begin{DoxyCode}
type Node = \{
  common: string,
\};

type Foo = \{
  // extends Node
  foo: string,
\};

type Bar = \{
  // extends Node
  bar: number,
\};
\end{DoxyCode}


Will be transformed into\+:


\begin{DoxyCode}
type Node = \{
  type: 'Foo',
  \_Foo: void,
  common: string,
  foo: string,
\} | \{
  type: 'Bar',
  \_Bar: void,
  common: string,
  bar: number,
\};

type Foo = \{
  type: 'Foo',
  \_Foo: void,
  common: string,
  foo: string,
\};

type Bar = \{
  type: 'Bar',
  \_Foo: void,
  common: string,
  bar: number,
\};
\end{DoxyCode}


A few things to note\+:


\begin{DoxyEnumerate}
\item The type {\ttfamily Node} would more ideally be compiled into {\ttfamily Foo $\vert$ Bar} but then the disjoint union cannot be properly refined. For now we have to duplicate the complete definitions.
\item Each entry in a disjoint union has to be structurally unique or Flow will have an error on the definition. That is why the private {\ttfamily \+\_\+\+Foo\+: void} fields appear in the types. 
\end{DoxyEnumerate}