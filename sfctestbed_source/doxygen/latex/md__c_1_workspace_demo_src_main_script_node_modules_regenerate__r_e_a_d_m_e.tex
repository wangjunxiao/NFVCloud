{\itshape Regenerate} is a Unicode-\/aware regex generator for Java\+Script. It allows you to easily generate E\+S5-\/compatible regular expressions based on a given set of Unicode symbols or code points. (This is trickier than you might think, because of \href{https://mathiasbynens.be/notes/javascript-unicode}{\tt how Java\+Script deals with astral symbols}.)

\subsection*{Installation}

Via \href{https://npmjs.org/}{\tt npm}\+:


\begin{DoxyCode}
npm install regenerate
\end{DoxyCode}


Via \href{http://bower.io/}{\tt Bower}\+:


\begin{DoxyCode}
bower install regenerate
\end{DoxyCode}


Via \href{https://github.com/component/component}{\tt Component}\+:


\begin{DoxyCode}
component install mathiasbynens/regenerate
\end{DoxyCode}


In a browser\+:


\begin{DoxyCode}
<script src="regenerate.js"></script>
\end{DoxyCode}


In \href{https://nodejs.org/}{\tt Node.\+js}, \href{https://iojs.org/}{\tt io.\+js}, and \href{http://ringojs.org/}{\tt Ringo\+JS ≥ v0.\+8.\+0}\+:


\begin{DoxyCode}
var regenerate = require('regenerate');
\end{DoxyCode}


In \href{http://narwhaljs.org/}{\tt Narwhal} and \href{http://ringojs.org/}{\tt Ringo\+JS ≤ v0.\+7.\+0}\+:


\begin{DoxyCode}
var regenerate = require('regenerate').regenerate;
\end{DoxyCode}


In \href{http://www.mozilla.org/rhino/}{\tt Rhino}\+:


\begin{DoxyCode}
load('regenerate.js');
\end{DoxyCode}


Using an A\+MD loader like \href{http://requirejs.org/}{\tt Require\+JS}\+:


\begin{DoxyCode}
require(
  \{
    'paths': \{
      'regenerate': 'path/to/regenerate'
    \}
  \},
  ['regenerate'],
  function(regenerate) \{
    console.log(regenerate);
  \}
);
\end{DoxyCode}


\subsection*{A\+PI}

\subsubsection*{{\ttfamily regenerate(value1, value2, value3, ...)}}

The main Regenerate function. Calling this function creates a new set that gets a chainable A\+PI.


\begin{DoxyCode}
var set = regenerate()
  .addRange(0x60, 0x69) // add U+0060 to U+0069
  .remove(0x62, 0x64) // remove U+0062 and U+0064
  .add(0x1D306); // add U+1D306
set.valueOf();
// → [0x60, 0x61, 0x63, 0x65, 0x66, 0x67, 0x68, 0x69, 0x1D306]
set.toString();
// → '[`ace-i]|\(\backslash\)\(\backslash\)uD834\(\backslash\)\(\backslash\)uDF06'
set.toRegExp();
// → /[`ace-i]|\(\backslash\)uD834\(\backslash\)uDF06/
\end{DoxyCode}


Any arguments passed to {\ttfamily regenerate()} will be added to the set right away. Both code points (numbers) and symbols (strings consisting of a single Unicode symbol) are accepted, as well as arrays containing values of these types.


\begin{DoxyCode}
regenerate(0x1D306, 'A', '©', 0x2603).toString();
// → '[A\(\backslash\)\(\backslash\)xA9\(\backslash\)\(\backslash\)u2603]|\(\backslash\)\(\backslash\)uD834\(\backslash\)\(\backslash\)uDF06'

var items = [0x1D306, 'A', '©', 0x2603];
regenerate(items).toString();
// → '[A\(\backslash\)\(\backslash\)xA9\(\backslash\)\(\backslash\)u2603]|\(\backslash\)\(\backslash\)uD834\(\backslash\)\(\backslash\)uDF06'
\end{DoxyCode}


\subsubsection*{{\ttfamily regenerate.\+prototype.\+add(value1, value2, value3, ...)}}

Any arguments passed to {\ttfamily add()} are added to the set. Both code points (numbers) and symbols (strings consisting of a single Unicode symbol) are accepted, as well as arrays containing values of these types.


\begin{DoxyCode}
regenerate().add(0x1D306, 'A', '©', 0x2603).toString();
// → '[A\(\backslash\)\(\backslash\)xA9\(\backslash\)\(\backslash\)u2603]|\(\backslash\)\(\backslash\)uD834\(\backslash\)\(\backslash\)uDF06'

var items = [0x1D306, 'A', '©', 0x2603];
regenerate().add(items).toString();
// → '[A\(\backslash\)\(\backslash\)xA9\(\backslash\)\(\backslash\)u2603]|\(\backslash\)\(\backslash\)uD834\(\backslash\)\(\backslash\)uDF06'
\end{DoxyCode}


It’s also possible to pass in a Regenerate instance. Doing so adds all code points in that instance to the current set.


\begin{DoxyCode}
var set = regenerate(0x1D306, 'A');
regenerate().add('©', 0x2603).add(set).toString();
// → '[A\(\backslash\)\(\backslash\)xA9\(\backslash\)\(\backslash\)u2603]|\(\backslash\)\(\backslash\)uD834\(\backslash\)\(\backslash\)uDF06'
\end{DoxyCode}


Note that the initial call to {\ttfamily regenerate()} acts like {\ttfamily add()}. This allows you to create a new Regenerate instance and add some code points to it in one go\+:


\begin{DoxyCode}
regenerate(0x1D306, 'A', '©', 0x2603).toString();
// → '[A\(\backslash\)\(\backslash\)xA9\(\backslash\)\(\backslash\)u2603]|\(\backslash\)\(\backslash\)uD834\(\backslash\)\(\backslash\)uDF06'
\end{DoxyCode}


\subsubsection*{{\ttfamily regenerate.\+prototype.\+remove(value1, value2, value3, ...)}}

Any arguments passed to {\ttfamily remove()} are removed to the set. Both code points (numbers) and symbols (strings consisting of a single Unicode symbol) are accepted, as well as arrays containing values of these types.


\begin{DoxyCode}
regenerate(0x1D306, 'A', '©', 0x2603).remove('☃').toString();
// → '[A\(\backslash\)\(\backslash\)xA9]|\(\backslash\)\(\backslash\)uD834\(\backslash\)\(\backslash\)uDF06'
\end{DoxyCode}


It’s also possible to pass in a Regenerate instance. Doing so removes all code points in that instance from the current set.


\begin{DoxyCode}
var set = regenerate('☃');
regenerate(0x1D306, 'A', '©', 0x2603).remove(set).toString();
// → '[A\(\backslash\)\(\backslash\)xA9]|\(\backslash\)\(\backslash\)uD834\(\backslash\)\(\backslash\)uDF06'
\end{DoxyCode}


\subsubsection*{{\ttfamily regenerate.\+prototype.\+add\+Range(start, end)}}

Adds a range of code points from {\ttfamily start} to {\ttfamily end} (inclusive) to the set. Both code points (numbers) and symbols (strings consisting of a single Unicode symbol) are accepted.


\begin{DoxyCode}
regenerate(0x1D306).addRange(0x00, 0xFF).toString(16);
// → '[\(\backslash\)\(\backslash\)0-\(\backslash\)\(\backslash\)xFF]|\(\backslash\)\(\backslash\)uD834\(\backslash\)\(\backslash\)uDF06'

regenerate().addRange('A', 'z').toString();
// → '[A-z]'
\end{DoxyCode}


\subsubsection*{{\ttfamily regenerate.\+prototype.\+remove\+Range(start, end)}}

Removes a range of code points from {\ttfamily start} to {\ttfamily end} (inclusive) from the set. Both code points (numbers) and symbols (strings consisting of a single Unicode symbol) are accepted.

\`{}\`{}\`{}js regenerate() .add\+Range(0x000000, 0x10\+F\+F\+F\+F) // add all Unicode code points .remove\+Range(\textquotesingle{}A\textquotesingle{}, \textquotesingle{}z\textquotesingle{}) // remove all symbols from {\ttfamily A} to {\ttfamily z} .to\+String(); // → \textquotesingle{}\mbox{[}\textbackslash{}0-\/\textbackslash{}-\/\textbackslash{}u\+D7\+FF\textbackslash{}u\+E000-\/\textbackslash{}u\+F\+F\+FF\mbox{]}$\vert$\mbox{[}\textbackslash{}u\+D800-\/\textbackslash{}u\+D\+B\+FF\mbox{]}\mbox{[}\textbackslash{}u\+D\+C00-\/\textbackslash{}u\+D\+F\+FF\mbox{]}$\vert$\mbox{[}\textbackslash{}u\+D800-\/\textbackslash{}u\+D\+B\+FF\mbox{]}(?!\mbox{[}\textbackslash{}u\+D\+C00-\/\textbackslash{}u\+D\+F\+FF\mbox{]})$\vert$(?\+:\mbox{[}$^\wedge$\textbackslash{}u\+D800-\/\textbackslash{}u\+D\+B\+FF\mbox{]}$\vert$$^\wedge$)\mbox{[}\textbackslash{}u\+D\+C00-\/\textbackslash{}u\+D\+F\+FF\mbox{]}\textquotesingle{}

regenerate() .add\+Range(0x000000, 0x10\+F\+F\+F\+F) // add all Unicode code points .remove\+Range(0x0041, 0x007\+A) // remove all code points from U+0041 to U+007A .to\+String(); // → \textquotesingle{}\mbox{[}\textbackslash{}0-\/\textbackslash{}-\/\textbackslash{}u\+D7\+FF\textbackslash{}u\+E000-\/\textbackslash{}u\+F\+F\+FF\mbox{]}$\vert$\mbox{[}\textbackslash{}u\+D800-\/\textbackslash{}u\+D\+B\+FF\mbox{]}\mbox{[}\textbackslash{}u\+D\+C00-\/\textbackslash{}u\+D\+F\+FF\mbox{]}$\vert$\mbox{[}\textbackslash{}u\+D800-\/\textbackslash{}u\+D\+B\+FF\mbox{]}(?!\mbox{[}\textbackslash{}u\+D\+C00-\/\textbackslash{}u\+D\+F\+FF\mbox{]})$\vert$(?\+:\mbox{[}$^\wedge$\textbackslash{}u\+D800-\/\textbackslash{}u\+D\+B\+FF\mbox{]}$\vert$$^\wedge$)\mbox{[}\textbackslash{}u\+D\+C00-\/\textbackslash{}u\+D\+F\+FF\mbox{]}\textquotesingle{} \`{}\`{}\`{}

\subsubsection*{{\ttfamily regenerate.\+prototype.\+intersection(code\+Points)}}

Removes any code points from the set that are not present in both the set and the given {\ttfamily code\+Points} array. {\ttfamily code\+Points} must be an array of numeric code point values, i.\+e. numbers.


\begin{DoxyCode}
regenerate()
  .addRange(0x00, 0xFF) // add extended ASCII code points
  .intersection([0x61, 0x69]) // remove all code points from the set except for these
  .toString();
// → '[ai]'
\end{DoxyCode}


Instead of the {\ttfamily code\+Points} array, it’s also possible to pass in a Regenerate instance.


\begin{DoxyCode}
var whitelist = regenerate(0x61, 0x69);

regenerate()
  .addRange(0x00, 0xFF) // add extended ASCII code points
  .intersection(whitelist) // remove all code points from the set except for those in the `whitelist` set
  .toString();
// → '[ai]'
\end{DoxyCode}


\subsubsection*{{\ttfamily regenerate.\+prototype.\+contains(value)}}

Returns {\ttfamily true} if the given value is part of the set, and {\ttfamily false} otherwise. Both code points (numbers) and symbols (strings consisting of a single Unicode symbol) are accepted.


\begin{DoxyCode}
var set = regenerate().addRange(0x00, 0xFF);
set.contains('A');
// → true
set.contains(0x1D306);
// → false
\end{DoxyCode}


\subsubsection*{{\ttfamily regenerate.\+prototype.\+clone()}}

Returns a clone of the current code point set. Any actions performed on the clone won’t mutate the original set.


\begin{DoxyCode}
var setA = regenerate(0x1D306);
var setB = setA.clone().add(0x1F4A9);
setA.toArray();
// → [0x1D306]
setB.toArray();
// → [0x1D306, 0x1F4A9]
\end{DoxyCode}


\subsubsection*{{\ttfamily regenerate.\+prototype.\+to\+String(options)}}

Returns a string representing (part of) a regular expression that matches all the symbols mapped to the code points within the set.


\begin{DoxyCode}
regenerate(0x1D306, 0x1F4A9).toString();
// → '\(\backslash\)\(\backslash\)uD834\(\backslash\)\(\backslash\)uDF06|\(\backslash\)\(\backslash\)uD83D\(\backslash\)\(\backslash\)uDCA9'
\end{DoxyCode}


If the {\ttfamily bmp\+Only} property of the optional {\ttfamily options} object is set to {\ttfamily true}, the output matches surrogates individually, regardless of whether they’re lone surrogates or just part of a surrogate pair. This simplifies the output, but it can only be used in case you’re certain the strings it will be used on don’t contain any astral symbols.


\begin{DoxyCode}
var highSurrogates = regenerate().addRange(0xD800, 0xDBFF);
highSurrogates.toString();
// → '[\(\backslash\)\(\backslash\)uD800-\(\backslash\)\(\backslash\)uDBFF](?![\(\backslash\)\(\backslash\)uDC00-\(\backslash\)\(\backslash\)uDFFF])'
highSurrogates.toString(\{ 'bmpOnly': true \});
// → '[\(\backslash\)\(\backslash\)uD800-\(\backslash\)\(\backslash\)uDBFF]'

var lowSurrogates = regenerate().addRange(0xDC00, 0xDFFF);
lowSurrogates.toString();
// → '(?:[^\(\backslash\)\(\backslash\)uD800-\(\backslash\)\(\backslash\)uDBFF]|^)[\(\backslash\)\(\backslash\)uDC00-\(\backslash\)\(\backslash\)uDFFF]'
lowSurrogates.toString(\{ 'bmpOnly': true \});
// → '[\(\backslash\)\(\backslash\)uDC00-\(\backslash\)\(\backslash\)uDFFF]'
\end{DoxyCode}


Note that lone low surrogates cannot be matched accurately using regular expressions in Java\+Script. Regenerate’s output makes a best-\/effort approach but \href{https://github.com/mathiasbynens/regenerate/issues/28#issuecomment-72224808}{\tt there can be false negatives in this regard}.

If the {\ttfamily has\+Unicode\+Flag} property of the optional {\ttfamily options} object is set to {\ttfamily true}, the output makes use of Unicode code point escapes ({\ttfamily \textbackslash{}u\{…\}}) where applicable. This simplifies the output at the cost of compatibility and portability, since it means the output can only be used as a pattern in a regular expression with \href{https://mathiasbynens.be/notes/es6-unicode-regex}{\tt the E\+S6 {\ttfamily u} flag} enabled.


\begin{DoxyCode}
var set = regenerate().addRange(0x0, 0x10FFFF);

set.toString();
// →
       '[\(\backslash\)\(\backslash\)0-\(\backslash\)\(\backslash\)uD7FF\(\backslash\)\(\backslash\)uE000-\(\backslash\)\(\backslash\)uFFFF]|[\(\backslash\)\(\backslash\)uD800-\(\backslash\)\(\backslash\)uDBFF][\(\backslash\)\(\backslash\)uDC00-\(\backslash\)\(\backslash\)uDFFF]|[\(\backslash\)\(\backslash\)uD800-\(\backslash\)\(\backslash\)uDBFF](?![\(\backslash\)\(\backslash\)uDC00-\(\backslash\)\(\backslash\)uDFFF])|(?:[^\(\backslash\)\(\backslash\)uD800-\(\backslash\)\(\backslash\)uDBFF]|^)[\(\backslash\)\(\backslash\)uDC00-\(\backslash\)\(\backslash\)uDFFF]''

set.toString(\{ 'hasUnicodeFlag': true \});
// → '[\(\backslash\)\(\backslash\)0-\(\backslash\)\(\backslash\)u\{10FFFF\}]'
\end{DoxyCode}


\subsubsection*{`regenerate.\+prototype.\+to\+Reg\+Exp(flags = '\textquotesingle{})\`{}}

Returns a regular expression that matches all the symbols mapped to the code points within the set. Optionally, you can pass \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#Parameters}{\tt flags} to be added to the regular expression.


\begin{DoxyCode}
var regex = regenerate(0x1D306, 0x1F4A9).toRegExp();
// → /\(\backslash\)uD834\(\backslash\)uDF06|\(\backslash\)uD83D\(\backslash\)uDCA9/
regex.test('𝌆');
// → true
regex.test('A');
// → false

// With flags:
var regex = regenerate(0x1D306, 0x1F4A9).toRegExp('g');
// → /\(\backslash\)uD834\(\backslash\)uDF06|\(\backslash\)uD83D\(\backslash\)uDCA9/g
\end{DoxyCode}


{\bfseries Note\+:} This probably shouldn’t be used. Regenerate is intended as a tool that is used as part of a build process, not at runtime.

\subsubsection*{{\ttfamily regenerate.\+prototype.\+value\+Of()} or {\ttfamily regenerate.\+prototype.\+to\+Array()}}

Returns a sorted array of unique code points in the set.


\begin{DoxyCode}
regenerate(0x1D306)
  .addRange(0x60, 0x65)
  .add(0x59, 0x60) // note: 0x59 is added after 0x65, and 0x60 is a duplicate
  .valueOf();
// → [0x59, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x1D306]
\end{DoxyCode}


\subsubsection*{{\ttfamily regenerate.\+version}}

A string representing the semantic version number.

\subsection*{Combine Regenerate with other libraries}

Regenerate gets even better when combined with other libraries such as \href{https://mths.be/punycode}{\tt Punycode.\+js}. Here’s an example where \href{https://mths.be/punycode}{\tt Punycode.\+js} is used to convert a string into an array of code points, that is then passed on to Regenerate\+:


\begin{DoxyCode}
var regenerate = require('regenerate');
var punycode = require('punycode');

var string = 'Lorem ipsum dolor sit amet.';
// Get an array of all code points used in the string:
var codePoints = punycode.ucs2.decode(string);

// Generate a regular expression that matches any of the symbols used in the string:
regenerate(codePoints).toString();
// → '[ \(\backslash\)\(\backslash\).Ladeilmopr-u]'
\end{DoxyCode}


In E\+S6 you can do something similar with \href{https://mths.be/array-from}{\tt {\ttfamily Array.\+from}} which uses \href{https://mathiasbynens.be/notes/javascript-unicode#iterating-over-symbols}{\tt the string’s iterator} to split the given string into an array of strings that each contain a single symbol. \href{#regenerateprototypeaddvalue1-value2-value3-}{\tt {\ttfamily regenerate()}} accepts both strings and code points, remember?


\begin{DoxyCode}
var regenerate = require('regenerate');

var string = 'Lorem ipsum dolor sit amet.';
// Get an array of all symbols used in the string:
var symbols = Array.from(string);

// Generate a regular expression that matches any of the symbols used in the string:
regenerate(symbols).toString();
// → '[ \(\backslash\)\(\backslash\).Ladeilmopr-u]'
\end{DoxyCode}


\subsection*{Support}

Regenerate supports at least Chrome 27+, Firefox 3+, Safari 4+, Opera 10+, IE 6+, Node.\+js v0.\+10.\+0+, io.\+js v1.\+0.\+0+, Narwhal 0.\+3.\+2+, Ringo\+JS 0.\+8+, Phantom\+JS 1.\+9.\+0+, and Rhino 1.\+7\+R\+C4+.

\subsection*{Unit tests \& code coverage}

After cloning this repository, run {\ttfamily npm install} to install the dependencies needed for Regenerate development and testing. You may want to install Istanbul {\itshape globally} using {\ttfamily npm install istanbul -\/g}.

Once that’s done, you can run the unit tests in Node using {\ttfamily npm test} or {\ttfamily node tests/tests.\+js}. To run the tests in Rhino, Ringo, Narwhal, and web browsers as well, use {\ttfamily grunt test}.

To generate the code coverage report, use {\ttfamily grunt cover}.

\subsection*{Author}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{1}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ \mbox{[}!   }\\\cline{1-1}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ \mbox{[}!   }\\\cline{1-1}
\endhead
\href{https://mathiasbynens.be/}{\tt Mathias Bynens}   \\\cline{1-1}
\end{longtabu}


\subsection*{License}

Regenerate is available under the \href{https://mths.be/mit}{\tt M\+IT} license. 