B\+S\+ER is a binary serialization scheme that can be used as an alternative to J\+S\+ON. B\+S\+ER uses a framed encoding that makes it simpler to use to stream a sequence of encoded values.

It is intended to be used for local-\/\+I\+PC only and strings are represented as binary with no specific encoding; this matches the convention employed by most operating system filename storage.

For more details about the serialization scheme see \href{https://facebook.github.io/watchman/docs/bser.html}{\tt Watchman\textquotesingle{}s docs}.

\subsection*{A\+PI}


\begin{DoxyCode}
var bser = require('bser');
\end{DoxyCode}


\subsubsection*{bser.\+load\+From\+Buffer}

The is the synchronous decoder; given an input string or buffer, decodes a single value and returns it. Throws an error if the input is invalid.


\begin{DoxyCode}
var obj = bser.loadFromBuffer(buf);
\end{DoxyCode}


\subsubsection*{bser.\+dump\+To\+Buffer}

Synchronously encodes a value as B\+S\+ER.


\begin{DoxyCode}
var encoded = bser.dumpToBuffer(['hello']);
console.log(bser.loadFromBuffer(encoded)); // ['hello']
\end{DoxyCode}


\subsubsection*{Bunser\+Buf}

The asynchronous decoder A\+PI is implemented in the Bunser\+Buf object. You may incrementally append data to this object and it will emit the decoded values via its {\ttfamily value} event.


\begin{DoxyCode}
var bunser = new bser.BunserBuf();

bunser.on('value', function(obj) \{
  console.log(obj);
\});
\end{DoxyCode}


Then in your socket {\ttfamily data} event\+:


\begin{DoxyCode}
bunser.append(buf);
\end{DoxyCode}


\subsection*{Example}

Read B\+S\+ER from socket\+:


\begin{DoxyCode}
var bunser = new bser.BunserBuf();

bunser.on('value', function(obj) \{
  console.log('data from socket', obj);
\});

var socket = net.connect('/socket');

socket.on('data', function(buf) \{
  bunser.append(buf);
\});
\end{DoxyCode}


Write B\+S\+ER to socket\+:


\begin{DoxyCode}
socket.write(bser.dumpToBuffer(obj));
\end{DoxyCode}
 