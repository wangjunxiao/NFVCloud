A regex that tokenizes Java\+Script.


\begin{DoxyCode}
var jsTokens = require("js-tokens").default

var jsString = "var foo=opts.foo;\(\backslash\)n..."

jsString.match(jsTokens)
// ["var", " ", "foo", "=", "opts", ".", "foo", ";", "\(\backslash\)n", ...]
\end{DoxyCode}


\section*{Installation }

{\ttfamily npm install js-\/tokens}


\begin{DoxyCode}
import jsTokens from "js-tokens"
// or:
var jsTokens = require("js-tokens").default
\end{DoxyCode}


\section*{Usage }

\subsubsection*{{\ttfamily js\+Tokens}}

A regex with the {\ttfamily g} flag that matches Java\+Script tokens.

The regex {\itshape always} matches, even invalid Java\+Script and the empty string.

The next match is always directly after the previous.

\subsubsection*{{\ttfamily var token = match\+To\+Token(match)}}


\begin{DoxyCode}
import \{matchToToken\} from "js-tokens"
// or:
var matchToToken = require("js-tokens").matchToToken
\end{DoxyCode}


Takes a {\ttfamily match} returned by {\ttfamily js\+Tokens.\+exec(string)}, and returns a {\ttfamily \{type\+: String, value\+: String\}} object. The following types are available\+:


\begin{DoxyItemize}
\item string
\item comment
\item regex
\item number
\item name
\item punctuator
\item whitespace
\item invalid
\end{DoxyItemize}

Multi-\/line comments and strings also have a {\ttfamily closed} property indicating if the token was closed or not (see below).

Comments and strings both come in several flavors. To distinguish them, check if the token starts with {\ttfamily //}, {\ttfamily /$\ast$}, `'{\ttfamily ,}"{\ttfamily or} \`{}\`{}.

Names are E\+C\+M\+A\+Script Identifier\+Names, that is, including both identifiers and keywords. You may use \href{https://github.com/crissdev/is-keyword-js}{\tt is-\/keyword-\/js} to tell them apart.

Whitespace includes both line terminators and other whitespace.

\section*{E\+C\+M\+A\+Script support }

The intention is to always support the latest stable E\+C\+M\+A\+Script version.

If adding support for a newer version requires changes, a new version with a major verion bump will be released.

Currently, \href{https://www.ecma-international.org/ecma-262/8.0/index.html}{\tt E\+C\+M\+A\+Script 2017} is supported.

\section*{Invalid code handling }

Unterminated strings are still matched as strings. Java\+Script strings cannot contain (unescaped) newlines, so unterminated strings simply end at the end of the line. Unterminated template strings can contain unescaped newlines, though, so they go on to the end of input.

Unterminated multi-\/line comments are also still matched as comments. They simply go on to the end of the input.

Unterminated regex literals are likely matched as division and whatever is inside the regex.

Invalid A\+S\+C\+II characters have their own capturing group.

Invalid non-\/\+A\+S\+C\+II characters are treated as names, to simplify the matching of names (except unicode spaces which are treated as whitespace).

Regex literals may contain invalid regex syntax. They are still matched as regex literals. They may also contain repeated regex flags, to keep the regex simple.

Strings may contain invalid escape sequences.

\section*{Limitations }

Tokenizing Java\+Script using regexes—in fact, \+\_\+one single regex\+\_\+—won’t be perfect. But that’s not the point either.

You may compare js\+Tokens with \href{http://esprima.org/}{\tt esprima} by using {\ttfamily esprima-\/compare.\+js}. See {\ttfamily npm run esprima-\/compare}!

\subsubsection*{Template string interpolation}

Template strings are matched as single tokens, from the starting {\ttfamily \`{}} to the ending {\ttfamily \`{}}, including interpolations (whose tokens are not matched individually).

Matching template string interpolations requires recursive balancing of {\ttfamily \{} and {\ttfamily \}}—something that Java\+Script regexes cannot do. Only one level of nesting is supported.

\subsubsection*{Division and regex literals collision}

Consider this example\+:


\begin{DoxyCode}
var g = 9.82
var number = bar / 2/g

var regex = / 2/g
\end{DoxyCode}


A human can easily understand that in the {\ttfamily number} line we’re dealing with division, and in the {\ttfamily regex} line we’re dealing with a regex literal. How come? Because humans can look at the whole code to put the {\ttfamily /} characters in context. A Java\+Script regex cannot. It only sees forwards.

When the {\ttfamily js\+Tokens} regex scans throught the above, it will see the following at the end of both the {\ttfamily number} and {\ttfamily regex} rows\+:


\begin{DoxyCode}
/ 2/g
\end{DoxyCode}


It is then impossible to know if that is a regex literal, or part of an expression dealing with division.

Here is a similar case\+:


\begin{DoxyCode}
foo /= 2/g
foo(/= 2/g)
\end{DoxyCode}


The first line divides the {\ttfamily foo} variable with {\ttfamily 2/g}. The second line calls the {\ttfamily foo} function with the regex literal {\ttfamily /= 2/g}. Again, since {\ttfamily js\+Tokens} only sees forwards, it cannot tell the two cases apart.

There are some cases where we {\itshape can} tell division and regex literals apart, though.

First off, we have the simple cases where there’s only one slash in the line\+:


\begin{DoxyCode}
var foo = 2/g
foo /= 2
\end{DoxyCode}


Regex literals cannot contain newlines, so the above cases are correctly identified as division. Things are only problematic when there are more than one non-\/comment slash in a single line.

Secondly, not every character is a valid regex flag.


\begin{DoxyCode}
var number = bar / 2/e
\end{DoxyCode}


The above example is also correctly identified as division, because {\ttfamily e} is not a valid regex flag. I initially wanted to future-\/proof by allowing {\ttfamily \mbox{[}a-\/z\+A-\/Z\mbox{]}$\ast$} (any letter) as flags, but it is not worth it since it increases the amount of ambigous cases. So only the standard {\ttfamily g}, {\ttfamily m}, {\ttfamily i}, {\ttfamily y} and {\ttfamily u} flags are allowed. This means that the above example will be identified as division as long as you don’t rename the {\ttfamily e} variable to some permutation of {\ttfamily gmiyu} 1 to 5 characters long.

Lastly, we can look {\itshape forward} for information.


\begin{DoxyItemize}
\item If the token following what looks like a regex literal is not valid after a regex literal, but is valid in a division expression, then the regex literal is treated as division instead. For example, a flagless regex cannot be followed by a string, number or name, but all of those three can be the denominator of a division.
\item Generally, if what looks like a regex literal is followed by an operator, the regex literal is treated as division instead. This is because regexes are seldomly used with operators (such as {\ttfamily +}, {\ttfamily $\ast$}, {\ttfamily \&\&} and {\ttfamily ==}), but division could likely be part of such an expression.
\end{DoxyItemize}

Please consult the regex source and the test cases for precise information on when regex or division is matched (should you need to know). In short, you could sum it up as\+:

If the end of a statement looks like a regex literal (even if it isn’t), it will be treated as one. Otherwise it should work as expected (if you write sane code).

\section*{License }

\mbox{[}M\+IT\mbox{]}(L\+I\+C\+E\+N\+SE). 