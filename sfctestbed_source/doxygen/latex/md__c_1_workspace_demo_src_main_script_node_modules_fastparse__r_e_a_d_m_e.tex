A very simple and stupid parser, based on a statemachine and regular expressions.

It\textquotesingle{}s not intended for complex languages. It\textquotesingle{}s intended to easily write a simple parser for a simple language.

\subsection*{Usage}

Pass a description of statemachine to the constructor. The description must be in this form\+:


\begin{DoxyCode}
new Parser(description)

description is \{
    // The key is the name of the state
    // The value is an object containing possible transitions
    "state-name": \{
        // The key is a regular expression
        // If the regular expression matches the transition is executed
        // The value can be "true", a other state name or a function

        "a": true,
        // true will make the parser stay in the current state

        "b": "other-state-name",
        // a string will make the parser transit to a new state

        "[cde]": function(match, index, matchLength) \{
            // "match" will be the matched string
            // "index" will be the position in the complete string
            // "matchLength" will be "match.length"

            // "this" will be the "context" passed to the "parse" method"

            // A new state name (string) can be returned
            return "other-state-name";
        \},

        "([0-9]+)(\(\backslash\)\(\backslash\).[0-9]+)?": function(match, first, second, index, matchLength) \{
            // groups can be used in the regular expression
            // they will match to arguments "first", "second"
        \},

        // the parser stops when it cannot match the string anymore

        // order of keys is the order in which regular expressions are matched
        // if the javascript runtime preserves the order of keys in an object
        // (this is not standardized, but it's a de-facto standard)
    \}
\}
\end{DoxyCode}


The statemachine is compiled down to a single regular expression per state. So basically the parsing work is delegated to the (native) regular expression logic of the javascript runtime.


\begin{DoxyCode}
Parser.prototype.parse(initialState: String, parsedString: String, context: Object)
\end{DoxyCode}


{\ttfamily initial\+State}\+: state where the parser starts to parse.

{\ttfamily parsed\+String}\+: the string which should be parsed.

{\ttfamily context}\+: an object which can be used to save state and results. Available as {\ttfamily this} in transition functions.

returns {\ttfamily context}

\subsection*{Example}


\begin{DoxyCode}
var Parser = require("fastparse");

// A simple parser that extracts @licence ... from comments in a JS file
var parser = new Parser(\{
    // The "source" state
    "source": \{
        // matches comment start
        "/\(\backslash\)\(\backslash\)*": "comment",
        "//": "linecomment",

        // this would be necessary for a complex language like JS
        // but omitted here for simplicity
        // "\(\backslash\)"": "string1",
        // "\(\backslash\)'": "string2",
        // "\(\backslash\)/": "regexp"

    \},
    // The "comment" state
    "comment": \{
        "\(\backslash\)\(\backslash\)*/": "source",
        "@licen[cs]e\(\backslash\)\(\backslash\)s((?:[^*\(\backslash\)n]|\(\backslash\)\(\backslash\)*+[^*/\(\backslash\)n])*)": function(match, licenseText) \{
            this.licences.push(licenseText.trim());
        \}
    \},
    // The "linecomment" state
    "linecomment": \{
        "\(\backslash\)n": "source",
        "@licen[cs]e\(\backslash\)\(\backslash\)s(.*)": function(match, licenseText) \{
            this.licences.push(licenseText.trim());
        \}
    \}
\});

var licences = parser.parse("source", sourceCode, \{ licences: [] \}).licences;

console.log(licences);
\end{DoxyCode}


\subsection*{License}

M\+IT (\href{http://www.opensource.org/licenses/mit-license.php}{\tt http\+://www.\+opensource.\+org/licenses/mit-\/license.\+php}) 