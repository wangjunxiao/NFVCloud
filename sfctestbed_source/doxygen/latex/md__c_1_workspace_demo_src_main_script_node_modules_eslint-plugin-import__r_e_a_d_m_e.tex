\href{https://travis-ci.org/benmosher/eslint-plugin-import}{\tt } \href{https://coveralls.io/github/benmosher/eslint-plugin-import?branch=master}{\tt } \href{https://ci.appveyor.com/project/benmosher/eslint-plugin-import/branch/master}{\tt } \href{https://www.npmjs.com/package/eslint-plugin-import}{\tt } \href{http://www.npmtrends.com/eslint-plugin-import}{\tt }

This plugin intends to support linting of E\+S2015+ (E\+S6+) import/export syntax, and prevent issues with misspelling of file paths and import names. All the goodness that the E\+S2015+ static module syntax intends to provide, marked up in your editor.

{\bfseries IF Y\+OU A\+RE U\+S\+I\+NG T\+H\+IS W\+I\+TH S\+U\+B\+L\+I\+ME}\+: see the \href{#sublimelinter-eslint}{\tt bottom section} for important info.

\subsection*{Rules}

{\bfseries Static analysis\+:}


\begin{DoxyItemize}
\item Ensure imports point to a file/module that can be resolved. (./docs/rules/no-\/unresolved.md \char`\"{}\`{}no-\/unresolved\`{}\char`\"{})
\item Ensure named imports correspond to a named export in the remote file. (./docs/rules/named.md \char`\"{}\`{}named\`{}\char`\"{})
\item Ensure a default export is present, given a default import. (./docs/rules/default.md \char`\"{}\`{}default\`{}\char`\"{})
\item Ensure imported namespaces contain dereferenced properties as they are dereferenced. (./docs/rules/namespace.md \char`\"{}\`{}namespace\`{}\char`\"{})
\item Restrict which files can be imported in a given folder (./docs/rules/no-\/restricted-\/paths.md \char`\"{}\`{}no-\/restricted-\/paths\`{}\char`\"{})
\item Forbid import of modules using absolute paths (./docs/rules/no-\/absolute-\/path.md \char`\"{}\`{}no-\/absolute-\/path\`{}\char`\"{})
\item Forbid {\ttfamily require()} calls with expressions (./docs/rules/no-\/dynamic-\/require.md \char`\"{}\`{}no-\/dynamic-\/require\`{}\char`\"{})
\item Prevent importing the submodules of other modules (./docs/rules/no-\/internal-\/modules.md \char`\"{}\`{}no-\/internal-\/modules\`{}\char`\"{})
\item Forbid Webpack loader syntax in imports (./docs/rules/no-\/webpack-\/loader-\/syntax.md \char`\"{}\`{}no-\/webpack-\/loader-\/syntax\`{}\char`\"{})
\end{DoxyItemize}

{\bfseries Helpful warnings\+:}


\begin{DoxyItemize}
\item Report any invalid exports, i.\+e. re-\/export of the same name (./docs/rules/export.md \char`\"{}\`{}export\`{}\char`\"{})
\item Report use of exported name as identifier of default export (./docs/rules/no-\/named-\/as-\/default.md \char`\"{}\`{}no-\/named-\/as-\/default\`{}\char`\"{})
\item Report use of exported name as property of default export (./docs/rules/no-\/named-\/as-\/default-\/member.md \char`\"{}\`{}no-\/named-\/as-\/default-\/member\`{}\char`\"{})
\item Report imported names marked with \`{}\begin{DoxyRefDesc}{弃用}
\item[\mbox{\hyperlink{deprecated__deprecated000001}{弃用}}]{\ttfamily documentation tag (\mbox{[}}no-\/deprecated{\ttfamily \mbox{]})}\end{DoxyRefDesc}

\end{DoxyItemize}

{\bfseries Module systems\+:}


\begin{DoxyItemize}
\item Report potentially ambiguous parse goal ({\ttfamily script} vs. {\ttfamily module}) (./docs/rules/unambiguous.md \char`\"{}\`{}unambiguous\`{}\char`\"{})
\item Report Common\+JS {\ttfamily require} calls and {\ttfamily module.\+exports} or {\ttfamily exports.$\ast$}. (./docs/rules/no-\/commonjs.md \char`\"{}\`{}no-\/commonjs\`{}\char`\"{})
\item Report A\+MD {\ttfamily require} and {\ttfamily define} calls. (./docs/rules/no-\/amd.md \char`\"{}\`{}no-\/amd\`{}\char`\"{})
\item No Node.\+js builtin modules. (./docs/rules/no-\/nodejs-\/modules.md \char`\"{}\`{}no-\/nodejs-\/modules\`{}\char`\"{})
\end{DoxyItemize}

{\bfseries Style guide\+:}


\begin{DoxyItemize}
\item Ensure all imports appear before other statements (./docs/rules/first.md \char`\"{}\`{}first\`{}\char`\"{})
\item Report repeated import of the same module in multiple places (./docs/rules/no-\/duplicates.md \char`\"{}\`{}no-\/duplicates\`{}\char`\"{})
\item Report namespace imports (./docs/rules/no-\/namespace.md \char`\"{}\`{}no-\/namespace\`{}\char`\"{})
\item Ensure consistent use of file extension within the import path (./docs/rules/extensions.md \char`\"{}\`{}extensions\`{}\char`\"{})
\item Enforce a convention in module import order (./docs/rules/order.md \char`\"{}\`{}order\`{}\char`\"{})
\item Enforce a newline after import statements (./docs/rules/newline-\/after-\/import.md \char`\"{}\`{}newline-\/after-\/import\`{}\char`\"{})
\item Prefer a default export if module exports a single name (./docs/rules/prefer-\/default-\/export.md \char`\"{}\`{}prefer-\/default-\/export\`{}\char`\"{})
\item Limit the maximum number of dependencies a module can have (./docs/rules/max-\/dependencies.md \char`\"{}\`{}max-\/dependencies\`{}\char`\"{})
\item Forbid unassigned imports (./docs/rules/no-\/unassigned-\/import.md \char`\"{}\`{}no-\/unassigned-\/import\`{}\char`\"{})
\item Forbid named default exports (./docs/rules/no-\/named-\/default.md \char`\"{}\`{}no-\/named-\/default\`{}\char`\"{})
\end{DoxyItemize}

\subsection*{Installation}


\begin{DoxyCode}
npm install eslint-plugin-import -g
\end{DoxyCode}


or if you manage E\+S\+Lint as a dev dependency\+:


\begin{DoxyCode}
# inside your project's working tree
npm install eslint-plugin-import --save-dev
\end{DoxyCode}


All rules are off by default. However, you may configure them manually in your {\ttfamily .eslintrc.(yml$\vert$json$\vert$js)}, or extend one of the canned configs\+:


\begin{DoxyCode}
---
extends:
  - eslint:recommended
  - plugin:import/errors
  - plugin:import/warnings

# or configure manually:
plugins:
  - import

rules:
  import/no-unresolved: [2, \{commonjs: true, amd: true\}]
  import/named: 2
  import/namespace: 2
  import/default: 2
  import/export: 2
  # etc...
\end{DoxyCode}


\section*{Resolvers}

With the advent of module bundlers and the current state of modules and module syntax specs, it\textquotesingle{}s not always obvious where `import x from \textquotesingle{}module'{\ttfamily should look to find the file behind}module\`{}.

Up through v0.\+10ish, this plugin has directly used substack\textquotesingle{}s \href{https://www.npmjs.com/package/resolve}{\tt {\ttfamily resolve}} plugin, which implements Node\textquotesingle{}s import behavior. This works pretty well in most cases.

However, Webpack allows a number of things in import module source strings that Node does not, such as loaders (`import \textquotesingle{}file!./whatever'{\ttfamily ) and a number of aliasing schemes, such as \mbox{[}}externals\`{}\mbox{]}\+: mapping a module id to a global name at runtime (allowing some modules to be included more traditionally via script tags).

In the interest of supporting both of these, v0.\+11 introduces resolvers.

Currently \href{https://www.npmjs.com/package/eslint-import-resolver-node}{\tt Node} and \href{https://www.npmjs.com/package/eslint-import-resolver-webpack}{\tt Webpack} resolution have been implemented, but the resolvers are just npm packages, so \href{https://github.com/benmosher/eslint-plugin-import/wiki/Resolvers}{\tt third party packages are supported} (and encouraged!).

You can reference resolvers in several ways(in order of precedence)\+:


\begin{DoxyItemize}
\item as a conventional {\ttfamily eslint-\/import-\/resolver} name, like {\ttfamily eslint-\/import-\/resolver-\/foo}\+:
\end{DoxyItemize}


\begin{DoxyCode}
# .eslintrc.yml
settings:
  # uses 'eslint-import-resolver-foo':
  import/resolver: foo
\end{DoxyCode}
 
\begin{DoxyCode}
// .eslintrc.js
module.exports = \{
  settings: \{
    'import/resolver': \{
      foo: \{ someConfig: value \}
    \}
  \}
\}
\end{DoxyCode}



\begin{DoxyItemize}
\item with a full npm module name, like {\ttfamily my-\/awesome-\/npm-\/module}\+:
\end{DoxyItemize}


\begin{DoxyCode}
# .eslintrc.yml
settings:
  import/resolver: 'my-awesome-npm-module'
\end{DoxyCode}
 
\begin{DoxyCode}
// .eslintrc.js
module.exports = \{
  settings: \{
    'import/resolver': \{
      'my-awesome-npm-module': \{ someConfig: value \}
    \}
  \}
\}
\end{DoxyCode}



\begin{DoxyItemize}
\item with a filesystem path to resolver, defined in this example as a {\ttfamily computed property} name\+:
\end{DoxyItemize}


\begin{DoxyCode}
// .eslintrc.js
module.exports = \{
  settings: \{
    'import/resolver': \{
      [path.resolve('../../../my-resolver')]: \{ someConfig: value \}
    \}
  \}
\}
\end{DoxyCode}


Relative paths will be resolved relative to the source\textquotesingle{}s nearest {\ttfamily package.\+json} or the process\textquotesingle{}s current working directory if no {\ttfamily package.\+json} is found.

If you are interesting in writing a resolver, see the ./resolvers/\+R\+E\+A\+D\+ME.md \char`\"{}spec\char`\"{} for more details.

\section*{Settings}

You may set the following settings in your {\ttfamily .eslintrc}\+:

\paragraph*{{\ttfamily import/extensions}}

A list of file extensions that will be parsed as modules and inspected for {\ttfamily export}s.

This defaults to `\mbox{[}'.js\textquotesingle{}\mbox{]}{\ttfamily , unless you are using the}react{\ttfamily shared config, in which case it is specified as}\mbox{[}\textquotesingle{}.js\textquotesingle{}, \textquotesingle{}.jsx\textquotesingle{}\mbox{]}\`{}.

Note that this is different from (and likely a subset of) any {\ttfamily import/resolver} extensions settings, which may include {\ttfamily .json}, {\ttfamily .coffee}, etc. which will still factor into the {\ttfamily no-\/unresolved} rule.

Also, the following {\ttfamily import/ignore} patterns will overrule this list.

\paragraph*{{\ttfamily import/ignore}}

A list of regex strings that, if matched by a path, will not report the matching module if no {\ttfamily export}s are found. In practice, this means rules other than \href{./docs/rules/no-unresolved.md#ignore}{\tt {\ttfamily no-\/unresolved}} will not report on any {\ttfamily import}s with (absolute filesystem) paths matching this pattern.

{\ttfamily no-\/unresolved} has its own \href{./docs/rules/no-unresolved.md#ignore}{\tt {\ttfamily ignore}} setting.


\begin{DoxyCode}
settings:
  import/ignore:
    - \(\backslash\).coffee$          # fraught with parse errors
    - \(\backslash\).(scss|less|css)$ # can't parse unprocessed CSS modules, either
\end{DoxyCode}


\paragraph*{{\ttfamily import/core-\/modules}}

An array of additional modules to consider as \char`\"{}core\char`\"{} modules--modules that should be considered resolved but have no path on the filesystem. Your resolver may already define some of these (for example, the Node resolver knows about {\ttfamily fs} and {\ttfamily path}), so you need not redefine those.

For example, Electron exposes an {\ttfamily electron} module\+:


\begin{DoxyCode}
import 'electron'  // without extra config, will be flagged as unresolved!
\end{DoxyCode}


that would otherwise be unresolved. To avoid this, you may provide {\ttfamily electron} as a core module\+:


\begin{DoxyCode}
# .eslintrc.yml
settings:
  import/core-modules: [ electron ]
\end{DoxyCode}


In Electron\textquotesingle{}s specific case, there is a shared config named {\ttfamily electron} that specifies this for you.

Contribution of more such shared configs for other platforms are welcome!

\paragraph*{{\ttfamily import/external-\/module-\/folders}}

An array of folders. Resolved modules only from those folders will be considered as \char`\"{}external\char`\"{}. By default -\/ {\ttfamily \mbox{[}\char`\"{}node\+\_\+modules\char`\"{}\mbox{]}}. Makes sense if you have configured your path or webpack to handle your internal paths differently and want to considered modules from some folders, for example {\ttfamily bower\+\_\+components} or {\ttfamily jspm\+\_\+modules}, as \char`\"{}external\char`\"{}.

\paragraph*{{\ttfamily import/parsers}}

A map from parsers to file extension arrays. If a file extension is matched, the dependency parser will require and use the map key as the parser instead of the configured E\+S\+Lint parser. This is useful if you\textquotesingle{}re inter-\/op-\/ing with Type\+Script directly using Webpack, for example\+:


\begin{DoxyCode}
# .eslintrc.yml
settings:
  import/parsers:
    typescript-eslint-parser: [ .ts, .tsx ]
\end{DoxyCode}


In this case, \href{https://github.com/eslint/typescript-eslint-parser}{\tt {\ttfamily typescript-\/eslint-\/parser}} must be installed and require-\/able from the running {\ttfamily eslint} module\textquotesingle{}s location (i.\+e., install it as a peer of E\+S\+Lint).

This is currently only tested with {\ttfamily typescript-\/eslint-\/parser} but should theoretically work with any moderately E\+S\+Tree-\/compliant parser.

It\textquotesingle{}s difficult to say how well various plugin features will be supported, too, depending on how far down the rabbit hole goes. Submit an issue if you find strange behavior beyond here, but steel your heart against the likely outcome of closing with {\ttfamily wontfix}.

\paragraph*{{\ttfamily import/resolver}}

See \href{#resolvers}{\tt resolvers}.

\paragraph*{{\ttfamily import/cache}}

Settings for cache behavior. Memoization is used at various levels to avoid the copious amount of {\ttfamily fs.\+stat\+Sync}/module parse calls required to correctly report errors.

For normal {\ttfamily eslint} console runs, the cache lifetime is irrelevant, as we can strongly assume that files should not be changing during the lifetime of the linter process (and thus, the cache in memory)

For long-\/lasting processes, like \href{https://www.npmjs.com/package/eslint_d}{\tt {\ttfamily eslint\+\_\+d}} or \href{https://www.npmjs.com/package/eslint-loader}{\tt {\ttfamily eslint-\/loader}}, however, it\textquotesingle{}s important that there be some notion of staleness.

If you never use \href{https://www.npmjs.com/package/eslint_d}{\tt {\ttfamily eslint\+\_\+d}} or \href{https://www.npmjs.com/package/eslint-loader}{\tt {\ttfamily eslint-\/loader}}, you may set the cache lifetime to {\ttfamily Infinity} and everything should be fine\+:


\begin{DoxyCode}
# .eslintrc.yml
settings:
  import/cache:
    lifetime: ∞  # or Infinity
\end{DoxyCode}


Otherwise, set some integer, and cache entries will be evicted after that many seconds have elapsed\+:


\begin{DoxyCode}
# .eslintrc.yml
settings:
  import/cache:
    lifetime: 5  # 30 is the default
\end{DoxyCode}


\subsection*{Sublime\+Linter-\/eslint}

Sublime\+Linter-\/eslint introduced a change to support {\ttfamily .eslintignore} files which altered the way file paths are passed to E\+S\+Lint when linting during editing. This change sends a relative path instead of the absolute path to the file (as E\+S\+Lint normally provides), which can make it impossible for this plugin to resolve dependencies on the filesystem.

This workaround should no longer be necessary with the release of E\+S\+Lint 2.\+0, when {\ttfamily .eslintignore} will be updated to work more like a {\ttfamily .gitignore}, which should support proper ignoring of absolute paths via {\ttfamily -\/-\/stdin-\/filename}.

In the meantime, see \href{https://github.com/roadhump/SublimeLinter-eslint/issues/58}{\tt roadhump/\+Sublime\+Linter-\/eslint\#58} for more details and discussion, but essentially, you may find you need to add the following {\ttfamily Sublime\+Linter} config to your Sublime project file\+:


\begin{DoxyCode}
\{
    "folders":
    [
        \{
            "path": "code"
        \}
    ],
    "SublimeLinter":
    \{
        "linters":
        \{
            "eslint":
            \{
                "chdir": "$\{project\}/code"
            \}
        \}
    \}
\}
\end{DoxyCode}


Note that {\ttfamily \$\{project\}/code} matches the {\ttfamily code} provided at {\ttfamily folders\mbox{[}0\mbox{]}.path}.

The purpose of the {\ttfamily chdir} setting, in this case, is to set the working directory from which E\+S\+Lint is executed to be the same as the directory on which Sublime\+Linter-\/eslint bases the relative path it provides.

See the Sublime\+Linter docs on \href{http://www.sublimelinter.com/en/latest/linter_settings.html#chdir}{\tt {\ttfamily chdir}} for more information, in case this does not work with your project.

If you are not using {\ttfamily .eslintignore}, or don\textquotesingle{}t have a Sublime project file, you can also do the following via a {\ttfamily .sublimelinterrc} file in some ancestor directory of your code\+:


\begin{DoxyCode}
\{
  "linters": \{
    "eslint": \{
      "args": ["--stdin-filename", "@"]
    \}
  \}
\}
\end{DoxyCode}


I also found that I needed to set {\ttfamily rc\+\_\+search\+\_\+limit} to {\ttfamily null}, which removes the file hierarchy search limit when looking up the directory tree for {\ttfamily .sublimelinterrc}\+:

In Package Settings / Sublime\+Linter / User Settings\+: 
\begin{DoxyCode}
\{
  "user": \{
    "rc\_search\_limit": null
  \}
\}
\end{DoxyCode}


I believe this defaults to {\ttfamily 3}, so you may not need to alter it depending on your project folder max depth. 