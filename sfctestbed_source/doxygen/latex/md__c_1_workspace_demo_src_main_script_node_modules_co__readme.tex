\href{https://gitter.im/tj/co?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge}{\tt } \href{https://npmjs.org/package/co}{\tt } \href{https://travis-ci.org/tj/co}{\tt } \href{https://coveralls.io/r/tj/co}{\tt } \href{https://npmjs.org/package/co}{\tt }

Generator based control flow goodness for nodejs and the browser, using promises, letting you write non-\/blocking code in a nice-\/ish way.

\subsection*{Co v4}

{\ttfamily co@4.\+0.\+0} has been released, which now relies on promises. It is a stepping stone towards \href{https://github.com/lukehoban/ecmascript-asyncawait}{\tt E\+S7 async/await}. The primary A\+PI change is how {\ttfamily co()} is invoked. Before, {\ttfamily co} returned a \char`\"{}thunk\char`\"{}, which you then called with a callback and optional arguments. Now, {\ttfamily co()} returns a promise.


\begin{DoxyCode}
co(function* () \{
  var result = yield Promise.resolve(true);
  return result;
\}).then(function (value) \{
  console.log(value);
\}, function (err) \{
  console.error(err.stack);
\});
\end{DoxyCode}


If you want to convert a {\ttfamily co}-\/generator-\/function into a regular function that returns a promise, you now use {\ttfamily co.\+wrap(fn$\ast$)}.


\begin{DoxyCode}
var fn = co.wrap(function* (val) \{
  return yield Promise.resolve(val);
\});

fn(true).then(function (val) \{

\});
\end{DoxyCode}


\subsection*{Platform Compatibility}

{\ttfamily co@4+} requires a {\ttfamily Promise} implementation. For versions of node {\ttfamily $<$ 0.\+11} and for many older browsers, you should/must include your own {\ttfamily Promise} polyfill.

When using node 0.\+11.\+x or greater, you must use the {\ttfamily -\/-\/harmony-\/generators} flag or just {\ttfamily -\/-\/harmony} to get access to generators.

When using node 0.\+10.\+x and lower or browsers without generator support, you must use \href{https://github.com/TooTallNate/gnode}{\tt gnode} and/or \href{http://facebook.github.io/regenerator/}{\tt regenerator}.

io.\+js is supported out of the box, you can use {\ttfamily co} without flags or polyfills.

\subsection*{Installation}


\begin{DoxyCode}
$ npm install co
\end{DoxyCode}


\subsection*{Associated libraries}

Any library that returns promises work well with {\ttfamily co}.


\begin{DoxyItemize}
\item \href{https://github.com/normalize/mz}{\tt mz} -\/ wrap all of node\textquotesingle{}s code libraries as promises.
\end{DoxyItemize}

View the \href{https://github.com/visionmedia/co/wiki}{\tt wiki} for more libraries.

\subsection*{Examples}


\begin{DoxyCode}
var co = require('co');

co(function *()\{
  // yield any promise
  var result = yield Promise.resolve(true);
\}).catch(onerror);

co(function *()\{
  // resolve multiple promises in parallel
  var a = Promise.resolve(1);
  var b = Promise.resolve(2);
  var c = Promise.resolve(3);
  var res = yield [a, b, c];
  console.log(res);
  // => [1, 2, 3]
\}).catch(onerror);

// errors can be try/catched
co(function *()\{
  try \{
    yield Promise.reject(new Error('boom'));
  \} catch (err) \{
    console.error(err.message); // "boom"
 \}
\}).catch(onerror);

function onerror(err) \{
  // log any uncaught errors
  // co will not throw any errors you do not handle!!!
  // HANDLE ALL YOUR ERRORS!!!
  console.error(err.stack);
\}
\end{DoxyCode}


\subsection*{Yieldables}

The {\ttfamily yieldable} objects currently supported are\+:


\begin{DoxyItemize}
\item promises
\item thunks (functions)
\item array (parallel execution)
\item objects (parallel execution)
\item generators (delegation)
\item generator functions (delegation)
\end{DoxyItemize}

Nested {\ttfamily yieldable} objects are supported, meaning you can nest promises within objects within arrays, and so on!

\subsubsection*{Promises}

\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise}{\tt Read more on promises!}

\subsubsection*{Thunks}

Thunks are functions that only have a single argument, a callback. Thunk support only remains for backwards compatibility and may be removed in future versions of {\ttfamily co}.

\subsubsection*{Arrays}

{\ttfamily yield}ing an array will resolve all the {\ttfamily yieldables} in parallel.


\begin{DoxyCode}
co(function* () \{
  var res = yield [
    Promise.resolve(1),
    Promise.resolve(2),
    Promise.resolve(3),
  ];
  console.log(res); // => [1, 2, 3]
\}).catch(onerror);
\end{DoxyCode}


\subsubsection*{Objects}

Just like arrays, objects resolve all {\ttfamily yieldable}s in parallel.


\begin{DoxyCode}
co(function* () \{
  var res = yield \{
    1: Promise.resolve(1),
    2: Promise.resolve(2),
  \};
  console.log(res); // => \{ 1: 1, 2: 2 \}
\}).catch(onerror);
\end{DoxyCode}


\subsubsection*{Generators and Generator Functions}

Any generator or generator function you can pass into {\ttfamily co} can be yielded as well. This should generally be avoided as we should be moving towards spec-\/compliant {\ttfamily Promise}s instead.

\subsection*{A\+PI}

\subsubsection*{co(fn$\ast$).then( val =$>$ )}

Returns a promise that resolves a generator, generator function, or any function that returns a generator.


\begin{DoxyCode}
co(function* () \{
  return yield Promise.resolve(true);
\}).then(function (val) \{
  console.log(val);
\}, function (err) \{
  console.error(err.stack);
\});
\end{DoxyCode}


\subsubsection*{var fn = co.\+wrap(fn$\ast$)}

Convert a generator into a regular function that returns a {\ttfamily Promise}.


\begin{DoxyCode}
var fn = co.wrap(function* (val) \{
  return yield Promise.resolve(val);
\});

fn(true).then(function (val) \{

\});
\end{DoxyCode}


\subsection*{License}

M\+IT 