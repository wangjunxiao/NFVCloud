\begin{quote}
Glob matching for javascript/node.\+js. A drop-\/in replacement and faster alternative to minimatch and multimatch. \end{quote}


Micromatch supports all of the same matching features as \href{https://github.com/isaacs/minimatch}{\tt minimatch} and \href{https://github.com/sindresorhus/multimatch}{\tt multimatch}.


\begin{DoxyItemize}
\item \href{#usage}{\tt mm()} is the same as \href{https://github.com/sindresorhus/multimatch}{\tt multimatch()}
\item \href{#match}{\tt mm.\+match()} is the same as \href{https://github.com/isaacs/minimatch}{\tt minimatch.\+match()}
\item use \href{#ismatch}{\tt mm.\+is\+Match()} instead of \href{https://github.com/isaacs/minimatch}{\tt minimatch()}
\end{DoxyItemize}

\subsection*{Install}

Install with \href{https://www.npmjs.com/}{\tt npm}\+:


\begin{DoxyCode}
$ npm install --save micromatch
\end{DoxyCode}


\subsection*{Start matching!}


\begin{DoxyCode}
var mm = require('micromatch');
console.log(mm(['']))
\end{DoxyCode}






\subsubsection*{Features}


\begin{DoxyItemize}
\item \href{#switch-from-minimatch}{\tt Drop-\/in replacement} for \href{https://github.com/isaacs/minimatch}{\tt minimatch} and \href{https://github.com/sindresorhus/multimatch}{\tt multimatch}
\item Built-\/in support for multiple glob patterns, like `\mbox{[}\textquotesingle{}foo/$\ast$.js', \textquotesingle{}!bar.js\textquotesingle{}\mbox{]}{\ttfamily }
\item {\ttfamily \mbox{[}Brace Expansion\mbox{]}(\href{https://github.com/jonschlinkert/braces}{\tt https\+://github.\+com/jonschlinkert/braces}) (}foo/bar-\/\{1..5\}.md{\ttfamily ,}one/\{two,three\}/four.md{\ttfamily )}
\item {\ttfamily Typical glob patterns, like}$\ast$$\ast$/$\ast${\ttfamily ,}a/b/$\ast$.js{\ttfamily , or}\mbox{[}\textquotesingle{}foo/$\ast$.js\textquotesingle{}, \textquotesingle{}!bar.js\textquotesingle{}\mbox{]}{\ttfamily }
\item {\ttfamily Methods like}.is\+Match(){\ttfamily ,}.contains(){\ttfamily and}.any()\`{}
\end{DoxyItemize}

{\bfseries Extended globbing features\+:}


\begin{DoxyItemize}
\item Logical {\ttfamily OR} ({\ttfamily foo/bar/(abc$\vert$xyz).js})
\item Regex character classes ({\ttfamily foo/bar/baz-\/\mbox{[}1-\/5\mbox{]}.js})
\item P\+O\+S\+IX \href{https://github.com/jonschlinkert/expand-brackets}{\tt bracket expressions} ({\ttfamily $\ast$$\ast$/\mbox{[}\mbox{[}\+:alpha\+:\mbox{]}\mbox{[}\+:digit\+:\mbox{]}\mbox{]}/})
\item \href{https://github.com/jonschlinkert/extglob}{\tt extglobs} ({\ttfamily $\ast$$\ast$/+(x$\vert$y)}, {\ttfamily !(a$\vert$b)}, etc).
\end{DoxyItemize}

You can combine these to create whatever matching patterns you need.

{\bfseries Example}


\begin{DoxyCode}
// double-negation!
mm(['fa', 'fb', 'f', 'fo'], '!(f!(o))');
//=> ['fo']
\end{DoxyCode}


\subsection*{Why switch to micromatch?}


\begin{DoxyItemize}
\item Native support for multiple glob patterns, no need for wrappers like \href{https://github.com/sindresorhus/multimatch}{\tt multimatch}
\item \href{#benchmarks}{\tt 10-\/55x faster} and more performant than \href{https://github.com/isaacs/minimatch}{\tt minimatch} and \href{https://github.com/sindresorhus/multimatch}{\tt multimatch}. This is achieved through a combination of caching and regex optimization strategies, a fundamentally different approach than minimatch.
\item More extensive support for the Bash 4.\+3 specification
\item More complete extglob support
\item Extensive \href{./test}{\tt unit tests} (approx. 1,300 tests). Minimatch fails many of the tests.
\end{DoxyItemize}

\subsubsection*{Switch from minimatch}

Use {\ttfamily mm.\+is\+Match()} instead of {\ttfamily minimatch()}\+:


\begin{DoxyCode}
mm.isMatch('foo', 'b*');
//=> false
\end{DoxyCode}


Use {\ttfamily mm.\+match()} instead of {\ttfamily minimatch.\+match()}\+:


\begin{DoxyCode}
mm.match(['foo', 'bar'], 'b*');
//=> 'bar'
\end{DoxyCode}


\subsubsection*{Switch from multimatch}

Same signature\+:


\begin{DoxyCode}
mm(['foo', 'bar', 'baz'], ['f*', '*z']);
//=> ['foo', 'baz']
\end{DoxyCode}






\subsection*{Usage}

Add micromatch to your node.\+js project\+:


\begin{DoxyCode}
var mm = require('micromatch');
\end{DoxyCode}


{\bfseries Signature}


\begin{DoxyCode}
mm(array\_of\_strings, glob\_patterns[, options]);
\end{DoxyCode}


{\bfseries Example}


\begin{DoxyCode}
mm(['foo', 'bar', 'baz'], 'b*');
//=> ['bar', 'baz']
\end{DoxyCode}


\subsubsection*{Usage examples}

{\bfseries Brace expansion}

Match files with {\ttfamily .js} or {\ttfamily .txt} extensions.


\begin{DoxyCode}
mm(['a.js', 'b.md', 'c.txt'], '*.\{js,txt\}');
//=> ['a.js', 'c.txt']
\end{DoxyCode}


{\bfseries Extglobs}

Match anything except for files with the {\ttfamily .md} extension.


\begin{DoxyCode}
mm(files, '**/*.!(md)');

//=> ['a.js', 'c.txt']
\end{DoxyCode}


{\bfseries Multiple patterns}

Match using an array of patterns.


\begin{DoxyCode}
mm(['a.md', 'b.js', 'c.txt', 'd.json'], ['*.md', '*.txt']);
//=> ['a.md', 'c.txt']
\end{DoxyCode}


{\bfseries Negation patterns\+:}

Behavior is designed to be what users would expect, based on conventions that are already well-\/established.


\begin{DoxyItemize}
\item \href{https://github.com/isaacs/minimatch}{\tt minimatch} behavior is used when the pattern is a string, so patterns are {\bfseries inclusive by default}.
\item \href{https://github.com/sindresorhus/multimatch}{\tt multimatch} behavior is used when an array of patterns is passed, so patterns are {\bfseries exclusive by default}.
\end{DoxyItemize}


\begin{DoxyCode}
mm(['a.js', 'b.md', 'c.txt'], '!*.\{js,txt\}');
//=> ['b.md']

mm(['a.md', 'b.js', 'c.txt', 'd.json'], ['*.*', '!*.\{js,txt\}']);
//=> ['a.md', 'd.json']
\end{DoxyCode}






\subsection*{A\+PI methods}


\begin{DoxyCode}
var mm = require('micromatch');
\end{DoxyCode}


\subsubsection*{.match}


\begin{DoxyCode}
mm.match(array, globString);
\end{DoxyCode}


Return an array of files that match the given glob pattern. Useful if you only need to use a single glob pattern.

{\bfseries Example}


\begin{DoxyCode}
mm.match(['ab', 'a/b', 'bb', 'b/c'], '?b');
//=> ['ab', 'bb']

mm.match(['ab', 'a/b', 'bb', 'b/c'], '*/b');
//=> ['a/b']
\end{DoxyCode}


\subsubsection*{.is\+Match}


\begin{DoxyCode}
mm.isMatch(filepath, globString);
\end{DoxyCode}


Returns true if a file path matches the given glob pattern.

{\bfseries Example}


\begin{DoxyCode}
mm.isMatch('.verb.md', '*.md');
//=> false

mm.isMatch('.verb.md', '*.md', \{dot: true\});
//=> true
\end{DoxyCode}


\subsubsection*{.contains}

Returns true if any part of a file path matches the given glob pattern. Think of this is \char`\"{}has path\char`\"{} versus \char`\"{}is path\char`\"{}.

{\bfseries Example}

{\ttfamily .is\+Match()} would return false for both of the following\+:


\begin{DoxyCode}
mm.contains('a/b/c', 'a/b');
//=> true

mm.contains('a/b/c', 'a/*');
//=> true
\end{DoxyCode}


\subsubsection*{.matcher}

Returns a function for matching using the supplied pattern. e.\+g. create your own \char`\"{}matcher\char`\"{}. The advantage of this method is that the pattern can be compiled outside of a loop.

{\bfseries Pattern}

Can be any of the following\+:


\begin{DoxyItemize}
\item {\ttfamily glob/string}
\item {\ttfamily regex}
\item {\ttfamily function}
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
var isMatch = mm.matcher('*.md');
var files = [];

['a.md', 'b.txt', 'c.md'].forEach(function(fp) \{
  if (isMatch(fp)) \{
    files.push(fp);
  \}
\});
\end{DoxyCode}


\subsubsection*{.filter}

Returns a function that can be passed to {\ttfamily Array\+::filter()}.

{\bfseries Params}


\begin{DoxyItemize}
\item {\ttfamily patterns} $\ast$$\ast$\{String$\vert$\+Array\}$\ast$$\ast$\+:
\end{DoxyItemize}

{\bfseries Examples}

Single glob\+:


\begin{DoxyCode}
var fn = mm.filter('*.md');
['a.js', 'b.txt', 'c.md'].filter(fn);
//=> ['c.md']

var fn = mm.filter('[a-c]');
['a', 'b', 'c', 'd', 'e'].filter(fn);
//=> ['a', 'b', 'c']
\end{DoxyCode}


Array of glob patterns\+:


\begin{DoxyCode}
var arr = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];

var fn = mm.filter(['\{1..10\}', '![7-9]', '!\{3..4\}']);
arr.filter(fn);
//=> [1, 2, 5, 6, 10]
\end{DoxyCode}


\+\_\+(Internally this function generates the matching function by using the \href{#matcher}{\tt matcher} method. You can use the \href{#matcher}{\tt matcher} method directly to create your own filter function)\+\_\+

\subsubsection*{.any}

Returns true if a file path matches any of the given patterns.


\begin{DoxyCode}
mm.any(filepath, patterns, options);
\end{DoxyCode}


{\bfseries Params}


\begin{DoxyItemize}
\item filepath {\ttfamily \{String\}}\+: The file path to test.
\item patterns {\ttfamily \{String$\vert$\+Array\}}\+: One or more glob patterns
\item options\+: {\ttfamily \{Object\}}\+: options to pass to the {\ttfamily .matcher()} method.
\end{DoxyItemize}

{\bfseries Example}


\begin{DoxyCode}
mm.any('abc', ['!*z']);
//=> true
mm.any('abc', ['a*', 'z*']);
//=> true
mm.any('abc', 'a*');
//=> true
mm.any('abc', ['z*']);
//=> false
\end{DoxyCode}


\subsubsection*{.expand}

Returns an object with a regex-\/compatible string and tokens.


\begin{DoxyCode}
mm.expand('*.js');

// when `track` is enabled (for debugging), the `history` array is used
// to record each mutation to the glob pattern as it's converted to regex
\{ options: \{ track: false, dot: undefined, makeRe: true, negated: false \},
  pattern: '(.*\(\backslash\)\(\backslash\)/|^)bar\(\backslash\)\(\backslash\)/(?:(?!(?:^|\(\backslash\)\(\backslash\)/)\(\backslash\)\(\backslash\).).)*?',
  history: [],
  tokens:
   \{ path:
      \{ whole: '**/bar/**',
        dirname: '**/bar/',
        filename: '**',
        basename: '**',
        extname: '',
        ext: '' \},
     is:
      \{ glob: true,
        negated: false,
        globstar: true,
        dotfile: false,
        dotdir: false \},
     match: \{\},
     original: '**/bar/**',
     pattern: '**/bar/**',
     base: '' \} \}
\end{DoxyCode}


\subsubsection*{.make\+Re}

Create a regular expression for matching file paths based on the given pattern\+:


\begin{DoxyCode}
mm.makeRe('*.js');
//=> /^(?:(?!\(\backslash\).)(?=.)[^/]*?\(\backslash\).js)$/
\end{DoxyCode}


\subsection*{Options}

\subsubsection*{options.\+unixify}

Normalize slashes in file paths and glob patterns to forward slashes.

Type\+: {\ttfamily \{Boolean\}}

Default\+: {\ttfamily undefined} on non-\/windows, {\ttfamily true} on windows.

\subsubsection*{options.\+dot}

Match dotfiles. Same behavior as \href{https://github.com/isaacs/minimatch}{\tt minimatch}.

Type\+: {\ttfamily \{Boolean\}}

Default\+: {\ttfamily false}

\subsubsection*{options.\+unescape}

Unescape slashes in glob patterns. Use cautiously, especially on windows.

Type\+: {\ttfamily \{Boolean\}}

Default\+: {\ttfamily undefined}

{\bfseries Example}


\begin{DoxyCode}
mm.isMatch('abc', '\(\backslash\)\(\backslash\)a\(\backslash\)\(\backslash\)b\(\backslash\)\(\backslash\)c', \{unescape: true\});
//=> true
\end{DoxyCode}


\subsubsection*{options.\+nodupes}

Remove duplicate elements from the result array.

Type\+: {\ttfamily \{Boolean\}}

Default\+: {\ttfamily undefined}

{\bfseries Example}

Example of using the {\ttfamily unescape} and {\ttfamily nodupes} options together\+:


\begin{DoxyCode}
mm.match(['abc', '\(\backslash\)\(\backslash\)a\(\backslash\)\(\backslash\)b\(\backslash\)\(\backslash\)c'], '\(\backslash\)\(\backslash\)a\(\backslash\)\(\backslash\)b\(\backslash\)\(\backslash\)c', \{unescape: true\});
//=> ['abc', 'abc']

mm.match(['abc', '\(\backslash\)\(\backslash\)a\(\backslash\)\(\backslash\)b\(\backslash\)\(\backslash\)c'], '\(\backslash\)\(\backslash\)a\(\backslash\)\(\backslash\)b\(\backslash\)\(\backslash\)c', \{unescape: true, nodupes: true\});
//=> ['abc']
\end{DoxyCode}


\subsubsection*{options.\+match\+Base}

Allow glob patterns without slashes to match a file path based on its basename. . Same behavior as \href{https://github.com/isaacs/minimatch}{\tt minimatch}.

Type\+: {\ttfamily \{Boolean\}}

Default\+: {\ttfamily false}

{\bfseries Example}


\begin{DoxyCode}
mm(['a/b.js', 'a/c.md'], '*.js');
//=> []

mm(['a/b.js', 'a/c.md'], '*.js', \{matchBase: true\});
//=> ['a/b.js']
\end{DoxyCode}


\subsubsection*{options.\+nobraces}

Don\textquotesingle{}t expand braces in glob patterns. Same behavior as \href{https://github.com/isaacs/minimatch}{\tt minimatch} {\ttfamily nobrace}.

Type\+: {\ttfamily \{Boolean\}}

Default\+: {\ttfamily undefined}

See \href{https://github.com/jonschlinkert/braces}{\tt braces} for more information about extended brace expansion.

\subsubsection*{options.\+nobrackets}

Don\textquotesingle{}t expand P\+O\+S\+IX bracket expressions.

Type\+: {\ttfamily \{Boolean\}}

Default\+: {\ttfamily undefined}

See \href{https://github.com/jonschlinkert/expand-brackets}{\tt expand-\/brackets} for more information about extended bracket expressions.

\subsubsection*{options.\+noextglob}

Don\textquotesingle{}t expand extended globs.

Type\+: {\ttfamily \{Boolean\}}

Default\+: {\ttfamily undefined}

See \href{https://github.com/jonschlinkert/extglob}{\tt extglob} for more information about extended globs.

\subsubsection*{options.\+nocase}

Use a case-\/insensitive regex for matching files. Same behavior as \href{https://github.com/isaacs/minimatch}{\tt minimatch}.

Type\+: {\ttfamily \{Boolean\}}

Default\+: {\ttfamily false}

\subsubsection*{options.\+nonegate}

Disallow negation ({\ttfamily !}) patterns.

Type\+: {\ttfamily \{Boolean\}}

Default\+: {\ttfamily false}

\subsubsection*{options.\+nonull}

If {\ttfamily true}, when no matches are found the actual (array-\/ified) glob pattern is returned instead of an empty array. Same behavior as \href{https://github.com/isaacs/minimatch}{\tt minimatch}.

Type\+: {\ttfamily \{Boolean\}}

Default\+: {\ttfamily false}

\subsubsection*{options.\+cache}

Cache the platform (e.\+g. {\ttfamily win32}) to prevent this from being looked up for every filepath.

Type\+: {\ttfamily \{Boolean\}}

Default\+: {\ttfamily true}





\subsection*{Other features}

Micromatch also supports the following.

\subsubsection*{Extended globbing}

\paragraph*{extglobs}

Extended globbing, as described by the bash man page\+:

$\vert$ {\bfseries pattern} $\vert$ {\bfseries regex equivalent} $\vert$ {\bfseries description} $\vert$ $\vert$ --- $\vert$ --- $\vert$ --- $\vert$ $\vert$ {\ttfamily ?(pattern-\/list)} $\vert$ {\ttfamily (... $\vert$ ...)?} $\vert$ Matches zero or one occurrence of the given patterns $\vert$ $\vert$ {\ttfamily $\ast$(pattern-\/list)} $\vert$ {\ttfamily (... $\vert$ ...)$\ast$} $\vert$ Matches zero or more occurrences of the given patterns $\vert$ $\vert$ {\ttfamily +(pattern-\/list)} $\vert$ {\ttfamily (... $\vert$ ...)+} $\vert$ Matches one or more occurrences of the given patterns $\vert$ $\vert$ {\ttfamily @(pattern-\/list)} $\vert$ {\ttfamily (... $\vert$ ...)} \textsuperscript{$\ast$} $\vert$ Matches one of the given patterns $\vert$ $\vert$ {\ttfamily !(pattern-\/list)} $\vert$ N/A $\vert$ Matches anything except one of the given patterns $\vert$

\textsuperscript{{\bfseries $\ast$}} {\ttfamily @} isn\textquotesingle{}t a Reg\+Ex character.

Powered by \href{https://github.com/jonschlinkert/extglob}{\tt extglob}. Visit that library for the full range of options or to report extglob related issues.

See \href{https://github.com/jonschlinkert/extglob}{\tt extglob} for more information about extended globs.

\paragraph*{brace expansion}

In simple cases, brace expansion appears to work the same way as the logical {\ttfamily OR} operator. For example, {\ttfamily (a$\vert$b)} will achieve the same result as {\ttfamily \{a,b\}}.

Here are some powerful features unique to brace expansion (versus character classes)\+:


\begin{DoxyItemize}
\item range expansion\+: {\ttfamily a\{1..3\}b/$\ast$.js} expands to\+: `\mbox{[}\textquotesingle{}a1b/$\ast$.js', \textquotesingle{}a2b/$\ast$.js\textquotesingle{}, \textquotesingle{}a3b/$\ast$.js\textquotesingle{}\mbox{]}{\ttfamily }
\item {\ttfamily nesting\+:}a\{c,\{d,e\}\}b/$\ast$.js{\ttfamily expands to\+:}\mbox{[}\textquotesingle{}acb/$\ast$.js\textquotesingle{}, \textquotesingle{}adb/$\ast$.js\textquotesingle{}, \textquotesingle{}aeb/$\ast$.js\textquotesingle{}\mbox{]}\`{}
\end{DoxyItemize}

Visit \href{https://github.com/jonschlinkert/braces}{\tt braces} to ask questions and create an issue related to brace-\/expansion, or to see the full range of features and options related to brace expansion.

\paragraph*{regex character classes}

With the exception of brace expansion ({\ttfamily \{a,b\}}, {\ttfamily \{1..5\}}, etc), most of the special characters convert directly to regex, so you can expect them to follow the same rules and produce the same results as regex.

For example, given the list\+: `\mbox{[}\textquotesingle{}a.\+js', \textquotesingle{}b.\+js\textquotesingle{}, \textquotesingle{}c.\+js\textquotesingle{}, \textquotesingle{}d.\+js\textquotesingle{}, \textquotesingle{}E.\+js\textquotesingle{}\mbox{]}\`{}\+:


\begin{DoxyItemize}
\item {\ttfamily \mbox{[}ac\mbox{]}.js}\+: matches both {\ttfamily a} and {\ttfamily c}, returning `\mbox{[}\textquotesingle{}a.\+js', \textquotesingle{}c.\+js\textquotesingle{}\mbox{]}{\ttfamily  $\ast$}\mbox{[}b-\/d\mbox{]}.js{\ttfamily \+: matches from}b{\ttfamily to}d{\ttfamily , returning}\mbox{[}\textquotesingle{}b.\+js\textquotesingle{}, \textquotesingle{}c.\+js\textquotesingle{}, \textquotesingle{}d.\+js\textquotesingle{}\mbox{]}{\ttfamily  $\ast$}\mbox{[}b-\/d\mbox{]}.js{\ttfamily \+: matches from}b{\ttfamily to}d{\ttfamily , returning}\mbox{[}\textquotesingle{}b.\+js\textquotesingle{}, \textquotesingle{}c.\+js\textquotesingle{}, \textquotesingle{}d.\+js\textquotesingle{}\mbox{]}{\ttfamily  $\ast$}a/\mbox{[}A-\/Z\mbox{]}.js{\ttfamily \+: matches and uppercase letter, returning}\mbox{[}\textquotesingle{}a/\+E.\+md\textquotesingle{}\mbox{]}\`{}
\end{DoxyItemize}

Learn about \href{http://www.regular-expressions.info/charclass.html}{\tt regex character classes}.

\paragraph*{regex groups}

Given `\mbox{[}\textquotesingle{}a.\+js', \textquotesingle{}b.\+js\textquotesingle{}, \textquotesingle{}c.\+js\textquotesingle{}, \textquotesingle{}d.\+js\textquotesingle{}, \textquotesingle{}E.\+js\textquotesingle{}\mbox{]}\`{}\+:


\begin{DoxyItemize}
\item {\ttfamily (a$\vert$c).js}\+: would match either {\ttfamily a} or {\ttfamily c}, returning `\mbox{[}\textquotesingle{}a.\+js', \textquotesingle{}c.\+js\textquotesingle{}\mbox{]}{\ttfamily  $\ast$}(b$\vert$d).js{\ttfamily \+: would match either}b{\ttfamily or}d{\ttfamily , returning}\mbox{[}\textquotesingle{}b.\+js\textquotesingle{}, \textquotesingle{}d.\+js\textquotesingle{}\mbox{]}{\ttfamily  $\ast$}(b$\vert$\mbox{[}A-\/Z\mbox{]}).js{\ttfamily \+: would match either}b{\ttfamily or an uppercase letter, returning}\mbox{[}\textquotesingle{}b.\+js\textquotesingle{}, \textquotesingle{}E.\+js\textquotesingle{}\mbox{]}\`{}
\end{DoxyItemize}

As with regex, parenthese can be nested, so patterns like {\ttfamily ((a$\vert$b)$\vert$c)/b} will work. But it might be easier to achieve your goal using brace expansion.

\paragraph*{P\+O\+S\+IX bracket expressions}

{\bfseries Example}


\begin{DoxyCode}
mm.isMatch('a1', '[[:alpha:][:digit:]]');
//=> true
\end{DoxyCode}


See \href{https://github.com/jonschlinkert/expand-brackets}{\tt expand-\/brackets} for more information about extended bracket expressions.





\subsection*{Notes}

Whenever possible parsing behavior for patterns is based on globbing specifications in Bash 4.\+3. Patterns that aren\textquotesingle{}t described by Bash follow wildmatch spec (used by git).

\subsection*{Benchmarks}

Run the \href{./benchmark}{\tt benchmarks}\+:


\begin{DoxyCode}
node benchmark
\end{DoxyCode}


As of July 15, 2016\+:


\begin{DoxyCode}
#1: basename-braces
  micromatch x 26,420 ops/sec ±0.89% (91 runs sampled)
  minimatch x 3,507 ops/sec ±0.64% (97 runs sampled)

#2: basename
  micromatch x 25,315 ops/sec ±0.82% (93 runs sampled)
  minimatch x 4,398 ops/sec ±0.86% (94 runs sampled)

#3: braces-no-glob
  micromatch x 341,254 ops/sec ±0.78% (93 runs sampled)
  minimatch x 30,197 ops/sec ±1.12% (91 runs sampled)

#4: braces
  micromatch x 54,649 ops/sec ±0.74% (94 runs sampled)
  minimatch x 3,095 ops/sec ±0.82% (95 runs sampled)

#5: immediate
  micromatch x 16,719 ops/sec ±0.79% (95 runs sampled)
  minimatch x 4,348 ops/sec ±0.86% (96 runs sampled)

#6: large
  micromatch x 721 ops/sec ±0.77% (94 runs sampled)
  minimatch x 17.73 ops/sec ±1.08% (50 runs sampled)

#7: long
  micromatch x 5,051 ops/sec ±0.87% (97 runs sampled)
  minimatch x 628 ops/sec ±0.83% (94 runs sampled)

#8: mid
  micromatch x 51,280 ops/sec ±0.80% (95 runs sampled)
  minimatch x 1,923 ops/sec ±0.84% (95 runs sampled)

#9: multi-patterns
  micromatch x 22,440 ops/sec ±0.97% (94 runs sampled)
  minimatch x 2,481 ops/sec ±1.10% (94 runs sampled)

#10: no-glob
  micromatch x 722,823 ops/sec ±1.30% (87 runs sampled)
  minimatch x 52,967 ops/sec ±1.09% (94 runs sampled)

#11: range
  micromatch x 243,471 ops/sec ±0.79% (94 runs sampled)
  minimatch x 11,736 ops/sec ±0.82% (96 runs sampled)

#12: shallow
  micromatch x 190,874 ops/sec ±0.98% (95 runs sampled)
  minimatch x 21,699 ops/sec ±0.81% (97 runs sampled)

#13: short
  micromatch x 496,393 ops/sec ±3.86% (90 runs sampled)
  minimatch x 53,765 ops/sec ±0.75% (95 runs sampled)
\end{DoxyCode}


\subsection*{Tests}

\subsubsection*{Running tests}

Install dev dependencies\+:


\begin{DoxyCode}
$ npm install -d && npm test
\end{DoxyCode}


\subsubsection*{Coverage}

As of July 15, 2016\+:


\begin{DoxyCode}
Statements : 100% (441/441)
Branches   : 100% (270/270)
Functions  : 100% (54/54)
Lines      : 100% (429/429)
\end{DoxyCode}


\subsection*{Contributing}

Pull requests and stars are always welcome. For bugs and feature requests, \href{../../issues/new}{\tt please create an issue}.

Please be sure to run the benchmarks before/after any code changes to judge the impact before you do a PR. thanks!

\subsection*{Related}


\begin{DoxyItemize}
\item \href{https://www.npmjs.com/package/braces}{\tt braces}\+: Fastest brace expansion for node.\+js, with the most complete support for the Bash 4.\+3 braces… \href{https://github.com/jonschlinkert/braces}{\tt more} $\vert$ \href{https://github.com/jonschlinkert/braces}{\tt homepage}
\item \href{https://www.npmjs.com/package/expand-brackets}{\tt expand-\/brackets}\+: Expand P\+O\+S\+IX bracket expressions (character classes) in glob patterns. $\vert$ \mbox{[}homepage\mbox{]}(\href{https://github.com/jonschlinkert/expand-brackets}{\tt https\+://github.\+com/jonschlinkert/expand-\/brackets} \char`\"{}\+Expand P\+O\+S\+I\+X bracket expressions (character classes) in glob patterns.\char`\"{})
\item \href{https://www.npmjs.com/package/expand-range}{\tt expand-\/range}\+: Fast, bash-\/like range expansion. Expand a range of numbers or letters, uppercase or lowercase. See… \href{https://github.com/jonschlinkert/expand-range}{\tt more} $\vert$ \href{https://github.com/jonschlinkert/expand-range}{\tt homepage}
\item \href{https://www.npmjs.com/package/extglob}{\tt extglob}\+: Convert extended globs to regex-\/compatible strings. Add (almost) the expressive power of regular expressions to… \href{https://github.com/jonschlinkert/extglob}{\tt more} $\vert$ \mbox{[}homepage\mbox{]}(\href{https://github.com/jonschlinkert/extglob}{\tt https\+://github.\+com/jonschlinkert/extglob} \char`\"{}\+Convert extended globs to regex-\/compatible strings. Add (almost) the expressive power of regular expressions to glob patterns.\char`\"{})
\item \href{https://www.npmjs.com/package/fill-range}{\tt fill-\/range}\+: Fill in a range of numbers or letters, optionally passing an increment or multiplier to… \href{https://github.com/jonschlinkert/fill-range}{\tt more} $\vert$ \href{https://github.com/jonschlinkert/fill-range}{\tt homepage}
\item \href{https://www.npmjs.com/package/gulp-micromatch}{\tt gulp-\/micromatch}\+: Filter vinyl files with glob patterns, string, regexp, array, object or matcher function. micromatch stream. $\vert$ \href{https://github.com/tunnckocore/gulp-micromatch#readme}{\tt homepage}
\item \href{https://www.npmjs.com/package/is-glob}{\tt is-\/glob}\+: Returns {\ttfamily true} if the given string looks like a glob pattern or an extglob pattern… \href{https://github.com/jonschlinkert/is-glob}{\tt more} $\vert$ \href{https://github.com/jonschlinkert/is-glob}{\tt homepage}
\item \href{https://www.npmjs.com/package/parse-glob}{\tt parse-\/glob}\+: Parse a glob pattern into an object of tokens. $\vert$ \href{https://github.com/jonschlinkert/parse-glob}{\tt homepage}
\end{DoxyItemize}

\subsection*{Contributing}

Pull requests and stars are always welcome. For bugs and feature requests, \href{../../issues/new}{\tt please create an issue}.

\subsection*{Building docs}

\+\_\+(This document was generated by \href{https://github.com/verbose/verb-generate-readme}{\tt verb-\/generate-\/readme} (a \href{https://github.com/verbose/verb}{\tt verb} generator), please don\textquotesingle{}t edit the readme directly. Any changes to the readme must be made in .verb.\+md \char`\"{}.\+verb.\+md\char`\"{}.)\+\_\+

To generate the readme and A\+PI documentation with \href{https://github.com/verbose/verb}{\tt verb}\+:


\begin{DoxyCode}
$ npm install -g verb verb-generate-readme && verb
\end{DoxyCode}


\subsection*{Running tests}

Install dev dependencies\+:


\begin{DoxyCode}
$ npm install -d && npm test
\end{DoxyCode}


\subsection*{Author}

{\bfseries Jon Schlinkert}


\begin{DoxyItemize}
\item \href{https://github.com/jonschlinkert}{\tt github/jonschlinkert}
\item \href{http://twitter.com/jonschlinkert}{\tt twitter/jonschlinkert}
\end{DoxyItemize}

\subsection*{License}

Copyright © 2016, \href{https://github.com/jonschlinkert}{\tt Jon Schlinkert}. Released under the \href{https://github.com/jonschlinkert/micromatch/blob/master/LICENSE}{\tt M\+IT license}.





{\itshape This file was generated by \href{https://github.com/verbose/verb}{\tt verb}, v0.\+9.\+0, on July 15, 2016.} 