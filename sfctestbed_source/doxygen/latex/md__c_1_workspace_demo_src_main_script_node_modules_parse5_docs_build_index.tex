 

\href{https://www.npmjs.com/package/parse5}{\tt } 

{\itshape W\+H\+A\+T\+WG H\+T\+M\+L5 specification-\/compliant, fast and ready for production H\+T\+ML parsing/serialization toolset for Node.} 

{\bfseries {\itshape parse5}} contains nearly everything what you will need to deal with the H\+T\+ML. It\textquotesingle{}s the fastest spec-\/compliant H\+T\+ML parser for Node to the date and will parse H\+T\+ML the way the latest version of your browser does. It\textquotesingle{}s stable and used by such projects as \href{https://github.com/tmpvar/jsdom}{\tt jsdom}, \href{https://github.com/angular/angular}{\tt Angular2}, \href{https://www.polymer-project.org/1.0/}{\tt Polymer} and many more.

\section*{Table of contents}


\begin{DoxyItemize}
\item \href{#install}{\tt Install}
\item \href{#usage}{\tt Usage}
\item \href{#api-reference}{\tt A\+PI Reference}
\item \href{#faq}{\tt F\+AQ}
\item \href{#version-history}{\tt Version history}
\item \href{#license-and-author-information}{\tt License}
\end{DoxyItemize}

\# Install 
\begin{DoxyCode}
$ npm install parse5
\end{DoxyCode}


\# Usage 
\begin{DoxyCode}
var parse5 = require('parse5');

var document     = parse5.parse('<!DOCTYPE html><html><body>Hi there!</body></html>');
var documentHtml = parse5.serialize(document);


var fragment     = parse5.parseFragment('<td>Yo!</td>');
var fragmentHtml = parse5.serialize(fragment);
\end{DoxyCode}
 For more advanced examples see \href{#api-reference}{\tt A\+PI reference} and \href{#faq}{\tt F\+AQ}.

\section*{A\+PI Reference}

\subsection*{Objects}


\begin{DoxyDescription}
\item[\href{#parse5}{\tt parse5} \+: {\ttfamily object} ]
\end{DoxyDescription}\subsection*{Typedefs}


\begin{DoxyDescription}
\item[\href{#ElementLocationInfo}{\tt Element\+Location\+Info} \+: {\ttfamily Object} ]
\item[\href{#LocationInfo}{\tt Location\+Info} \+: {\ttfamily Object} ]
\item[\href{#ParserOptions}{\tt Parser\+Options} \+: {\ttfamily Object} ]
\item[\href{#SAXParserOptions}{\tt S\+A\+X\+Parser\+Options} \+: {\ttfamily Object} ]
\item[\href{#SerializerOptions}{\tt Serializer\+Options} \+: {\ttfamily Object} ]
\item[\href{#TreeAdapter}{\tt Tree\+Adapter} \+: {\ttfamily Object} ]
\end{DoxyDescription}\label{_parse5}%
 \subsection*{parse5 \+: {\ttfamily object}}

{\bfseries Kind}\+: global namespace


\begin{DoxyItemize}
\item \href{#parse5}{\tt parse5} \+: {\ttfamily object}
\begin{DoxyItemize}
\item \href{#parse5+ParserStream}{\tt .Parser\+Stream} ⇐ {\ttfamily stream.\+Writable}
\begin{DoxyItemize}
\item \href{#new_parse5+ParserStream_new}{\tt new Parser\+Stream(options)}
\item \href{#parse5+ParserStream+document}{\tt .document} \+: {\ttfamily A\+S\+T\+Node.$<$document$>$}
\item \href{#parse5+ParserStream+event_script}{\tt \char`\"{}script\char`\"{} (script\+Element, document\+Write(html), resume)}
\end{DoxyItemize}
\item \href{#parse5+SAXParser}{\tt .S\+A\+X\+Parser} ⇐ {\ttfamily stream.\+Transform}
\begin{DoxyItemize}
\item \href{#new_parse5+SAXParser_new}{\tt new S\+A\+X\+Parser(options)}
\item \href{#parse5+SAXParser+stop}{\tt .stop()}
\item \href{#parse5+SAXParser+event_startTag}{\tt \char`\"{}start\+Tag\char`\"{} (name, attributes, self\+Closing, \mbox{[}location\mbox{]})}
\item \href{#parse5+SAXParser+event_endTag}{\tt \char`\"{}end\+Tag\char`\"{} (name, \mbox{[}location\mbox{]})}
\item \href{#parse5+SAXParser+event_comment}{\tt \char`\"{}comment\char`\"{} (text, \mbox{[}location\mbox{]})}
\item \href{#parse5+SAXParser+event_doctype}{\tt \char`\"{}doctype\char`\"{} (name, public\+Id, system\+Id, \mbox{[}location\mbox{]})}
\item \href{#parse5+SAXParser+event_text}{\tt \char`\"{}text\char`\"{} (text, \mbox{[}location\mbox{]})}
\end{DoxyItemize}
\item \href{#parse5+SerializerStream}{\tt .Serializer\+Stream} ⇐ {\ttfamily stream.\+Readable}
\begin{DoxyItemize}
\item \href{#new_parse5+SerializerStream_new}{\tt new Serializer\+Stream(node, \mbox{[}options\mbox{]})}
\end{DoxyItemize}
\item \href{#parse5+treeAdapters}{\tt .tree\+Adapters}
\item \href{#parse5+parse}{\tt .parse(html, \mbox{[}options\mbox{]})} ⇒ {\ttfamily A\+S\+T\+Node.$<$Document$>$}
\item \href{#parse5+parseFragment}{\tt .parse\+Fragment(\mbox{[}fragment\+Context\mbox{]}, html, \mbox{[}options\mbox{]})} ⇒ {\ttfamily A\+S\+T\+Node.$<$Document\+Fragment$>$}
\item \href{#parse5+serialize}{\tt .serialize(node, \mbox{[}options\mbox{]})} ⇒ {\ttfamily String}
\end{DoxyItemize}
\end{DoxyItemize}

\label{_parse5+ParserStream}%
 \subsubsection*{parse5.\+Parser\+Stream ⇐ {\ttfamily stream.\+Writable}}

{\bfseries Kind}\+: instance class of {\ttfamily \href{#parse5}{\tt parse5}} {\bfseries Extends\+:} {\ttfamily stream.\+Writable}


\begin{DoxyItemize}
\item \href{#parse5+ParserStream}{\tt .Parser\+Stream} ⇐ {\ttfamily stream.\+Writable}
\begin{DoxyItemize}
\item \href{#new_parse5+ParserStream_new}{\tt new Parser\+Stream(options)}
\item \href{#parse5+ParserStream+document}{\tt .document} \+: {\ttfamily A\+S\+T\+Node.$<$document$>$}
\item \href{#parse5+ParserStream+event_script}{\tt \char`\"{}script\char`\"{} (script\+Element, document\+Write(html), resume)}
\end{DoxyItemize}
\end{DoxyItemize}

\label{_new_parse5+ParserStream_new}%
 \paragraph*{new Parser\+Stream(options)}

Streaming H\+T\+ML parser with the scripting support. \href{https://nodejs.org/api/stream.html#stream_class_stream_writable}{\tt Writable stream}.

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
options  &{\ttfamily \href{#ParserOptions}{\tt Parser\+Options}}  &Parsing options.   \\\cline{1-3}
\end{longtabu}


{\bfseries Example} 
\begin{DoxyCode}
var parse5 = require('parse5');
var http = require('http');

// Fetch google.com content and obtain it's <body> node
http.get('http://google.com', function(res) \{
 var parser = new parse5.ParserStream();

 parser.on('finish', function() \{
     var body = parser.document.childNodes[0].childNodes[1];
 \});

 res.pipe(parser);
\});
\end{DoxyCode}
 \label{_parse5+ParserStream+document}%
 \paragraph*{parser\+Stream.\+document \+: {\ttfamily A\+S\+T\+Node.$<$document$>$}}

Resulting document node.

{\bfseries Kind}\+: instance property of {\ttfamily \href{#parse5+ParserStream}{\tt Parser\+Stream}} \label{_parse5+ParserStream+event_script}%
 \paragraph*{\char`\"{}script\char`\"{} (script\+Element, document\+Write(html), resume)}

Raised then parser encounters {\ttfamily $<$script$>$} element. If event has listeners then parsing will be suspended on event emission. So, if {\ttfamily $<$script$>$} has {\ttfamily src} attribute you can fetch it, execute and then resume parser like browsers do.

{\bfseries Kind}\+: event emitted by {\ttfamily \href{#parse5+ParserStream}{\tt Parser\+Stream}}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
script\+Element  &{\ttfamily A\+S\+T\+Node}  &Script element that caused the event.   \\\cline{1-3}
document\+Write(html)  &{\ttfamily function}  &Write additional {\ttfamily html} at the current parsing position. Suitable for the D\+OM {\ttfamily document.\+write} and {\ttfamily document.\+writeln} methods implementation.   \\\cline{1-3}
resume  &{\ttfamily function}  &Resumes the parser.   \\\cline{1-3}
\end{longtabu}


{\bfseries Example} \`{}\`{}`js var parse = require(\textquotesingle{}parse5'); var http = require(\textquotesingle{}http\textquotesingle{});

var parser = new parse5.\+Parser\+Stream();

parser.\+on(\textquotesingle{}script\textquotesingle{}, function(script\+Element, document\+Write, resume) \{ var src = parse5.\+tree\+Adapters.\+default.\+get\+Attr\+List(script\+Element)\mbox{[}0\mbox{]}.value;

http.\+get(src, function(res) \{ // Fetch script content, execute it with D\+OM built around {\ttfamily parser.\+document} and // {\ttfamily document.\+write} implemented using {\ttfamily document\+Write} ... // Then resume the parser resume(); \}); \});

parser.\+end(\textquotesingle{}$<$script src=\char`\"{}example.\+com/script.\+js\char`\"{}$>$$<$/script$>$\textquotesingle{}); 
\begin{DoxyCode}
<a name="parse5+SAXParser"></a>
### parse5.SAXParser ⇐ <code>stream.Transform</code>
**Kind**: instance class of <code>[parse5](#parse5)</code>
**Extends:** <code>stream.Transform</code>

* [.SAXParser](#parse5+SAXParser) ⇐ <code>stream.Transform</code>
  * [new SAXParser(options)](#new\_parse5+SAXParser\_new)
  * [.stop()](#parse5+SAXParser+stop)
  * ["startTag" (name, attributes, selfClosing, [location])](#parse5+SAXParser+event\_startTag)
  * ["endTag" (name, [location])](#parse5+SAXParser+event\_endTag)
  * ["comment" (text, [location])](#parse5+SAXParser+event\_comment)
  * ["doctype" (name, publicId, systemId, [location])](#parse5+SAXParser+event\_doctype)
  * ["text" (text, [location])](#parse5+SAXParser+event\_text)

<a name="new\_parse5+SAXParser\_new"></a>
#### new SAXParser(options)
Streaming [SAX](https://en.wikipedia.org/wiki/Simple\_API\_for\_XML)-style HTML parser.
[Transform stream](https://nodejs.org/api/stream.html#stream\_class\_stream\_transform)
(which means you can pipe *through* it, see example).


| Param | Type | Description |
| --- | --- | --- |
| options | <code>[SAXParserOptions](#SAXParserOptions)</code> | Parsing options. |

**Example**
```js
var parse5 = require('parse5');
var http = require('http');
var fs = require('fs');

var file = fs.createWriteStream('/home/google.com.html');
var parser = new SAXParser();

parser.on('text', function(text) \{
 // Handle page text content
 ...
\});

http.get('http://google.com', function(res) \{
 // SAXParser is the Transform stream, which means you can pipe
 // through it. So you can analyze page content and e.g. save it
 // to the file at the same time:
 res.pipe(parser).pipe(file);
\});
\end{DoxyCode}
 \label{_parse5+SAXParser+stop}%
 \paragraph*{sax\+Parser.\+stop()}

Stops parsing. Useful if you want parser to stop consume C\+PU time once you\textquotesingle{}ve obtained desired info from input stream. Doesn\textquotesingle{}t prevents piping, so data will flow through parser as usual.

{\bfseries Kind}\+: instance method of {\ttfamily \href{#parse5+SAXParser}{\tt S\+A\+X\+Parser}} {\bfseries Example} 
\begin{DoxyCode}
var parse5 = require('parse5');
var http = require('http');
var fs = require('fs');

var file = fs.createWriteStream('/home/google.com.html');
var parser = new parse5.SAXParser();

parser.on('doctype', function(name, publicId, systemId) \{
 // Process doctype info ans stop parsing
 ...
 parser.stop();
\});

http.get('http://google.com', function(res) \{
 // Despite the fact that parser.stop() was called whole
 // content of the page will be written to the file
 res.pipe(parser).pipe(file);
\});
\end{DoxyCode}
 \label{_parse5+SAXParser+event_startTag}%
 \paragraph*{\char`\"{}start\+Tag\char`\"{} (name, attributes, self\+Closing, \mbox{[}location\mbox{]})}

Raised then parser encounters start tag.

{\bfseries Kind}\+: event emitted by {\ttfamily \href{#parse5+SAXParser}{\tt S\+A\+X\+Parser}}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
name  &{\ttfamily String}  &Tag name.   \\\cline{1-3}
attributes  &{\ttfamily String}  &List of attributes in {\ttfamily \{ key\+: String, value\+: String \}} form.   \\\cline{1-3}
self\+Closing  &{\ttfamily Boolean}  &Indicates if tag is self-\/closing.   \\\cline{1-3}
\mbox{[}location\mbox{]}  &{\ttfamily \href{#LocationInfo}{\tt Location\+Info}}  &Start tag source code location info. Available if location info is enabled in \href{#SAXParserOptions}{\tt S\+A\+X\+Parser\+Options}.   \\\cline{1-3}
\end{longtabu}


\label{_parse5+SAXParser+event_endTag}%
 \paragraph*{\char`\"{}end\+Tag\char`\"{} (name, \mbox{[}location\mbox{]})}

Raised then parser encounters end tag.

{\bfseries Kind}\+: event emitted by {\ttfamily \href{#parse5+SAXParser}{\tt S\+A\+X\+Parser}}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
name  &{\ttfamily String}  &Tag name.   \\\cline{1-3}
\mbox{[}location\mbox{]}  &{\ttfamily \href{#LocationInfo}{\tt Location\+Info}}  &End tag source code location info. Available if location info is enabled in \href{#SAXParserOptions}{\tt S\+A\+X\+Parser\+Options}.   \\\cline{1-3}
\end{longtabu}


\label{_parse5+SAXParser+event_comment}%
 \paragraph*{\char`\"{}comment\char`\"{} (text, \mbox{[}location\mbox{]})}

Raised then parser encounters comment.

{\bfseries Kind}\+: event emitted by {\ttfamily \href{#parse5+SAXParser}{\tt S\+A\+X\+Parser}}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
text  &{\ttfamily String}  &Comment text.   \\\cline{1-3}
\mbox{[}location\mbox{]}  &{\ttfamily \href{#LocationInfo}{\tt Location\+Info}}  &Comment source code location info. Available if location info is enabled in \href{#SAXParserOptions}{\tt S\+A\+X\+Parser\+Options}.   \\\cline{1-3}
\end{longtabu}


\label{_parse5+SAXParser+event_doctype}%
 \paragraph*{\char`\"{}doctype\char`\"{} (name, public\+Id, system\+Id, \mbox{[}location\mbox{]})}

Raised then parser encounters \href{https://en.wikipedia.org/wiki/Document_type_declaration}{\tt document type declaration}.

{\bfseries Kind}\+: event emitted by {\ttfamily \href{#parse5+SAXParser}{\tt S\+A\+X\+Parser}}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
name  &{\ttfamily String}  &Document type name.   \\\cline{1-3}
public\+Id  &{\ttfamily String}  &Document type public identifier.   \\\cline{1-3}
system\+Id  &{\ttfamily String}  &Document type system identifier.   \\\cline{1-3}
\mbox{[}location\mbox{]}  &{\ttfamily \href{#LocationInfo}{\tt Location\+Info}}  &Document type declaration source code location info. Available if location info is enabled in \href{#SAXParserOptions}{\tt S\+A\+X\+Parser\+Options}.   \\\cline{1-3}
\end{longtabu}


\label{_parse5+SAXParser+event_text}%
 \paragraph*{\char`\"{}text\char`\"{} (text, \mbox{[}location\mbox{]})}

Raised then parser encounters text content.

{\bfseries Kind}\+: event emitted by {\ttfamily \href{#parse5+SAXParser}{\tt S\+A\+X\+Parser}}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
text  &{\ttfamily String}  &Text content.   \\\cline{1-3}
\mbox{[}location\mbox{]}  &{\ttfamily \href{#LocationInfo}{\tt Location\+Info}}  &Text content code location info. Available if location info is enabled in \href{#SAXParserOptions}{\tt S\+A\+X\+Parser\+Options}.   \\\cline{1-3}
\end{longtabu}


\label{_parse5+SerializerStream}%
 \subsubsection*{parse5.\+Serializer\+Stream ⇐ {\ttfamily stream.\+Readable}}

{\bfseries Kind}\+: instance class of {\ttfamily \href{#parse5}{\tt parse5}} {\bfseries Extends\+:} {\ttfamily stream.\+Readable} \label{_new_parse5+SerializerStream_new}%
 \paragraph*{new Serializer\+Stream(node, \mbox{[}options\mbox{]})}

Streaming A\+ST node to H\+T\+ML serializer. \href{https://nodejs.org/api/stream.html#stream_class_stream_readable}{\tt Readable stream}.

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
node  &{\ttfamily A\+S\+T\+Node}  &Node to serialize.   \\\cline{1-3}
\mbox{[}options\mbox{]}  &{\ttfamily \href{#SerializerOptions}{\tt Serializer\+Options}}  &Serialization options.   \\\cline{1-3}
\end{longtabu}


{\bfseries Example} 
\begin{DoxyCode}
var parse5 = require('parse5');
var fs = require('fs');

var file = fs.createWriteStream('/home/index.html');

// Serialize parsed document to the HTML and write it to file
var document = parse5.parse('<body>Who is John Galt?</body>');
var serializer = new parse5.SerializerStream(document);

serializer.pipe(file);
\end{DoxyCode}
 \label{_parse5+treeAdapters}%
 \subsubsection*{parse5.\+tree\+Adapters}

Provides built-\/in tree adapters which can be used for parsing and serialization.

{\bfseries Kind}\+: instance property of {\ttfamily \href{#parse5}{\tt parse5}} {\bfseries Properties}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Name  }&\textbf{ Type  }&\textbf{ De   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Name  }&\textbf{ Type  }&\textbf{ De   }\\\cline{1-3}
\endhead
default  &{\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}}  &Default tree format for parse5.   \\\cline{1-3}
htmlparser2  &{\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}}  &Quite popular \href{https://github.com/fb55/htmlparser2}{\tt htmlparser2} tree format (e.\+g. used by \href{https://github.com/MatthewMueller/cheerio}{\tt cheerio} and \href{https://github.com/tmpvar/jsdom}{\tt jsdom}).   \\\cline{1-3}
\end{longtabu}


{\bfseries Example} 
\begin{DoxyCode}
var parse5 = require('parse5');

// Use default tree adapter for parsing
var document = parse5.parse('<div></div>', \{ treeAdapter: parse5.treeAdapters.default \});

// Use htmlparser2 tree adapter with SerializerStream
var serializer = new parse5.SerializerStream(node, \{ treeAdapter: parse5.treeAdapters.htmlparser2 \});
\end{DoxyCode}
 \label{_parse5+parse}%
 \subsubsection*{parse5.\+parse(html, \mbox{[}options\mbox{]}) ⇒ {\ttfamily A\+S\+T\+Node.$<$Document$>$}}

Parses H\+T\+ML string.

{\bfseries Kind}\+: instance method of {\ttfamily \href{#parse5}{\tt parse5}} {\bfseries Returns}\+: {\ttfamily A\+S\+T\+Node.$<$Document$>$} -\/ document

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
html  &{\ttfamily string}  &Input H\+T\+ML string.   \\\cline{1-3}
\mbox{[}options\mbox{]}  &{\ttfamily \href{#ParserOptions}{\tt Parser\+Options}}  &Parsing options.   \\\cline{1-3}
\end{longtabu}


{\bfseries Example} 
\begin{DoxyCode}
var parse5 = require('parse5');

var document = parse5.parse('<!DOCTYPE html><html><head></head><body>Hi there!</body></html>');
\end{DoxyCode}
 \label{_parse5+parseFragment}%
 \subsubsection*{parse5.\+parse\+Fragment(\mbox{[}fragment\+Context\mbox{]}, html, \mbox{[}options\mbox{]}) ⇒ {\ttfamily A\+S\+T\+Node.$<$Document\+Fragment$>$}}

Parses H\+T\+ML fragment.

{\bfseries Kind}\+: instance method of {\ttfamily \href{#parse5}{\tt parse5}} {\bfseries Returns}\+: {\ttfamily A\+S\+T\+Node.$<$Document\+Fragment$>$} -\/ document\+Fragment

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
\mbox{[}fragment\+Context\mbox{]}  &{\ttfamily A\+S\+T\+Node}  &Parsing context element. If specified, given fragment will be parsed as if it was set to the context element\textquotesingle{}s {\ttfamily inner\+H\+T\+ML} property.   \\\cline{1-3}
html  &{\ttfamily string}  &Input H\+T\+ML fragment string.   \\\cline{1-3}
\mbox{[}options\mbox{]}  &{\ttfamily \href{#ParserOptions}{\tt Parser\+Options}}  &Parsing options.   \\\cline{1-3}
\end{longtabu}


{\bfseries Example} 
\begin{DoxyCode}
var parse5 = require('parse5');

var documentFragment = parse5.parseFragment('<table></table>');

//Parse html fragment in context of the parsed <table> element
var trFragment = parser.parseFragment(documentFragment.childNodes[0], '<tr><td>Shake it, baby</td></tr>');
\end{DoxyCode}
 \label{_parse5+serialize}%
 \subsubsection*{parse5.\+serialize(node, \mbox{[}options\mbox{]}) ⇒ {\ttfamily String}}

Serializes A\+ST node to H\+T\+ML string.

{\bfseries Kind}\+: instance method of {\ttfamily \href{#parse5}{\tt parse5}} {\bfseries Returns}\+: {\ttfamily String} -\/ html

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
node  &{\ttfamily A\+S\+T\+Node}  &Node to serialize.   \\\cline{1-3}
\mbox{[}options\mbox{]}  &{\ttfamily \href{#SerializerOptions}{\tt Serializer\+Options}}  &Serialization options.   \\\cline{1-3}
\end{longtabu}


{\bfseries Example} 
\begin{DoxyCode}
var parse5 = require('parse5');

var document = parse5.parse('<!DOCTYPE html><html><head></head><body>Hi there!</body></html>');

//Serialize document
var html = parse5.serialize(document);

//Serialize <body> element content
var bodyInnerHtml = parse5.serialize(document.childNodes[0].childNodes[1]);
\end{DoxyCode}
 \label{_ElementLocationInfo}%
 \subsection*{Element\+Location\+Info \+: {\ttfamily Object}}

{\bfseries Kind}\+: global typedef {\bfseries Extends\+:} {\ttfamily \href{#LocationInfo}{\tt Location\+Info}} {\bfseries Properties}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Name  }&\textbf{ Type  }&\textbf{ De   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Name  }&\textbf{ Type  }&\textbf{ De   }\\\cline{1-3}
\endhead
start\+Tag  &{\ttfamily \href{#LocationInfo}{\tt Location\+Info}}  &Element\textquotesingle{}s start tag \href{#LocationInfo}{\tt Location\+Info}.   \\\cline{1-3}
end\+Tag  &{\ttfamily \href{#LocationInfo}{\tt Location\+Info}}  &Element\textquotesingle{}s end tag \href{#LocationInfo}{\tt Location\+Info}.   \\\cline{1-3}
\end{longtabu}


\label{_LocationInfo}%
 \subsection*{Location\+Info \+: {\ttfamily Object}}

{\bfseries Kind}\+: global typedef {\bfseries Properties}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Name  }&\textbf{ Type  }&\textbf{ De   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Name  }&\textbf{ Type  }&\textbf{ De   }\\\cline{1-3}
\endhead
line  &{\ttfamily Number}  &One-\/based line index   \\\cline{1-3}
col  &{\ttfamily Number}  &One-\/based column index   \\\cline{1-3}
start\+Offset  &{\ttfamily Number}  &Zero-\/based first character index   \\\cline{1-3}
end\+Offset  &{\ttfamily Number}  &Zero-\/based last character index   \\\cline{1-3}
\end{longtabu}


\label{_ParserOptions}%
 \subsection*{Parser\+Options \+: {\ttfamily Object}}

{\bfseries Kind}\+: global typedef {\bfseries Properties}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Name  }&\textbf{ Type  }&\multicolumn{2}{p{(\linewidth-\tabcolsep*4-\arrayrulewidth*3)*2/4}|}{\cellcolor{\tableheadbgcolor}\textbf{ Default   }}\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Name  }&\textbf{ Type  }&\multicolumn{2}{p{(\linewidth-\tabcolsep*4-\arrayrulewidth*3)*2/4}|}{\cellcolor{\tableheadbgcolor}\textbf{ Default   }}\\\cline{1-4}
\endhead
location\+Info  &{\ttfamily Boolean}  &{\ttfamily false}  &Enables source code location information for the nodes. When enabled, each node (except root node) has {\ttfamily \+\_\+\+\_\+location} property. In case the node is not an empty element, {\ttfamily \+\_\+\+\_\+location} will be \href{#ElementLocationInfo}{\tt Element\+Location\+Info} object, otherwise it\textquotesingle{}s \href{#LocationInfo}{\tt Location\+Info}. If element was implicitly created by the parser it\textquotesingle{}s {\ttfamily \+\_\+\+\_\+location} property will be {\ttfamily null}.   \\\cline{1-4}
tree\+Adapter  &{\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}}  &{\ttfamily parse5.\+tree\+Adapters.\+default}  &Specifies resulting tree format.   \\\cline{1-4}
\end{longtabu}


\label{_SAXParserOptions}%
 \subsection*{S\+A\+X\+Parser\+Options \+: {\ttfamily Object}}

{\bfseries Kind}\+: global typedef {\bfseries Properties}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Name  }&\textbf{ Type  }&\multicolumn{2}{p{(\linewidth-\tabcolsep*4-\arrayrulewidth*3)*2/4}|}{\cellcolor{\tableheadbgcolor}\textbf{ Default   }}\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Name  }&\textbf{ Type  }&\multicolumn{2}{p{(\linewidth-\tabcolsep*4-\arrayrulewidth*3)*2/4}|}{\cellcolor{\tableheadbgcolor}\textbf{ Default   }}\\\cline{1-4}
\endhead
location\+Info  &{\ttfamily Boolean}  &{\ttfamily false}  &Enables source code location information for the tokens. When enabled, each token event handler will receive \href{#LocationInfo}{\tt Location\+Info} object as the last argument.   \\\cline{1-4}
\end{longtabu}


\label{_SerializerOptions}%
 \subsection*{Serializer\+Options \+: {\ttfamily Object}}

{\bfseries Kind}\+: global typedef {\bfseries Properties}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Name  }&\textbf{ Type  }&\multicolumn{2}{p{(\linewidth-\tabcolsep*4-\arrayrulewidth*3)*2/4}|}{\cellcolor{\tableheadbgcolor}\textbf{ Default   }}\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Name  }&\textbf{ Type  }&\multicolumn{2}{p{(\linewidth-\tabcolsep*4-\arrayrulewidth*3)*2/4}|}{\cellcolor{\tableheadbgcolor}\textbf{ Default   }}\\\cline{1-4}
\endhead
tree\+Adapter  &{\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}}  &{\ttfamily parse5.\+tree\+Adapters.\+default}  &Specifies input tree format.   \\\cline{1-4}
\end{longtabu}


\label{_TreeAdapter}%
 \subsection*{Tree\+Adapter \+: {\ttfamily Object}}

{\bfseries Kind}\+: global typedef


\begin{DoxyItemize}
\item \href{#TreeAdapter}{\tt Tree\+Adapter} \+: {\ttfamily Object}
\begin{DoxyItemize}
\item \href{#TreeAdapter.createDocument}{\tt .create\+Document()} ⇒ {\ttfamily A\+S\+T\+Node.$<$Document$>$}
\item \href{#TreeAdapter.createDocumentFragment}{\tt .create\+Document\+Fragment()} ⇒ {\ttfamily A\+S\+T\+Node.$<$Document\+Fragment$>$}
\item \href{#TreeAdapter.createElement}{\tt .create\+Element(tag\+Name, namespace\+U\+R\+I, attrs)} ⇒ {\ttfamily A\+S\+T\+Node.$<$Element$>$}
\item \href{#TreeAdapter.createElement}{\tt .create\+Element(data)} ⇒ {\ttfamily A\+S\+T\+Node.$<$Comment\+Node$>$}
\item \href{#TreeAdapter.setDocumentType}{\tt .set\+Document\+Type(document, name, public\+Id, system\+Id)}
\item \href{#TreeAdapter.setQuirksMode}{\tt .set\+Quirks\+Mode(document)}
\item \href{#TreeAdapter.setQuirksMode}{\tt .set\+Quirks\+Mode(document)} ⇒ {\ttfamily Boolean}
\item \href{#TreeAdapter.detachNode}{\tt .detach\+Node(node)}
\item \href{#TreeAdapter.insertText}{\tt .insert\+Text(parent\+Node, text)}
\item \href{#TreeAdapter.insertTextBefore}{\tt .insert\+Text\+Before(parent\+Node, text, reference\+Node)}
\item \href{#TreeAdapter.adoptAttributes}{\tt .adopt\+Attributes(recipient\+Node, attrs)}
\item \href{#TreeAdapter.getFirstChild}{\tt .get\+First\+Child(node)} ⇒ {\ttfamily A\+S\+T\+Node}
\item \href{#TreeAdapter.getChildNodes}{\tt .get\+Child\+Nodes(node)} ⇒ {\ttfamily Array}
\item \href{#TreeAdapter.getParentNode}{\tt .get\+Parent\+Node(node)} ⇒ {\ttfamily A\+S\+T\+Node}
\item \href{#TreeAdapter.getAttrList}{\tt .get\+Attr\+List(node)} ⇒ {\ttfamily Array}
\item \href{#TreeAdapter.getTagName}{\tt .get\+Tag\+Name(element)} ⇒ {\ttfamily String}
\item \href{#TreeAdapter.getNamespaceURI}{\tt .get\+Namespace\+U\+R\+I(element)} ⇒ {\ttfamily String}
\item \href{#TreeAdapter.getTextNodeContent}{\tt .get\+Text\+Node\+Content(text\+Node)} ⇒ {\ttfamily String}
\item \href{#TreeAdapter.getTextNodeContent}{\tt .get\+Text\+Node\+Content(comment\+Node)} ⇒ {\ttfamily String}
\item \href{#TreeAdapter.getDocumentTypeNodeName}{\tt .get\+Document\+Type\+Node\+Name(doctype\+Node)} ⇒ {\ttfamily String}
\item \href{#TreeAdapter.getDocumentTypeNodePublicId}{\tt .get\+Document\+Type\+Node\+Public\+Id(doctype\+Node)} ⇒ {\ttfamily String}
\item \href{#TreeAdapter.getDocumentTypeNodeSystemId}{\tt .get\+Document\+Type\+Node\+System\+Id(doctype\+Node)} ⇒ {\ttfamily String}
\item \href{#TreeAdapter.isTextNode}{\tt .is\+Text\+Node(node)} ⇒ {\ttfamily Boolean}
\item \href{#TreeAdapter.isCommentNode}{\tt .is\+Comment\+Node(node)} ⇒ {\ttfamily Boolean}
\item \href{#TreeAdapter.isDocumentTypeNode}{\tt .is\+Document\+Type\+Node(node)} ⇒ {\ttfamily Boolean}
\item \href{#TreeAdapter.isElementNode}{\tt .is\+Element\+Node(node)} ⇒ {\ttfamily Boolean}
\end{DoxyItemize}
\end{DoxyItemize}

\label{_TreeAdapter.createDocument}%
 \subsubsection*{Tree\+Adapter.\+create\+Document() ⇒ {\ttfamily A\+S\+T\+Node.$<$Document$>$}}

Creates document node

{\bfseries Kind}\+: static method of {\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}} {\bfseries Returns}\+: {\ttfamily A\+S\+T\+Node.$<$Document$>$} -\/ document {\bfseries See}\+: \href{https://github.com/inikulin/parse5/blob/tree-adapter-docs-rev/lib/tree_adapters/default.js#L19}{\tt default implementation.} \label{_TreeAdapter.createDocumentFragment}%
 \subsubsection*{Tree\+Adapter.\+create\+Document\+Fragment() ⇒ {\ttfamily A\+S\+T\+Node.$<$Document\+Fragment$>$}}

Creates document fragment node

{\bfseries Kind}\+: static method of {\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}} {\bfseries Returns}\+: {\ttfamily A\+S\+T\+Node.$<$Document\+Fragment$>$} -\/ fragment {\bfseries See}\+: \href{https://github.com/inikulin/parse5/blob/tree-adapter-docs-rev/lib/tree_adapters/default.js#L37}{\tt default implementation.} \label{_TreeAdapter.createElement}%
 \subsubsection*{Tree\+Adapter.\+create\+Element(tag\+Name, namespace\+U\+R\+I, attrs) ⇒ {\ttfamily A\+S\+T\+Node.$<$Element$>$}}

Creates element node

{\bfseries Kind}\+: static method of {\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}} {\bfseries Returns}\+: {\ttfamily A\+S\+T\+Node.$<$Element$>$} -\/ element {\bfseries See}\+: \href{https://github.com/inikulin/parse5/blob/tree-adapter-docs-rev/lib/tree_adapters/default.js#L61}{\tt default implementation.}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
tag\+Name  &{\ttfamily String}  &Tag name of the element.   \\\cline{1-3}
namespace\+U\+RI  &{\ttfamily String}  &Namespace of the element.   \\\cline{1-3}
attrs  &{\ttfamily Array}  &Attribute name-\/value pair array. Foreign attributes may contain {\ttfamily namespace} and {\ttfamily prefix} fields as well.   \\\cline{1-3}
\end{longtabu}


\label{_TreeAdapter.createElement}%
 \subsubsection*{Tree\+Adapter.\+create\+Element(data) ⇒ {\ttfamily A\+S\+T\+Node.$<$Comment\+Node$>$}}

Creates comment node

{\bfseries Kind}\+: static method of {\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}} {\bfseries Returns}\+: {\ttfamily A\+S\+T\+Node.$<$Comment\+Node$>$} -\/ comment {\bfseries See}\+: \href{https://github.com/inikulin/parse5/blob/tree-adapter-docs-rev/lib/tree_adapters/default.js#L85}{\tt default implementation.}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
data  &{\ttfamily String}  &Comment text.   \\\cline{1-3}
\end{longtabu}


\label{_TreeAdapter.setDocumentType}%
 \subsubsection*{Tree\+Adapter.\+set\+Document\+Type(document, name, public\+Id, system\+Id)}

Sets document type. If {\ttfamily document} already have document type node in it then {\ttfamily name}, {\ttfamily public\+Id} and {\ttfamily system\+Id} properties of the node will be updated with the provided values. Otherwise, creates new document type node with the given properties and inserts it into {\ttfamily document}.

{\bfseries Kind}\+: static method of {\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}} {\bfseries See}\+: \href{https://github.com/inikulin/parse5/blob/tree-adapter-docs-rev/lib/tree_adapters/default.js#L131}{\tt default implementation.}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
document  &{\ttfamily A\+S\+T\+Node.$<$Document$>$}  &Document node.   \\\cline{1-3}
name  &{\ttfamily String}  &Document type name.   \\\cline{1-3}
public\+Id  &{\ttfamily String}  &Document type public identifier.   \\\cline{1-3}
system\+Id  &{\ttfamily String}  &Document type system identifier.   \\\cline{1-3}
\end{longtabu}


\label{_TreeAdapter.setQuirksMode}%
 \subsubsection*{Tree\+Adapter.\+set\+Quirks\+Mode(document)}

Sets document quirks mode flag.

{\bfseries Kind}\+: static method of {\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}} {\bfseries See}\+: \href{https://github.com/inikulin/parse5/blob/tree-adapter-docs-rev/lib/tree_adapters/default.js#L167}{\tt default implementation.}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
document  &{\ttfamily A\+S\+T\+Node.$<$Document$>$}  &Document node.   \\\cline{1-3}
\end{longtabu}


\label{_TreeAdapter.setQuirksMode}%
 \subsubsection*{Tree\+Adapter.\+set\+Quirks\+Mode(document) ⇒ {\ttfamily Boolean}}

Determines if document quirks mode flag is set.

{\bfseries Kind}\+: static method of {\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}} {\bfseries See}\+: \href{https://github.com/inikulin/parse5/blob/tree-adapter-docs-rev/lib/tree_adapters/default.js#L183}{\tt default implementation.}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
document  &{\ttfamily A\+S\+T\+Node.$<$Document$>$}  &Document node.   \\\cline{1-3}
\end{longtabu}


\label{_TreeAdapter.detachNode}%
 \subsubsection*{Tree\+Adapter.\+detach\+Node(node)}

Removes node from it\textquotesingle{}s parent.

{\bfseries Kind}\+: static method of {\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}} {\bfseries See}\+: \href{https://github.com/inikulin/parse5/blob/tree-adapter-docs-rev/lib/tree_adapters/default.js#L197}{\tt default implementation.}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
node  &{\ttfamily A\+S\+T\+Node}  &Node.   \\\cline{1-3}
\end{longtabu}


\label{_TreeAdapter.insertText}%
 \subsubsection*{Tree\+Adapter.\+insert\+Text(parent\+Node, text)}

Inserts text into node. If the last child of the node is the text node then provided text will be appended to the text node content. Otherwise, inserts new text node with the given text.

{\bfseries Kind}\+: static method of {\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}} {\bfseries See}\+: \href{https://github.com/inikulin/parse5/blob/tree-adapter-docs-rev/lib/tree_adapters/default.js#L220}{\tt default implementation.}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
parent\+Node  &{\ttfamily A\+S\+T\+Node}  &Node to insert text into.   \\\cline{1-3}
text  &{\ttfamily String}  &Text to insert.   \\\cline{1-3}
\end{longtabu}


\label{_TreeAdapter.insertTextBefore}%
 \subsubsection*{Tree\+Adapter.\+insert\+Text\+Before(parent\+Node, text, reference\+Node)}

Inserts text into node before the referenced child node. If node before the referenced child node is the text node then provided text will be appended to the text node content. Otherwise, inserts new text node with the given text before the referenced child node.

{\bfseries Kind}\+: static method of {\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}} {\bfseries See}\+: \href{https://github.com/inikulin/parse5/blob/tree-adapter-docs-rev/lib/tree_adapters/default.js#L249}{\tt default implementation.}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
parent\+Node  &{\ttfamily A\+S\+T\+Node}  &Node to insert text into.   \\\cline{1-3}
text  &{\ttfamily String}  &Text to insert.   \\\cline{1-3}
reference\+Node  &{\ttfamily A\+S\+T\+Node}  &Node to insert text before.   \\\cline{1-3}
\end{longtabu}


\label{_TreeAdapter.adoptAttributes}%
 \subsubsection*{Tree\+Adapter.\+adopt\+Attributes(recipient\+Node, attrs)}

Copies attributes to the given node. Only those nodes which are not yet present in the node are copied.

{\bfseries Kind}\+: static method of {\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}} {\bfseries See}\+: \href{https://github.com/inikulin/parse5/blob/tree-adapter-docs-rev/lib/tree_adapters/default.js#L270}{\tt default implementation.}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
recipient\+Node  &{\ttfamily A\+S\+T\+Node}  &Node to copy attributes into.   \\\cline{1-3}
attrs  &{\ttfamily Array}  &Attributes to copy.   \\\cline{1-3}
\end{longtabu}


\label{_TreeAdapter.getFirstChild}%
 \subsubsection*{Tree\+Adapter.\+get\+First\+Child(node) ⇒ {\ttfamily A\+S\+T\+Node}}

Returns first child of the given node.

{\bfseries Kind}\+: static method of {\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}} {\bfseries Returns}\+: {\ttfamily A\+S\+T\+Node} -\/ first\+Child {\bfseries See}\+: \href{https://github.com/inikulin/parse5/blob/tree-adapter-docs-rev/lib/tree_adapters/default.js#L297}{\tt default implementation.}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
node  &{\ttfamily A\+S\+T\+Node}  &Node.   \\\cline{1-3}
\end{longtabu}


\label{_TreeAdapter.getChildNodes}%
 \subsubsection*{Tree\+Adapter.\+get\+Child\+Nodes(node) ⇒ {\ttfamily Array}}

Returns array of the given node\textquotesingle{}s children.

{\bfseries Kind}\+: static method of {\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}} {\bfseries Returns}\+: {\ttfamily Array} -\/ children {\bfseries See}\+: \href{https://github.com/inikulin/parse5/blob/tree-adapter-docs-rev/lib/tree_adapters/default.js#L313}{\tt default implementation.}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
node  &{\ttfamily A\+S\+T\+Node}  &Node.   \\\cline{1-3}
\end{longtabu}


\label{_TreeAdapter.getParentNode}%
 \subsubsection*{Tree\+Adapter.\+get\+Parent\+Node(node) ⇒ {\ttfamily A\+S\+T\+Node}}

Returns given node\textquotesingle{}s parent.

{\bfseries Kind}\+: static method of {\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}} {\bfseries Returns}\+: {\ttfamily A\+S\+T\+Node} -\/ parent {\bfseries See}\+: \href{https://github.com/inikulin/parse5/blob/tree-adapter-docs-rev/lib/tree_adapters/default.js#L329}{\tt default implementation.}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
node  &{\ttfamily A\+S\+T\+Node}  &Node.   \\\cline{1-3}
\end{longtabu}


\label{_TreeAdapter.getAttrList}%
 \subsubsection*{Tree\+Adapter.\+get\+Attr\+List(node) ⇒ {\ttfamily Array}}

Returns array of the given node\textquotesingle{}s attributes in form of the name-\/value pair. Foreign attributes may contain {\ttfamily namespace} and {\ttfamily prefix} fields as well.

{\bfseries Kind}\+: static method of {\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}} {\bfseries Returns}\+: {\ttfamily Array} -\/ attributes {\bfseries See}\+: \href{https://github.com/inikulin/parse5/blob/tree-adapter-docs-rev/lib/tree_adapters/default.js#L346}{\tt default implementation.}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
node  &{\ttfamily A\+S\+T\+Node}  &Node.   \\\cline{1-3}
\end{longtabu}


\label{_TreeAdapter.getTagName}%
 \subsubsection*{Tree\+Adapter.\+get\+Tag\+Name(element) ⇒ {\ttfamily String}}

Returns given element\textquotesingle{}s tag name.

{\bfseries Kind}\+: static method of {\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}} {\bfseries Returns}\+: {\ttfamily String} -\/ tag\+Name {\bfseries See}\+: \href{https://github.com/inikulin/parse5/blob/tree-adapter-docs-rev/lib/tree_adapters/default.js#L364}{\tt default implementation.}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
element  &{\ttfamily A\+S\+T\+Node.$<$Element$>$}  &Element.   \\\cline{1-3}
\end{longtabu}


\label{_TreeAdapter.getNamespaceURI}%
 \subsubsection*{Tree\+Adapter.\+get\+Namespace\+U\+R\+I(element) ⇒ {\ttfamily String}}

Returns given element\textquotesingle{}s namespace.

{\bfseries Kind}\+: static method of {\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}} {\bfseries Returns}\+: {\ttfamily String} -\/ namespace\+U\+RI {\bfseries See}\+: \href{https://github.com/inikulin/parse5/blob/tree-adapter-docs-rev/lib/tree_adapters/default.js#L380}{\tt default implementation.}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
element  &{\ttfamily A\+S\+T\+Node.$<$Element$>$}  &Element.   \\\cline{1-3}
\end{longtabu}


\label{_TreeAdapter.getTextNodeContent}%
 \subsubsection*{Tree\+Adapter.\+get\+Text\+Node\+Content(text\+Node) ⇒ {\ttfamily String}}

Returns given text node\textquotesingle{}s content.

{\bfseries Kind}\+: static method of {\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}} {\bfseries Returns}\+: {\ttfamily String} -\/ text {\bfseries See}\+: \href{https://github.com/inikulin/parse5/blob/tree-adapter-docs-rev/lib/tree_adapters/default.js#L396}{\tt default implementation.}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
text\+Node  &{\ttfamily A\+S\+T\+Node.$<$Text$>$}  &Text node.   \\\cline{1-3}
\end{longtabu}


\label{_TreeAdapter.getTextNodeContent}%
 \subsubsection*{Tree\+Adapter.\+get\+Text\+Node\+Content(comment\+Node) ⇒ {\ttfamily String}}

Returns given comment node\textquotesingle{}s content.

{\bfseries Kind}\+: static method of {\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}} {\bfseries Returns}\+: {\ttfamily String} -\/ comment\+Text {\bfseries See}\+: \href{https://github.com/inikulin/parse5/blob/tree-adapter-docs-rev/lib/tree_adapters/default.js#L412}{\tt default implementation.}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
comment\+Node  &{\ttfamily A\+S\+T\+Node.$<$Comment$>$}  &Comment node.   \\\cline{1-3}
\end{longtabu}


\label{_TreeAdapter.getDocumentTypeNodeName}%
 \subsubsection*{Tree\+Adapter.\+get\+Document\+Type\+Node\+Name(doctype\+Node) ⇒ {\ttfamily String}}

Returns given document type node\textquotesingle{}s name.

{\bfseries Kind}\+: static method of {\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}} {\bfseries Returns}\+: {\ttfamily String} -\/ name {\bfseries See}\+: \href{https://github.com/inikulin/parse5/blob/tree-adapter-docs-rev/lib/tree_adapters/default.js#L428}{\tt default implementation.}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
doctype\+Node  &{\ttfamily A\+S\+T\+Node.$<$Document\+Type$>$}  &Document type node.   \\\cline{1-3}
\end{longtabu}


\label{_TreeAdapter.getDocumentTypeNodePublicId}%
 \subsubsection*{Tree\+Adapter.\+get\+Document\+Type\+Node\+Public\+Id(doctype\+Node) ⇒ {\ttfamily String}}

Returns given document type node\textquotesingle{}s public identifier.

{\bfseries Kind}\+: static method of {\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}} {\bfseries Returns}\+: {\ttfamily String} -\/ public\+Id {\bfseries See}\+: \href{https://github.com/inikulin/parse5/blob/tree-adapter-docs-rev/lib/tree_adapters/default.js#L444}{\tt default implementation.}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
doctype\+Node  &{\ttfamily A\+S\+T\+Node.$<$Document\+Type$>$}  &Document type node.   \\\cline{1-3}
\end{longtabu}


\label{_TreeAdapter.getDocumentTypeNodeSystemId}%
 \subsubsection*{Tree\+Adapter.\+get\+Document\+Type\+Node\+System\+Id(doctype\+Node) ⇒ {\ttfamily String}}

Returns given document type node\textquotesingle{}s system identifier.

{\bfseries Kind}\+: static method of {\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}} {\bfseries Returns}\+: {\ttfamily String} -\/ system\+Id {\bfseries See}\+: \href{https://github.com/inikulin/parse5/blob/tree-adapter-docs-rev/lib/tree_adapters/default.js#L460}{\tt default implementation.}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
doctype\+Node  &{\ttfamily A\+S\+T\+Node.$<$Document\+Type$>$}  &Document type node.   \\\cline{1-3}
\end{longtabu}


\label{_TreeAdapter.isTextNode}%
 \subsubsection*{Tree\+Adapter.\+is\+Text\+Node(node) ⇒ {\ttfamily Boolean}}

Determines if given node is a text node.

{\bfseries Kind}\+: static method of {\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}} {\bfseries See}\+: \href{https://github.com/inikulin/parse5/blob/tree-adapter-docs-rev/lib/tree_adapters/default.js#L477}{\tt default implementation.}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
node  &{\ttfamily A\+S\+T\+Node}  &Node.   \\\cline{1-3}
\end{longtabu}


\label{_TreeAdapter.isCommentNode}%
 \subsubsection*{Tree\+Adapter.\+is\+Comment\+Node(node) ⇒ {\ttfamily Boolean}}

Determines if given node is a comment node.

{\bfseries Kind}\+: static method of {\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}} {\bfseries See}\+: \href{https://github.com/inikulin/parse5/blob/tree-adapter-docs-rev/lib/tree_adapters/default.js#L493}{\tt default implementation.}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
node  &{\ttfamily A\+S\+T\+Node}  &Node.   \\\cline{1-3}
\end{longtabu}


\label{_TreeAdapter.isDocumentTypeNode}%
 \subsubsection*{Tree\+Adapter.\+is\+Document\+Type\+Node(node) ⇒ {\ttfamily Boolean}}

Determines if given node is a document type node.

{\bfseries Kind}\+: static method of {\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}} {\bfseries See}\+: \href{https://github.com/inikulin/parse5/blob/tree-adapter-docs-rev/lib/tree_adapters/default.js#L509}{\tt default implementation.}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
node  &{\ttfamily A\+S\+T\+Node}  &Node.   \\\cline{1-3}
\end{longtabu}


\label{_TreeAdapter.isElementNode}%
 \subsubsection*{Tree\+Adapter.\+is\+Element\+Node(node) ⇒ {\ttfamily Boolean}}

Determines if given node is an element.

{\bfseries Kind}\+: static method of {\ttfamily \href{#TreeAdapter}{\tt Tree\+Adapter}} {\bfseries See}\+: \href{https://github.com/inikulin/parse5/blob/tree-adapter-docs-rev/lib/tree_adapters/default.js#L525}{\tt default implementation.}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Param  }&\textbf{ Type  }&\textbf{ D   }\\\cline{1-3}
\endhead
node  &{\ttfamily A\+S\+T\+Node}  &Node.   \\\cline{1-3}
\end{longtabu}


\section*{F\+AQ}

\subsection*{Q\+: I want to work with my own document tree format. How can I achieve this?}

You can create a custom tree adapter so parse5 can work with your own D\+O\+M-\/tree implementation. Then just pass it to the parser or serializer via option\+:


\begin{DoxyCode}
var parse5 = require('parse5');

var myTreeAdapter = \{
   //Adapter methods...
\};

var document = parse5.parse('<div></div>', \{ treeAdapter: myTreeAdapter \});

var html = parse5.serialize(document, \{ treeAdapter: myTreeAdapter \});
\end{DoxyCode}
 You can find description of the methods which should be exposed by tree adapter and links to their default implementation in the \href{#TreeAdapter}{\tt A\+PI reference}.

\subsection*{Q\+: How can I use parse5 in the browser?}

Just compile it with \href{http://browserify.org/}{\tt browserify} and you\textquotesingle{}re set.

\subsection*{Q\+: I\textquotesingle{}m parsing {\ttfamily $<$img src=\char`\"{}foo\char`\"{}$>$} with the {\ttfamily S\+A\+X\+Parser} and I expect {\ttfamily self\+Closing} flag to be {\ttfamily true} for the {\ttfamily $<$img$>$} tag. But it\textquotesingle{}s not. Is there something wrong with parser?}

No. Self-\/closing tag is the tag that has {\ttfamily /} before the closing bracket. E.\+g\+: {\ttfamily $<$br/$>$}, {\ttfamily $<$meta/$>$}. In the provided example tag just doesn\textquotesingle{}t have end tag. Self-\/closing tags and tags without end tags are differently treated by the parser\+: in case of self-\/closing tag parser will not lookup for the appropriate closing tag and expects element to not have any content. But if start tag is not self-\/closing parser will treat everything after it (with the few exceptions) as the element content. However, if the start tag is in the list of \href{https://html.spec.whatwg.org/multipage/syntax.html#void-elements}{\tt void elements} parser expects corresponding element to not have content and behaves the same way as the if element is self-\/closing. So, semantically if element is the void element self-\/closing tags and tags without closing tags are equivalent, but it\textquotesingle{}s not true for all other tags.

{\bfseries TL;DR}\+: {\ttfamily self\+Closing} is the part of the lexical information and will be set only if the tag in source code has {\ttfamily /} before the closing bracket.

\subsection*{Q\+: I have some weird output from the parser, seems like it\textquotesingle{}s a bug.}

More likely, it\textquotesingle{}s not. There are a lot of weird edge cases in H\+T\+M\+L5 parsing algorithm, e.\+g.\+: 
\begin{DoxyCode}
<b>1<p>2</b>3</p>
\end{DoxyCode}


will be parsed as


\begin{DoxyCode}
<b>1</b><p><b>2</b>3</p>
\end{DoxyCode}


Just try it in the latest version of your browser before submitting the issue.

\section*{Version history}

\subsection*{2.\+0.\+0}


\begin{DoxyItemize}
\item Add\+: \href{http://inikulin.github.io/parse5/#parse5+ParserStream}{\tt Parser\+Stream} with the scripting support.
\item Add\+: \href{http://inikulin.github.io/parse5/#parse5+SerializerStream}{\tt Serializer\+Stream}
\item Add\+: Line/column location info.
\item Update ({\bfseries breaking})\+: {\ttfamily Simple\+Api\+Parser} was renamed to \href{http://inikulin.github.io/parse5/#parse5+SAXParser}{\tt S\+A\+X\+Parser}.
\item Update ({\bfseries breaking})\+: \href{http://inikulin.github.io/parse5/#parse5+SAXParser}{\tt S\+A\+X\+Parser} is the \href{https://nodejs.org/api/stream.html#stream_class_stream_transform}{\tt transform stream} now.
\item Update ({\bfseries breaking})\+: \href{http://inikulin.github.io/parse5/#parse5+SAXParser}{\tt S\+A\+X\+Parser} handler subscription is done via events now.
\item Add\+: \href{http://inikulin.github.io/parse5/#parse5+SAXParser+stop}{\tt S\+A\+X\+Parser.\+stop()}
\item Add ({\bfseries breaking})\+: \href{http://inikulin.github.io/parse5/#parse5+parse}{\tt parse5.\+parse()} and \href{http://inikulin.github.io/parse5/#parse5+parseFragment}{\tt parse5.\+parse\+Fragment()} methods as replacement for the {\ttfamily Parser} class.
\item Add ({\bfseries breaking})\+: \href{http://inikulin.github.io/parse5/#parse5+serialized}{\tt parse5.\+serialize()} method as replacement for the {\ttfamily Serializer} class.
\item Update\+: parsing algorithm was updated with the latest \href{https://html.spec.whatwg.org/}{\tt H\+T\+ML spec} changes.
\item Remove ({\bfseries breaking})\+: {\ttfamily decode\+Html\+Entities} and {\ttfamily encode\+Html\+Entities} options. \href{https://github.com/inikulin/parse5/issues/75}{\tt Discussion}.
\end{DoxyItemize}

\subsection*{1.\+5.\+0}


\begin{DoxyItemize}
\item Add\+: Location info for the element start and end tags (by ).
\end{DoxyItemize}

\subsection*{1.\+4.\+2}


\begin{DoxyItemize}
\item Fix\+: htmlparser2 tree adapter {\ttfamily Document\+Type.\+data} property rendering (GH \href{https://github.com/inikulin/parse5/issues/45}{\tt \#45}).
\end{DoxyItemize}

\subsection*{1.\+4.\+1}


\begin{DoxyItemize}
\item Fix\+: Location info handling for the implicitly generated {\ttfamily $<$html$>$} and {\ttfamily $<$body$>$} elements (GH \href{https://github.com/inikulin/parse5/issues/44}{\tt \#44}).
\end{DoxyItemize}

\subsection*{1.\+4.\+0}


\begin{DoxyItemize}
\item Add\+: Parser \href{https://github.com/inikulin/parse5#optionsdecodehtmlentities}{\tt decode\+Html\+Entities} option.
\item Add\+: Simple\+Api\+Parser \href{https://github.com/inikulin/parse5#optionsdecodehtmlentities-1}{\tt decode\+Html\+Entities} option.
\item Add\+: Parser \href{https://github.com/inikulin/parse5#optionslocationinfo}{\tt location\+Info} option.
\item Add\+: Simple\+Api\+Parser \href{https://github.com/inikulin/parse5#optionslocationinfo-1}{\tt location\+Info} option.
\end{DoxyItemize}

\subsection*{1.\+3.\+2}


\begin{DoxyItemize}
\item Fix\+: {\ttfamily $<$form$>$} processing in {\ttfamily $<$template$>$} (GH \href{https://github.com/inikulin/parse5/issues/40}{\tt \#40}).
\end{DoxyItemize}

\subsection*{1.\+3.\+1}


\begin{DoxyItemize}
\item Fix\+: text node in {\ttfamily $<$template$>$} serialization problem with custom tree adapter (GH \href{https://github.com/inikulin/parse5/issues/38}{\tt \#38}).
\end{DoxyItemize}

\subsection*{1.\+3.\+0}


\begin{DoxyItemize}
\item Add\+: Serializer {\ttfamily encode\+Html\+Entities} option.
\end{DoxyItemize}

\subsection*{1.\+2.\+0}


\begin{DoxyItemize}
\item Add\+: {\ttfamily $<$template$>$} support
\item {\ttfamily parse\+Fragment} now uses {\ttfamily $<$template$>$} as default {\ttfamily context\+Element}. This leads to the more \char`\"{}forgiving\char`\"{} parsing manner.
\item {\ttfamily Tree\+Serializer} was renamed to {\ttfamily Serializer}. However, serializer is accessible as {\ttfamily parse5.\+Tree\+Serializer} for backward compatibility .
\end{DoxyItemize}

\subsection*{1.\+1.\+6}


\begin{DoxyItemize}
\item Fix\+: apply latest changes to the {\ttfamily htmlparser2} tree format (D\+OM Level1 node emulation).
\end{DoxyItemize}

\subsection*{1.\+1.\+5}


\begin{DoxyItemize}
\item Add\+: \href{https://github.com/tmpvar/jsdom}{\tt jsdom}-\/specific parser with scripting support. Undocumented for {\ttfamily jsdom} internal use only.
\end{DoxyItemize}

\subsection*{1.\+1.\+4}


\begin{DoxyItemize}
\item Add\+: logo
\item Fix\+: use fake {\ttfamily document} element for fragment parsing (required by \href{https://github.com/tmpvar/jsdom}{\tt jsdom}).
\end{DoxyItemize}

\subsection*{1.\+1.\+3}


\begin{DoxyItemize}
\item Development files (e.\+g. {\ttfamily .travis.\+yml}, {\ttfamily .editorconfig}) are removed from N\+PM package.
\end{DoxyItemize}

\subsection*{1.\+1.\+2}


\begin{DoxyItemize}
\item Fix\+: crash on Linux due to upper-\/case leading character in module name used in {\ttfamily require()}.
\end{DoxyItemize}

\subsection*{1.\+1.\+1}


\begin{DoxyItemize}
\item Add\+: \href{https://github.com/inikulin/parse5/#class-simpleapiparser}{\tt Simple\+Api\+Parser}.
\item Fix\+: new line serialization in {\ttfamily $<$pre$>$}.
\item Fix\+: {\ttfamily S\+Y\+S\+T\+EM}-\/only {\ttfamily D\+O\+C\+T\+Y\+PE} serialization.
\item Fix\+: quotes serialization in {\ttfamily D\+O\+C\+T\+Y\+PE} I\+Ds.
\end{DoxyItemize}

\subsection*{1.\+0.\+0}


\begin{DoxyItemize}
\item First stable release, switch to semantic versioning.
\end{DoxyItemize}

\subsection*{0.\+8.\+3}


\begin{DoxyItemize}
\item Fix\+: siblings calculation bug in {\ttfamily append\+Child} in {\ttfamily htmlparser2} tree adapter.
\end{DoxyItemize}

\subsection*{0.\+8.\+1}


\begin{DoxyItemize}
\item Add\+: \href{https://github.com/inikulin/parse5/#class-serializer}{\tt Tree\+Serializer}.
\item Add\+: \href{https://github.com/inikulin/parse5/#-treeadaptershtmlparser2}{\tt htmlparser2 tree adapter}.
\end{DoxyItemize}

\subsection*{0.\+6.\+1}


\begin{DoxyItemize}
\item Fix\+: incorrect {\ttfamily $<$menuitem$>$} handling in {\ttfamily $<$body$>$}.
\end{DoxyItemize}

\subsection*{0.\+6.\+0}


\begin{DoxyItemize}
\item Initial release.
\end{DoxyItemize}

\section*{License}

Copyright (c) 2013-\/2015 Ivan Nikulin (\href{mailto:ifaaan@gmail.com}{\tt ifaaan@gmail.\+com}, \href{https://github.com/inikulin}{\tt https\+://github.\+com/inikulin})

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \char`\"{}\+Software\char`\"{}), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions\+:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

T\+HE S\+O\+F\+T\+W\+A\+RE IS P\+R\+O\+V\+I\+D\+ED \char`\"{}\+A\+S I\+S\char`\"{}, W\+I\+T\+H\+O\+UT W\+A\+R\+R\+A\+N\+TY OF A\+NY K\+I\+ND, E\+X\+P\+R\+E\+SS OR I\+M\+P\+L\+I\+ED, I\+N\+C\+L\+U\+D\+I\+NG B\+UT N\+OT L\+I\+M\+I\+T\+ED TO T\+HE W\+A\+R\+R\+A\+N\+T\+I\+ES OF M\+E\+R\+C\+H\+A\+N\+T\+A\+B\+I\+L\+I\+TY, F\+I\+T\+N\+E\+SS F\+OR A P\+A\+R\+T\+I\+C\+U\+L\+AR P\+U\+R\+P\+O\+SE A\+ND N\+O\+N\+I\+N\+F\+R\+I\+N\+G\+E\+M\+E\+NT. IN NO E\+V\+E\+NT S\+H\+A\+LL T\+HE A\+U\+T\+H\+O\+RS OR C\+O\+P\+Y\+R\+I\+G\+HT H\+O\+L\+D\+E\+RS BE L\+I\+A\+B\+LE F\+OR A\+NY C\+L\+A\+IM, D\+A\+M\+A\+G\+ES OR O\+T\+H\+ER L\+I\+A\+B\+I\+L\+I\+TY, W\+H\+E\+T\+H\+ER IN AN A\+C\+T\+I\+ON OF C\+O\+N\+T\+R\+A\+CT, T\+O\+RT OR O\+T\+H\+E\+R\+W\+I\+SE, A\+R\+I\+S\+I\+NG F\+R\+OM, O\+UT OF OR IN C\+O\+N\+N\+E\+C\+T\+I\+ON W\+I\+TH T\+HE S\+O\+F\+T\+W\+A\+RE OR T\+HE U\+SE OR O\+T\+H\+ER D\+E\+A\+L\+I\+N\+GS IN T\+HE S\+O\+F\+T\+W\+A\+RE. 