\href{http://travis-ci.org/spdy-http2/node-spdy}{\tt } \href{http://badge.fury.io/js/spdy}{\tt } \href{https://david-dm.org/spdy-http2/node-spdy}{\tt } \href{http://standardjs.com/}{\tt } \href{https://waffle.io/spdy-http2/node-spdy}{\tt }

With this module you can create \href{https://http2.github.io/}{\tt H\+T\+T\+P2} / \href{http://www.chromium.org/spdy}{\tt S\+P\+DY} servers in node.\+js with natural http module interface and fallback to regular https (for browsers that don\textquotesingle{}t support neither H\+T\+T\+P2, nor S\+P\+DY yet).

This module named {\ttfamily spdy} but it \href{https://github.com/indutny/node-spdy/issues/269#issuecomment-239014184}{\tt provides} support for both http/2 (h2) and spdy (2,3,3.\+1). Also, {\ttfamily spdy} is compatible with Express.

\subsection*{Usage}

\subsubsection*{Examples}

Server\+: 
\begin{DoxyCode}
var spdy = require('spdy'),
    fs = require('fs');

var options = \{
  // Private key
  key: fs.readFileSync(\_\_dirname + '/keys/spdy-key.pem'),

  // Fullchain file or cert file (prefer the former)
  cert: fs.readFileSync(\_\_dirname + '/keys/spdy-fullchain.pem'),

  // **optional** SPDY-specific options
  spdy: \{
    protocols: [ 'h2', 'spdy/3.1', ..., 'http/1.1' ],
    plain: false,

    // **optional**
    // Parse first incoming X\_FORWARDED\_FOR frame and put it to the
    // headers of every request.
    // NOTE: Use with care! This should not be used without some proxy that
    // will *always* send X\_FORWARDED\_FOR
    'x-forwarded-for': true,

    connection: \{
      windowSize: 1024 * 1024, // Server's window size

      // **optional** if true - server will send 3.1 frames on 3.0 *plain* spdy
      autoSpdy31: false
    \}
  \}
\};

var server = spdy.createServer(options, function(req, res) \{
  res.writeHead(200);
  res.end('hello world!');
\});

server.listen(3000);
\end{DoxyCode}


Client\+: 
\begin{DoxyCode}
var spdy = require('spdy');
var https = require('https');

var agent = spdy.createAgent(\{
  host: 'www.google.com',
  port: 443,

  // Optional SPDY options
  spdy: \{
    plain: false,
    ssl: true,

    // **optional** send X\_FORWARDED\_FOR
    'x-forwarded-for': '127.0.0.1'
  \}
\});

https.get(\{
  host: 'www.google.com',
  agent: agent
\}, function(response) \{
  console.log('yikes');
  // Here it goes like with any other node.js HTTP request
  // ...
  // And once we're done - we may close TCP connection to server
  // NOTE: All non-closed requests will die!
  agent.close();
\}).end();
\end{DoxyCode}


Please note that if you use a custom agent, by default all connection-\/level errors will result in an uncaught exception. To handle these errors subscribe to the {\ttfamily error} event and re-\/emit the captured error\+:


\begin{DoxyCode}
var agent = spdy.createAgent(\{
  host: 'www.google.com',
  port: 443
\}).once('error', function (err) \{
  this.emit(err);
\});
\end{DoxyCode}


\paragraph*{Push streams}

It is possible to initiate \href{https://httpwg.github.io/specs/rfc7540.html#PUSH_PROMISE}{\tt P\+U\+S\+H\+\_\+\+P\+R\+O\+M\+I\+SE} to send content to clients {\itshape before} the client requests it.


\begin{DoxyCode}
spdy.createServer(options, function(req, res) \{
  var stream = res.push('/main.js', \{
    status: 200, // optional
    method: 'GET', // optional
    request: \{
      accept: '*/*'
    \},
    response: \{
      'content-type': 'application/javascript'
    \}
  \});
  stream.on('error', function() \{
  \});
  stream.end('alert("hello from push stream!");');

  res.end('<script src="/main.js"></script>');
\}).listen(3000);
\end{DoxyCode}


\href{https://httpwg.github.io/specs/rfc7540.html#PUSH_PROMISE}{\tt P\+U\+S\+H\+\_\+\+P\+R\+O\+M\+I\+SE} may be sent using the {\ttfamily push()} method on the current response object. The signature of the {\ttfamily push()} method is\+:

`.push('/some/relative/url\textquotesingle{}, \{ request\+: \{...\}, response\+: \{...\} \}, callback)\`{}

Second argument contains headers for both P\+U\+S\+H\+\_\+\+P\+R\+O\+M\+I\+SE and emulated response. {\ttfamily callback} will receive two arguments\+: {\ttfamily err} (if any error is happened) and a \href{https://iojs.org/api/stream.html#stream_class_stream_duplex}{\tt Duplex} stream as the second argument.

Client usage\+: 
\begin{DoxyCode}
var agent = spdy.createAgent(\{ /* ... */ \});
var req = http.get(\{
  host: 'www.google.com',
  agent: agent
\}, function(response) \{
\});
req.on('push', function(stream) \{
  stream.on('error', function(err) \{
    // Handle error
  \});
  // Read data from stream
\});
\end{DoxyCode}


N\+O\+TE\+: You\textquotesingle{}re responsible for the {\ttfamily stream} object once given it in {\ttfamily .push()} callback or {\ttfamily push} event. Hence ignoring {\ttfamily error} event on it will result in uncaught exception and crash your program.

\paragraph*{Trailing headers}

Server usage\+: 
\begin{DoxyCode}
function (req, res) \{
  // Send trailing headers to client
  res.addTrailers(\{ header1: 'value1', header2: 'value2' \});

  // On client's trailing headers
  req.on('trailers', function(headers) \{
    // ...
  \});
\}
\end{DoxyCode}


Client usage\+: 
\begin{DoxyCode}
var req = http.request(\{ agent: spdyAgent, /* ... */ \}).function (res) \{
  // On server's trailing headers
  res.on('trailers', function(headers) \{
    // ...
  \});
\});
req.write('stuff');
req.addTrailers(\{ /* ... */ \});
req.end();
\end{DoxyCode}


\paragraph*{Options}

All options supported by \href{http://nodejs.org/docs/latest/api/tls.html#tls.createServer}{\tt tls} work with node-\/spdy.

Additional options may be passed via {\ttfamily spdy} sub-\/object\+:


\begin{DoxyItemize}
\item {\ttfamily plain} -\/ if defined, server will ignore N\+PN and A\+L\+PN data and choose whether to use spdy or plain http by looking at first data packet.
\item {\ttfamily ssl} -\/ if {\ttfamily false} and {\ttfamily options.\+plain} is {\ttfamily true}, {\ttfamily http.\+Server} will be used as a {\ttfamily base} class for created server.
\item {\ttfamily max\+Chunk} -\/ if set and non-\/falsy, limits number of bytes sent in one D\+A\+TA chunk. Setting it to non-\/zero value is recommended if you care about interleaving of outgoing data from multiple different streams. (defaults to 8192)
\item {\ttfamily protocols} -\/ list of N\+P\+N/\+A\+L\+PN protocols to use (default is\+: `\mbox{[}\textquotesingle{}h2',\textquotesingle{}spdy/3.\+1\textquotesingle{}, \textquotesingle{}spdy/3\textquotesingle{}, \textquotesingle{}spdy/2\textquotesingle{},\textquotesingle{}http/1.\+1\textquotesingle{}, \textquotesingle{}http/1.\+0\textquotesingle{}\mbox{]}{\ttfamily ) $\ast$}protocol{\ttfamily -\/ use specific protocol if no N\+P\+N/\+A\+L\+PN ex In addition, $\ast$}max\+Streams\`{} -\/ set \char`\"{}\mbox{[}maximum concurrent streams\mbox{]}\mbox{[}3\mbox{]}\char`\"{} protocol option
\end{DoxyItemize}

\subsubsection*{A\+PI}

A\+PI is compatible with {\ttfamily http} and {\ttfamily https} module, but you can use another function as base class for S\+P\+D\+Y\+Server.


\begin{DoxyCode}
spdy.createServer(
  [base class constructor, i.e. https.Server],
  \{ /* keys and options */ \}, // <- the only one required argument
  [request listener]
).listen([port], [host], [callback]);
\end{DoxyCode}


Request listener will receive two arguments\+: {\ttfamily request} and {\ttfamily response}. They\textquotesingle{}re both instances of {\ttfamily http}\textquotesingle{}s {\ttfamily Incoming\+Message} and {\ttfamily Outgoing\+Message}. But three custom properties are added to both of them\+: {\ttfamily is\+Spdy}, {\ttfamily spdy\+Version}. {\ttfamily is\+Spdy} is {\ttfamily true} when the request was processed using H\+T\+T\+P2/\+S\+P\+DY protocols, it is {\ttfamily false} in case of H\+T\+T\+P/1.\+1 fallback. {\ttfamily spdy\+Version} is either of\+: {\ttfamily 2}, {\ttfamily 3}, {\ttfamily 3.\+1}, or {\ttfamily 4} (for H\+T\+T\+P2).

\paragraph*{Contributors}


\begin{DoxyItemize}
\item \href{https://github.com/indutny}{\tt Fedor Indutny}
\item \href{https://github.com/eee-c}{\tt Chris Strom}
\item \href{https://github.com/francois2metz}{\tt FranÃ§ois de Metz}
\item \href{https://github.com/igrigorik}{\tt Ilya Grigorik}
\item \href{https://github.com/grmocg}{\tt Roberto Peon}
\item \href{https://github.com/tatsuhiro-t}{\tt Tatsuhiro Tsujikawa}
\item \href{https://github.com/jessecravens}{\tt Jesse Cravens}
\end{DoxyItemize}

\paragraph*{L\+I\+C\+E\+N\+SE}

This software is licensed under the M\+IT License.

Copyright Fedor Indutny, 2015.

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \char`\"{}\+Software\char`\"{}), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions\+:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

T\+HE S\+O\+F\+T\+W\+A\+RE IS P\+R\+O\+V\+I\+D\+ED \char`\"{}\+A\+S I\+S\char`\"{}, W\+I\+T\+H\+O\+UT W\+A\+R\+R\+A\+N\+TY OF A\+NY K\+I\+ND, E\+X\+P\+R\+E\+SS OR I\+M\+P\+L\+I\+ED, I\+N\+C\+L\+U\+D\+I\+NG B\+UT N\+OT L\+I\+M\+I\+T\+ED TO T\+HE W\+A\+R\+R\+A\+N\+T\+I\+ES OF M\+E\+R\+C\+H\+A\+N\+T\+A\+B\+I\+L\+I\+TY, F\+I\+T\+N\+E\+SS F\+OR A P\+A\+R\+T\+I\+C\+U\+L\+AR P\+U\+R\+P\+O\+SE A\+ND N\+O\+N\+I\+N\+F\+R\+I\+N\+G\+E\+M\+E\+NT. IN NO E\+V\+E\+NT S\+H\+A\+LL T\+HE A\+U\+T\+H\+O\+RS OR C\+O\+P\+Y\+R\+I\+G\+HT H\+O\+L\+D\+E\+RS BE L\+I\+A\+B\+LE F\+OR A\+NY C\+L\+A\+IM, D\+A\+M\+A\+G\+ES OR O\+T\+H\+ER L\+I\+A\+B\+I\+L\+I\+TY, W\+H\+E\+T\+H\+ER IN AN A\+C\+T\+I\+ON OF C\+O\+N\+T\+R\+A\+CT, T\+O\+RT OR O\+T\+H\+E\+R\+W\+I\+SE, A\+R\+I\+S\+I\+NG F\+R\+OM, O\+UT OF OR IN C\+O\+N\+N\+E\+C\+T\+I\+ON W\+I\+TH T\+HE S\+O\+F\+T\+W\+A\+RE OR T\+HE U\+SE OR O\+T\+H\+ER D\+E\+A\+L\+I\+N\+GS IN T\+HE S\+O\+F\+T\+W\+A\+RE. 