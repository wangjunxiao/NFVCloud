Encode or decode the R\+D\+A\+TA field in multicast D\+NS T\+XT records. For use with D\+N\+S-\/\+Based Service Discovery. For details see \href{https://tools.ietf.org/html/rfc6763}{\tt R\+FC 6763}.

\href{https://travis-ci.org/watson/dns-txt}{\tt } \href{https://github.com/feross/standard}{\tt } \href{https://github.com/mafintosh/abstract-encoding}{\tt }

\subsection*{Installation}


\begin{DoxyCode}
npm install dns-txt
\end{DoxyCode}


\subsection*{Usage}


\begin{DoxyCode}
var txt = require('dns-txt')()

var obj = \{
  foo: 1,
  bar: 2
\}

var enc = txt.encode(obj) // <Buffer 05 66 6f 6f 3d 31 05 62 61 72 3d 32>

txt.decode(enc) // \{ foo: '1', bar: '2' \}
\end{DoxyCode}


\subsection*{A\+PI}

The encoder and decoder conforms to \href{https://tools.ietf.org/html/rfc6763}{\tt R\+FC 6763}.

\subsubsection*{Initialize}

The module exposes a constructor function which can be called with an optional options object\+:


\begin{DoxyCode}
var txt = require('dns-txt')(\{ binary: true \})
\end{DoxyCode}


The options are\+:


\begin{DoxyItemize}
\item {\ttfamily binary} -\/ If set to {\ttfamily true} all values will be returned as {\ttfamily Buffer} objects. The default behavior is to turn all values into strings. But according to the R\+FC the values can be any binary data. If you expect binary data, use this option.
\end{DoxyItemize}

\paragraph*{{\ttfamily txt.\+encode(obj, \mbox{[}buffer\mbox{]}, \mbox{[}offset\mbox{]})}}

Takes a key/value object and returns a buffer with the encoded T\+XT record. If a buffer is passed as the second argument the object should be encoded into that buffer. Otherwise a new buffer should be allocated If an offset is passed as the third argument the object should be encoded at that byte offset. The byte offset defaults to {\ttfamily 0}.

This module does not actively validate the key/value pairs, but keep the following in rules in mind\+:


\begin{DoxyItemize}
\item To be R\+FC compliant, each key should conform with the rules as specified in \href{https://tools.ietf.org/html/rfc6763#section-6.4}{\tt section 6.\+4}.
\item To be R\+FC compliant, each value should conform with the rules as specified in \href{https://tools.ietf.org/html/rfc6763#section-6.5}{\tt section 6.\+5}.
\end{DoxyItemize}

After encoding {\ttfamily txt.\+encode.\+bytes} is set to the amount of bytes used to encode the object.

\paragraph*{{\ttfamily txt.\+decode(buffer, \mbox{[}offset\mbox{]}, \mbox{[}length\mbox{]})}}

Takes a buffer and returns a decoded key/value object. If an offset is passed as the second argument the object should be decoded from that byte offset. The byte offset defaults to {\ttfamily 0}. Note that all keys will be lowercased and all values will be Buffer objects.

After decoding {\ttfamily txt.\+decode.\+bytes} is set to the amount of bytes used to decode the object.

\paragraph*{{\ttfamily txt.\+encoding\+Length(obj)}}

Takes a single key/value object and returns the number of bytes that the given object would require if encoded.

\subsection*{License}

M\+IT 