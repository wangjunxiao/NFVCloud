Delay the evaluation of a paramless async function and cache the result (see \href{http://en.wikipedia.org/wiki/Thunk_%28functional_programming%29}{\tt thunk}). \begin{DoxyVerb}npm install thunky
\end{DoxyVerb}


\subsection*{Example}

Let\textquotesingle{}s make a simple function that returns a random number 1 second after it is called for the first time


\begin{DoxyCode}
var thunky = require('thunky');

var test = thunky(function(callback) \{ // the inner function should only accept a callback
    console.log('waiting 1s and returning random number');
    setTimeout(function() \{
        callback(Math.random());
    \}, 1000);
\});

test(function(num) \{  // inner function is called the first time we call test
    console.log(num); // prints random number
\});

test(function(num) \{  // subsequent calls waits for the first call to finish and return the same value
    console.log(num); // prints the same random number as above
\});
\end{DoxyCode}


\subsection*{Lazy evaluation}

Thunky makes it easy to implement a lazy evaluation pattern.


\begin{DoxyCode}
var getDb = thunky(function(callback) \{
    db.open(myConnectionString, callback);
\});

var queryDb = function(query, callback) \{
    getDb(function(err, db) \{
        if (err) return callback(err);
        db.query(query, callback);
    \});
\};

queryDb('some query', function(err, result) \{ ... \} );

queryDb('some other query', function(err, result) \{ ... \} );
\end{DoxyCode}


The first time {\ttfamily get\+Db} is called it will try do open a connection to the database. Any subsequent calls will just wait for the first call to complete and then call your callback.

A nice property of this pattern is that it {\itshape easily} allows us to pass any error caused by {\ttfamily get\+Db} to the {\ttfamily query\+Db} callback.

\subsection*{Error â†’ No caching}

If the thunk callback is called with an {\ttfamily Error} object as the first argument it will not cache the result


\begin{DoxyCode}
var fails = thunky(function(callback) \{
    console.log('returning an error');
    callback(new Error('bad stuff'));
\});

fails(function(err) \{ // inner function is called
    console.log(err);
\});

fails(function(err) \{ // inner function is called again as it returned an error before
    console.log(err);
\});
\end{DoxyCode}


\subsection*{License}

M\+IT 