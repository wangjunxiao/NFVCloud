{\bfseries Light E\+C\+M\+A\+Script (Java\+Script) Value Notation} Levn is a library which allows you to parse a string into a Java\+Script value based on an expected type. It is meant for short amounts of human entered data (eg. config files, command line arguments).

Levn aims to concisely describe Java\+Script values in text, and allow for the extraction and validation of those values. Levn uses \href{https://github.com/gkz/type-check}{\tt type-\/check} for its type format, and to validate the results. M\+IT license. Version 0.\+3.\+0.

{\bfseries How is this different than J\+S\+ON?} levn is meant to be written by humans only, is (due to the previous point) much more concise, can be validated against supplied types, has regex and date literals, and can easily be extended with custom types. On the other hand, it is probably slower and thus less efficient at transporting large amounts of data, which is fine since this is not its purpose. \begin{DoxyVerb}npm install levn
\end{DoxyVerb}


For updates on levn, \href{https://twitter.com/gkzahariev}{\tt follow me on twitter}.

\subsection*{Quick Examples}


\begin{DoxyCode}
var parse = require('levn').parse;
parse('Number', '2');      // 2
parse('String', '2');      // '2'
parse('String', 'levn');   // 'levn'
parse('String', 'a b');    // 'a b'
parse('Boolean', 'true');  // true

parse('Date', '#2011-11-11#'); // (Date object)
parse('Date', '2011-11-11');   // (Date object)
parse('RegExp', '/[a-z]/gi');  // /[a-z]/gi
parse('RegExp', 're');         // /re/
parse('Int', '2');             // 2

parse('Number | String', 'str'); // 'str'
parse('Number | String', '2');   // 2

parse('[Number]', '[1,2,3]');                      // [1,2,3]
parse('(String, Boolean)', '(hi, false)');         // ['hi', false]
parse('\{a: String, b: Number\}', '\{a: str, b: 2\}'); // \{a: 'str', b: 2\}

// at the top level, you can ommit surrounding delimiters
parse('[Number]', '1,2,3');                      // [1,2,3]
parse('(String, Boolean)', 'hi, false');         // ['hi', false]
parse('\{a: String, b: Number\}', 'a: str, b: 2'); // \{a: 'str', b: 2\}

// wildcard - auto choose type
parse('*', '[hi,(null,[42]),\{k: true\}]'); // ['hi', [null, [42]], \{k: true\}]
\end{DoxyCode}
 \subsection*{Usage}

`require(\textquotesingle{}levn');{\ttfamily returns an object that exposes three properties.}V\+E\+R\+S\+I\+ON{\ttfamily is the current version of the library as a string.}parse{\ttfamily and}parsed\+Type\+Parse\`{} are functions.


\begin{DoxyCode}
// parse(type, input, options);
parse('[Number]', '1,2,3'); // [1, 2, 3]

// parsedTypeParse(parsedType, input, options);
var parsedType = require('type-check').parseType('[Number]');
parsedTypeParse(parsedType, '1,2,3'); // [1, 2, 3]
\end{DoxyCode}


\subsubsection*{parse(type, input, options)}

{\ttfamily parse} casts the string {\ttfamily input} into a Java\+Script value according to the specified {\ttfamily type} in the \href{https://github.com/gkz/type-check#type-format}{\tt type format} (and taking account the optional {\ttfamily options}) and returns the resulting Java\+Script value.

\subparagraph*{arguments}


\begin{DoxyItemize}
\item type -\/ {\ttfamily String} -\/ the type written in the \href{https://github.com/gkz/type-check#type-format}{\tt type format} which to check against
\item input -\/ {\ttfamily String} -\/ the value written in the \href{#levn-format}{\tt levn format}
\item options -\/ {\ttfamily Maybe Object} -\/ an optional parameter specifying additional \href{#options}{\tt options}
\end{DoxyItemize}

\subparagraph*{returns}

{\ttfamily $\ast$} -\/ the resulting Java\+Script value

\#\#\#\#\# example 
\begin{DoxyCode}
parse('[Number]', '1,2,3'); // [1, 2, 3]
\end{DoxyCode}


\subsubsection*{parsed\+Type\+Parse(parsed\+Type, input, options)}

{\ttfamily parsed\+Type\+Parse} casts the string {\ttfamily input} into a Java\+Script value according to the specified {\ttfamily type} which has already been parsed (and taking account the optional {\ttfamily options}) and returns the resulting Java\+Script value. You can parse a type using the \href{https://github.com/gkz/type-check}{\tt type-\/check} library\textquotesingle{}s {\ttfamily parse\+Type} function.

\subparagraph*{arguments}


\begin{DoxyItemize}
\item type -\/ {\ttfamily Object} -\/ the type in the parsed type format which to check against
\item input -\/ {\ttfamily String} -\/ the value written in the \href{#levn-format}{\tt levn format}
\item options -\/ {\ttfamily Maybe Object} -\/ an optional parameter specifying additional \href{#options}{\tt options}
\end{DoxyItemize}

\subparagraph*{returns}

{\ttfamily $\ast$} -\/ the resulting Java\+Script value

\#\#\#\#\# example 
\begin{DoxyCode}
var parsedType = require('type-check').parseType('[Number]');
parsedTypeParse(parsedType, '1,2,3'); // [1, 2, 3]
\end{DoxyCode}


\subsection*{Levn Format}

Levn can use the type information you provide to choose the appropriate value to produce from the input. For the same input, it will choose a different output value depending on the type provided. For example, `parse(\textquotesingle{}Number', \textquotesingle{}2\textquotesingle{}){\ttfamily will produce the number}2{\ttfamily , but}parse(\textquotesingle{}String\textquotesingle{}, \textquotesingle{}2\textquotesingle{}){\ttfamily will produce the string}\char`\"{}2\char`\"{}\`{}.

If you do not provide type information, and simply use {\ttfamily $\ast$}, levn will parse the input according the unambiguous \char`\"{}explicit\char`\"{} mode, which we will now detail -\/ you can also set the {\ttfamily explicit} option to true manually in the \href{#options}{\tt options}.


\begin{DoxyItemize}
\item {\ttfamily \char`\"{}string\char`\"{}}, `\textquotesingle{}string'{\ttfamily are parsed as a String, eg.}\char`\"{}a msg\char`\"{}{\ttfamily is}\char`\"{}a msg\char`\"{}{\ttfamily  $\ast$}\#date\#{\ttfamily is parsed as a Date, eg.}\#2011-\/11-\/11\#{\ttfamily is}new Date(\textquotesingle{}2011-\/11-\/11\textquotesingle{}){\ttfamily  $\ast$}/regexp/flags{\ttfamily is parsed as a Reg\+Exp, eg.}/re/gi{\ttfamily is}/re/gi{\ttfamily  $\ast$}undefined{\ttfamily ,}null{\ttfamily ,}NaN{\ttfamily ,}true{\ttfamily , and}false{\ttfamily are all their Java\+Script equivalents $\ast$}\mbox{[}element1, element2, etc\mbox{]}{\ttfamily is an Array, and the casting procedure is recursively applied to each element. Eg.}\mbox{[}1,2,3\mbox{]}{\ttfamily is}\mbox{[}1,2,3\mbox{]}{\ttfamily . $\ast$}(element1, element2, etc){\ttfamily is an tuple, and the casting procedure is recursively applied to each element. Eg.}(1, a){\ttfamily is}(1, a){\ttfamily (is}\mbox{[}1, \textquotesingle{}a\textquotesingle{}\mbox{]}{\ttfamily ). $\ast$}\{key1\+: val1, key2\+: val2, ...\}{\ttfamily is an Object, and the casting procedure is recursively applied to each property. Eg.}\{a\+: 1, b\+: 2\}{\ttfamily is}\{a\+: 1, b\+: 2\}{\ttfamily .}
\item {\ttfamily Any test which does not fall under the above, and which does not contain special characters (}\mbox{[}{\ttfamily \mbox{]}}({\ttfamily )}\{{\ttfamily \}}\+:\`{}{\ttfamily ,}) is a string, eg. {\ttfamily \$12-\/ blah} is {\ttfamily \char`\"{}\$12-\/ blah\char`\"{}}.
\end{DoxyItemize}

If you do provide type information, you can make your input more concise as the program already has some information about what it expects. Please see the \href{https://github.com/gkz/type-check#type-format}{\tt type format} section of \href{https://github.com/gkz/type-check}{\tt type-\/check} for more information about how to specify types. There are some rules about what levn can do with the information\+:


\begin{DoxyItemize}
\item If a String is expected, and only a String, all characters of the input (including any special ones) will become part of the output. Eg. {\ttfamily \mbox{[}(\{\})\mbox{]}} is {\ttfamily \char`\"{}\mbox{[}(\{\})\mbox{]}\char`\"{}}, and {\ttfamily \char`\"{}hi\char`\"{}} is `'\char`\"{}hi\char`\"{}\textquotesingle{}{\ttfamily .}
\item {\ttfamily If a Date is expected, the surrounding}\#{\ttfamily can be omitted from date literals. Eg.}2011-\/11-\/11{\ttfamily is}new Date(\textquotesingle{}2011-\/11-\/11\textquotesingle{}){\ttfamily .}
\item {\ttfamily If a Reg\+Exp is expected, no flags need to be specified, and the regex is not using any of the special characters,the opening and closing}/{\ttfamily can be omitted -\/ this will have the affect of setting the source of the regex to the input. Eg.}regex{\ttfamily is}/regex/{\ttfamily .}
\item {\ttfamily If an Array is expected, and it is the root node (at the top level), the opening}\mbox{[}{\ttfamily and closing}\mbox{]}{\ttfamily can be omitted. Eg.}1,2,3{\ttfamily is}\mbox{[}1,2,3\mbox{]}{\ttfamily .}
\item {\ttfamily If a tuple is expected, and it is the root node (at the top level), the opening}({\ttfamily and closing}){\ttfamily can be omitted. Eg.}1, a{\ttfamily is}(1, a){\ttfamily (is}\mbox{[}1, \textquotesingle{}a\textquotesingle{}\mbox{]}{\ttfamily ).}
\item {\ttfamily If an Object is expected, and it is the root node (at the top level), the opening}\{{\ttfamily and closing}\}{\ttfamily can be omitted. Eg}a\+: 1, b\+: 2{\ttfamily is}\{a\+: 1, b\+: 2\}\`{}.
\end{DoxyItemize}

If you list multiple types (eg. {\ttfamily Number $\vert$ String}), it will first attempt to cast to the first type and then validate -\/ if the validation fails it will move on to the next type and so forth, left to right. You must be careful as some types will succeed with any input, such as String. Thus put String at the end of your list. In non-\/explicit mode, Date and Reg\+Exp will succeed with a large variety of input -\/ also be careful with these and list them near the end if not last in your list.

Whitespace between special characters and elements is inconsequential.

\subsection*{Options}

Options is an object. It is an optional parameter to the {\ttfamily parse} and {\ttfamily parsed\+Type\+Parse} functions.

\subsubsection*{Explicit}

A {\ttfamily Boolean}. By default it is {\ttfamily false}.

{\bfseries Example\+:}


\begin{DoxyCode}
parse('RegExp', 're', \{explicit: false\});          // /re/
parse('RegExp', 're', \{explicit: true\});           // Error: ... does not type check...
parse('RegExp | String', 're', \{explicit: true\});  // 're'
\end{DoxyCode}


{\ttfamily explicit} sets whether to be in explicit mode or not. Using {\ttfamily $\ast$} automatically activates explicit mode. For more information, read the \href{#levn-format}{\tt levn format} section.

\subsubsection*{custom\+Types}

An {\ttfamily Object}. Empty {\ttfamily \{\}} by default.

{\bfseries Example\+:}


\begin{DoxyCode}
var options = \{
  customTypes: \{
    Even: \{
      typeOf: 'Number',
      validate: function (x) \{
        return x % 2 === 0;
      \},
      cast: function (x) \{
        return \{type: 'Just', value: parseInt(x)\};
      \}
    \}
  \}
\}
parse('Even', '2', options); // 2
parse('Even', '3', options); // Error: Value: "3" does not type check...
\end{DoxyCode}


{\bfseries Another Example\+:} 
\begin{DoxyCode}
function Person(name, age)\{
  this.name = name;
  this.age = age;
\}
var options = \{
  customTypes: \{
    Person: \{
      typeOf: 'Object',
      validate: function (x) \{
        x instanceof Person;
      \},
      cast: function (value, options, typesCast) \{
        var name, age;
        if (\{\}.toString.call(value).slice(8, -1) !== 'Object') \{
          return \{type: 'Nothing'\};
        \}
        name = typesCast(value.name, [\{type: 'String'\}], options);
        age = typesCast(value.age, [\{type: 'Numger'\}], options);
        return \{type: 'Just', value: new Person(name, age)\};
    \}
  \}
\}
parse('Person', '\{name: Laura, age: 25\}', options); // Person \{name: 'Laura', age: 25\}
\end{DoxyCode}


{\ttfamily custom\+Types} is an object whose keys are the name of the types, and whose values are an object with three properties, {\ttfamily type\+Of}, {\ttfamily validate}, and {\ttfamily cast}. For more information about {\ttfamily type\+Of} and {\ttfamily validate}, please see the \href{https://github.com/gkz/type-check#custom-types}{\tt custom types} section of type-\/check.

{\ttfamily cast} is a function which receives three arguments, the value under question, options, and the types\+Cast function. In {\ttfamily cast}, attempt to cast the value into the specified type. If you are successful, return an object in the format `\{type\+: \textquotesingle{}Just', value\+: C\+A\+S\+T-\/\+V\+A\+L\+UE\}{\ttfamily , if you know it won\textquotesingle{}t work, return}\{type\+: \textquotesingle{}Nothing\textquotesingle{}\}{\ttfamily . You can use the}types\+Cast{\ttfamily function to cast any child values. Remember to pass}options{\ttfamily to it. In your function you can also check for}options.\+explicit\`{} and act accordingly.

\subsection*{Technical About}

{\ttfamily levn} is written in \href{http://livescript.net/}{\tt Live\+Script} -\/ a language that compiles to Java\+Script. It uses \href{https://github.com/gkz/type-check}{\tt type-\/check} to both parse types and validate values. It also uses the \href{http://preludels.com/}{\tt prelude.\+ls} library. 