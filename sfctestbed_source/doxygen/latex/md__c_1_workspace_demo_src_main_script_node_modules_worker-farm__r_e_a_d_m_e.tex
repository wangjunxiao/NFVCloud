\href{https://nodei.co/npm/worker-farm/}{\tt } \href{https://nodei.co/npm/worker-farm/}{\tt }

Distribute processing tasks to child processes with an über-\/simple A\+PI and baked-\/in durability \& custom concurrency options. {\itshape Available in npm as {\bfseries worker-\/farm}}.

\subsection*{Example}

Given a file, {\itshape child.\+js}\+:


\begin{DoxyCode}
module.exports = function (inp, callback) \{
  callback(null, inp + ' BAR (' + process.pid + ')')
\}
\end{DoxyCode}


And a main file\+:


\begin{DoxyCode}
var workerFarm = require('worker-farm')
  , workers    = workerFarm(require.resolve('./child'))
  , ret        = 0

for (var i = 0; i < 10; i++) \{
  workers('#' + i + ' FOO', function (err, outp) \{
    console.log(outp)
    if (++ret == 10)
      workerFarm.end(workers)
  \})
\}
\end{DoxyCode}


We\textquotesingle{}ll get an output something like the following\+:


\begin{DoxyCode}
#1 FOO BAR (8546)
#0 FOO BAR (8545)
#8 FOO BAR (8545)
#9 FOO BAR (8546)
#2 FOO BAR (8548)
#4 FOO BAR (8551)
#3 FOO BAR (8549)
#6 FOO BAR (8555)
#5 FOO BAR (8553)
#7 FOO BAR (8557)
\end{DoxyCode}


This example is contained in the {\itshape \href{https://github.com/rvagg/node-worker-farm/tree/master/examples/basic/}{\tt examples/basic}} directory.

\subsubsection*{Example \#1\+: Estimating π using child workers}

You will also find a more complex example in {\itshape \href{https://github.com/rvagg/node-worker-farm/tree/master/examples/pi/}{\tt examples/pi}} that estimates the value of {\bfseries π} by using a Monte Carlo {\itshape area-\/under-\/the-\/curve} method and compares the speed of doing it all in-\/process vs using child workers to complete separate portions.

Running {\ttfamily node examples/pi} will give you something like\+:


\begin{DoxyCode}
Doing it the slow (single-process) way...
π ≈ 3.1416269360000006  (0.0000342824102075312 away from actual!)
took 8341 milliseconds
Doing it the fast (multi-process) way...
π ≈ 3.1416233600000036  (0.00003070641021052367 away from actual!)
took 1985 milliseconds
\end{DoxyCode}


\subsection*{Durability}

An important feature of Worker Farm is {\bfseries call durability}. If a child process dies for any reason during the execution of call(s), those calls will be re-\/queued and taken care of by other child processes. In this way, when you ask for something to be done, unless there is something {\itshape seriously} wrong with what you\textquotesingle{}re doing, you should get a result on your callback function.

\subsection*{My use-\/case}

There are other libraries for managing worker processes available but my use-\/case was fairly specific\+: I need to make heavy use of the \href{https://github.com/nearinfinity/node-java}{\tt node-\/java} library to interact with J\+VM code. Unfortunately, because the J\+VM garbage collector is so difficult to interact with, it\textquotesingle{}s prone to killing your Node process when the GC kicks under heavy load. For safety I needed a durable way to make calls so that (1) it wouldn\textquotesingle{}t kill my main process and (2) any calls that weren\textquotesingle{}t successful would be resubmitted for processing.

Worker Farm allows me to spin up multiple J\+V\+Ms to be controlled by Node, and have a single, uncomplicated A\+PI that acts the same way as an in-\/process A\+PI and the calls will be taken care of by a child process even if an error kills a child process while it is working as the call will simply be passed to a new child process.

{\bfseries But}, don\textquotesingle{}t think that Worker Farm is specific to that use-\/case, it\textquotesingle{}s designed to be very generic and simple to adapt to anything requiring the use of child Node processes.

\subsection*{A\+PI}

Worker Farm exports a main function and an {\ttfamily end()} method. The main function sets up a \char`\"{}farm\char`\"{} of coordinated child-\/process workers and it can be used to instantiate multiple farms, all operating independently.

\subsubsection*{worker\+Farm(\mbox{[}options, \mbox{]}path\+To\+Module\mbox{[}, exported\+Methods\mbox{]})}

In its most basic form, you call {\ttfamily worker\+Farm()} with the path to a module file to be invoked by the child process. You should use an {\bfseries absolute path} to the module file, the best way to obtain the path is with `require.\+resolve('./path/to/module\textquotesingle{}){\ttfamily , this function can be used in exactly the same way as}require(\textquotesingle{}./path/to/module\textquotesingle{})\`{} but it returns an absolute path.

\paragraph*{{\ttfamily exported\+Methods}}

If your module exports a single function on {\ttfamily module.\+exports} then you should omit the final parameter. However, if you are exporting multiple functions on {\ttfamily module.\+exports} then you should list them in an Array of Strings\+:


\begin{DoxyCode}
var workers = workerFarm(require.resolve('./mod'), [ 'doSomething', 'doSomethingElse' ])
workers.doSomething(function () \{\})
workers.doSomethingElse(function () \{\})
\end{DoxyCode}


Listing the available methods will instruct Worker Farm what A\+PI to provide you with on the returned object. If you don\textquotesingle{}t list a {\ttfamily exported\+Methods} Array then you\textquotesingle{}ll get a single callable function to use; but if you list the available methods then you\textquotesingle{}ll get an object with callable functions by those names.

{\bfseries It is assumed that each function you call on your child module will take a {\ttfamily callback} function as the last argument.}

\paragraph*{{\ttfamily options}}

If you don\textquotesingle{}t provide an {\ttfamily options} object then the following defaults will be used\+:


\begin{DoxyCode}
\{
    maxCallsPerWorker           : Infinity
  , maxConcurrentWorkers        : require('os').cpus().length
  , maxConcurrentCallsPerWorker : 10
  , maxConcurrentCalls          : Infinity
  , maxCallTime                 : Infinity
  , maxRetries                  : Infinity
  , autoStart                   : false
\}
\end{DoxyCode}



\begin{DoxyItemize}
\item $\ast$$\ast${\ttfamily max\+Calls\+Per\+Worker}$\ast$$\ast$ allows you to control the lifespan of your child processes. A positive number will indicate that you only want each child to accept that many calls before it is terminated. This may be useful if you need to control memory leaks or similar in child processes.
\item $\ast$$\ast${\ttfamily max\+Concurrent\+Workers}$\ast$$\ast$ will set the number of child processes to maintain concurrently. By default it is set to the number of C\+P\+Us available on the current system, but it can be any reasonable number, including {\ttfamily 1}.
\item $\ast$$\ast${\ttfamily max\+Concurrent\+Calls\+Per\+Worker}$\ast$$\ast$ allows you to control the {\itshape concurrency} of individual child processes. Calls are placed into a queue and farmed out to child processes according to the number of calls they are allowed to handle concurrently. It is arbitrarily set to 10 by default so that calls are shared relatively evenly across workers, however if your calls predictably take a similar amount of time then you could set it to {\ttfamily Infinity} and Worker Farm won\textquotesingle{}t queue any calls but spread them evenly across child processes and let them go at it. If your calls aren\textquotesingle{}t I/O bound then it won\textquotesingle{}t matter what value you use here as the individual workers won\textquotesingle{}t be able to execute more than a single call at a time.
\item $\ast$$\ast${\ttfamily max\+Concurrent\+Calls}$\ast$$\ast$ allows you to control the maximum number of calls in the queue---either actively being processed or waiting for a worker to be processed. {\ttfamily Infinity} indicates no limit but if you have conditions that may endlessly queue jobs and you need to set a limit then provide a {\ttfamily $>$0} value and any calls that push the limit will return on their callback with a {\ttfamily Max\+Concurrent\+Calls\+Error} error (check `err.\+type == \textquotesingle{}Max\+Concurrent\+Calls\+Error'\`{}).
\item $\ast$$\ast${\ttfamily max\+Call\+Time}$\ast$$\ast$ $\ast$(use with caution, understand what this does before you use it!)$\ast$ when {\ttfamily !== Infinity}, will cap a time, in milliseconds, that {\itshape any single call} can take to execute in a worker. If this time limit is exceeded by just a single call then the worker running that call will be killed and any calls running on that worker will have their callbacks returned with a {\ttfamily Timeout\+Error} (check `err.\+type == \textquotesingle{}Timeout\+Error'{\ttfamily ). If you are running with}max\+Concurrent\+Calls\+Per\+Worker{\ttfamily value greater than}1{\ttfamily then $\ast$$\ast$all calls currently executing$\ast$$\ast$ will fail and will be automatically resubmitted uless you\textquotesingle{}ve changed the}max\+Retries{\ttfamily option. Use this if you have jobs that may potentially end in infinite loops that you can\textquotesingle{}t programatically end with your child code. Preferably run this with a}max\+Concurrent\+Calls\+Per\+Worker\`{} so you don\textquotesingle{}t interrupt other calls when you have a timeout. This timeout operates on a per-\/call basis but will interrupt a whole worker.
\item $\ast$$\ast${\ttfamily max\+Retries}$\ast$$\ast$ allows you to control the max number of call requeues after worker termination (unexpected or timeout). By default this option is set to {\ttfamily Infinity} which means that each call of each terminated worker will always be auto requeued. When the number of retries exceeds {\ttfamily max\+Retries} value, the job callback will be executed with a {\ttfamily Process\+Terminated\+Error}. Note that if you are running with finite {\ttfamily max\+Call\+Time} and {\ttfamily max\+Concurrent\+Calls\+Per\+Workers} greater than {\ttfamily 1} then any {\ttfamily Timeout\+Error} will increase the retries counter {\itshape for each} concurrent call of the terminated worker.
\item $\ast$$\ast${\ttfamily auto\+Start}$\ast$$\ast$ when set to {\ttfamily true} will start the workers as early as possible. Use this when your workers have to do expensive initialization. That way they\textquotesingle{}ll be ready when the first request comes through.
\end{DoxyItemize}

\subsubsection*{worker\+Farm.\+end(farm)}

Child processes stay alive waiting for jobs indefinitely and your farm manager will stay alive managing its workers, so if you need it to stop then you have to do so explicitly. If you send your farm A\+PI to {\ttfamily worker\+Farm.\+end()} then it\textquotesingle{}ll cleanly end your worker processes. Note though that it\textquotesingle{}s a {\itshape soft} ending so it\textquotesingle{}ll wait for child processes to finish what they are working on before asking them to die.

Any calls that are queued and not yet being handled by a child process will be discarded. {\ttfamily end()} only waits for those currently in progress.

Once you end a farm, it won\textquotesingle{}t handle any more calls, so don\textquotesingle{}t even try!

\subsection*{Related}


\begin{DoxyItemize}
\item \href{https://github.com/Kikobeats/farm-cli}{\tt farm-\/cli} – Launch a farm of workers from C\+LI.
\end{DoxyItemize}

\subsection*{License}

Worker Farm is Copyright (c) 2014 Rod Vagg \href{https://twitter.com/rvagg}{\tt } and licensed under the M\+IT license. All rights not explicitly granted in the M\+IT license are reserved. See the included L\+I\+C\+E\+N\+S\+E.\+md file for more details. 