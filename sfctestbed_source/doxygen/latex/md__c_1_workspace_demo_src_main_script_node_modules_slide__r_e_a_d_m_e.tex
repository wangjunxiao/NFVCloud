\subsection*{What\textquotesingle{}s actually hard?}


\begin{DoxyItemize}
\item Doing a bunch of things in a specific order.
\item Knowing when stuff is done.
\item Handling failures.
\item Breaking up functionality into parts (avoid nested inline callbacks)
\end{DoxyItemize}

\subsection*{Common Mistakes}


\begin{DoxyItemize}
\item Abandoning convention and consistency.
\item Putting all callbacks inline.
\item Using libraries without grokking them.
\item Trying to make async code look sync.
\end{DoxyItemize}

\subsection*{Define Conventions}


\begin{DoxyItemize}
\item Two kinds of functions\+: {\itshape actors} take action, {\itshape callbacks} get results.
\item Essentially the continuation pattern. Resulting code {\itshape looks} similar to fibers, but is {\itshape much} simpler to implement.
\item Node works this way in the lowlevel A\+P\+Is already, and it\textquotesingle{}s very ï¬‚exible.
\end{DoxyItemize}

\subsection*{Callbacks}


\begin{DoxyItemize}
\item Simple responders
\item Must always be prepared to handle errors, that\textquotesingle{}s why it\textquotesingle{}s the first argument.
\item Often inline anonymous, but not always.
\item Can trap and call other callbacks with modified data, or pass errors upwards.
\end{DoxyItemize}

\subsection*{Actors}


\begin{DoxyItemize}
\item Last argument is a callback.
\item If any error occurs, and can\textquotesingle{}t be handled, pass it to the callback and return.
\item Must not throw. Return value ignored.
\item return x ==$>$ return cb(null, x)
\item throw er ==$>$ return cb(er)
\end{DoxyItemize}


\begin{DoxyCode}
// return true if a path is either
// a symlink or a directory.
function isLinkOrDir (path, cb) \{
  fs.lstat(path, function (er, s) \{
    if (er) return cb(er)
    return cb(null, s.isDirectory() || s.isSymbolicLink())
  \})
\}
\end{DoxyCode}


\section*{async\+Map}

\subsection*{Usecases}


\begin{DoxyItemize}
\item I have a list of 10 files, and need to read all of them, and then continue when they\textquotesingle{}re all done.
\item I have a dozen U\+R\+Ls, and need to fetch them all, and then continue when they\textquotesingle{}re all done.
\item I have 4 connected users, and need to send a message to all of them, and then continue when that\textquotesingle{}s done.
\item I have a list of n things, and I need to dosomething with all of them, in parallel, and get the results once they\textquotesingle{}re all complete.
\end{DoxyItemize}

\subsection*{Solution}


\begin{DoxyCode}
var asyncMap = require("slide").asyncMap
function writeFiles (files, what, cb) \{
  asyncMap(files, function (f, cb) \{
    fs.writeFile(f, what, cb)
  \}, cb)
\}
writeFiles([my, file, list], "foo", cb)
\end{DoxyCode}


\section*{chain}

\subsection*{Usecases}


\begin{DoxyItemize}
\item I have to do a bunch of things, in order. Get db credentials out of a file, read the data from the db, write that data to another file.
\item If anything fails, do not continue.
\item I still have to provide an array of functions, which is a lot of boilerplate, and a pita if your functions take args like
\end{DoxyItemize}


\begin{DoxyCode}
function (cb) \{
  blah(a, b, c, cb)
\}
\end{DoxyCode}



\begin{DoxyItemize}
\item Results are discarded, which is a bit lame.
\item No way to branch.
\end{DoxyItemize}

\subsection*{Solution}


\begin{DoxyItemize}
\item reduces boilerplate by converting an array of \mbox{[}fn, args\mbox{]} to an actor that takes no arguments (except cb)
\item A bit like Function\+::bind, but tailored for our use-\/case.
\item bind\+Actor(obj, \char`\"{}method\char`\"{}, a, b, c)
\item bind\+Actor(fn, a, b, c)
\item bind\+Actor(obj, fn, a, b, c)
\item branching, skipping over falsey arguments
\end{DoxyItemize}


\begin{DoxyCode}
chain([
  doThing && [thing, a, b, c]
, isFoo && [doFoo, "foo"]
, subChain && [chain, [one, two]]
], cb)
\end{DoxyCode}



\begin{DoxyItemize}
\item tracking results\+: results are stored in an optional array passed as argument, last result is always in results\mbox{[}results.\+length -\/ 1\mbox{]}.
\item treat chain.\+first and chain.\+last as placeholders for the first/last result up until that point.
\end{DoxyItemize}

\subsection*{Non-\/trivial example}


\begin{DoxyItemize}
\item Read number files in a directory
\item Add the results together
\item Ping a web service with the result
\item Write the response to a file
\item Delete the number files
\end{DoxyItemize}


\begin{DoxyCode}
var chain = require("slide").chain
function myProgram (cb) \{
  var res = [], last = chain.last, first = chain.first
  chain([
    [fs, "readdir", "the-directory"]
  , [readFiles, "the-directory", last]
  , [sum, last]
  , [ping, "POST", "example.com", 80, "/foo", last]
  , [fs, "writeFile", "result.txt", last]
  , [rmFiles, "./the-directory", first]
  ], res, cb)
\}
\end{DoxyCode}


\section*{Conclusion\+: Convention Profits}


\begin{DoxyItemize}
\item Consistent A\+PI from top to bottom.
\item Sneak in at any point to inject functionality. Testable, reusable, ...
\item When ruby and python users whine, you can smile condescendingly. 
\end{DoxyItemize}