Post\+C\+SS can transform styles in any syntax, and is not limited to just C\+SS. By writing a custom syntax, you can transform styles in any desired format.

Writing a custom syntax is much harder than writing a Post\+C\+SS plugin, but it is an awesome adventure.

There are 3 types of Post\+C\+SS syntax packages\+:


\begin{DoxyItemize}
\item {\bfseries Parser} to parse input string to node’s tree.
\item {\bfseries Stringifier} to generate output string by node’s tree.
\item {\bfseries Syntax} contains both parser and stringifier.
\end{DoxyItemize}

\subsection*{Syntax}

A good example of a custom syntax is \href{https://github.com/postcss/postcss-scss}{\tt S\+C\+SS}. Some users may want to transform S\+C\+SS sources with Post\+C\+SS plugins, for example if they need to add vendor prefixes or change the property order. So this syntax should output S\+C\+SS from an S\+C\+SS input.

The syntax A\+PI is a very simple plain object, with {\ttfamily parse} \& {\ttfamily stringify} functions\+:


\begin{DoxyCode}
module.exports = \{
    parse:     require('./parse'),
    stringify: require('./stringify')
\};
\end{DoxyCode}


\subsection*{Parser}

A good example of a parser is \href{https://github.com/postcss/postcss-safe-parser}{\tt Safe Parser}, which parses malformed/broken C\+SS. Because there is no point to generate broken output, this package only provides a parser.

The parser A\+PI is a function which receives a string \& returns a \href{http://api.postcss.org/Root.html}{\tt {\ttfamily Root}} node. The second argument is a function which receives an object with Post\+C\+SS options.


\begin{DoxyCode}
var postcss = require('postcss');

module.exports = function (css, opts) \{
    var root = postcss.root();
    // Add other nodes to root
    return root;
\};
\end{DoxyCode}


\subsubsection*{Main Theory}

There are many books about parsers; but do not worry because C\+SS syntax is very easy, and so the parser will be much simpler than a programming language parser.

The default Post\+C\+SS parser contains two steps\+:


\begin{DoxyEnumerate}
\item \href{https://github.com/postcss/postcss/blob/master/lib/tokenize.es6}{\tt Tokenizer} which reads input string character by character and builds a tokens array. For example, it joins space symbols to a `\mbox{[}\textquotesingle{}space', \textquotesingle{}~\newline
 \textquotesingle{}\mbox{]}{\ttfamily  token, and detects strings to a}\mbox{[}\textquotesingle{}string\textquotesingle{}, \textquotesingle{}\char`\"{}\textbackslash{}\char`\"{}\{\char`\"{}\textquotesingle{}\mbox{]}\`{} token.
2. $<$a href=\char`\"{}\href{https://github.com/postcss/postcss/blob/master/lib/parser.es6}{\tt https\+://github.\+com/postcss/postcss/blob/master/lib/parser.\+es6}"$>$Parser which reads the tokens array, creates node instances and builds a tree.
\end{DoxyEnumerate}

\subsubsection*{Performance}

Parsing input is often the most time consuming task in C\+SS processors. So it is very important to have a fast parser.

The main rule of optimization is that there is no performance without a benchmark. You can look at \href{https://github.com/postcss/benchmark}{\tt Post\+C\+SS benchmarks} to build your own.

Of parsing tasks, the tokenize step will often take the most time, so its performance should be prioritized. Unfortunately, classes, functions and high level structures can slow down your tokenizer. Be ready to write dirty code with repeated statements. This is why it is difficult to extend the default \href{https://github.com/postcss/postcss/blob/master/lib/tokenize.es6}{\tt Post\+C\+SS tokenizer}; copy \& paste will be a necessary evil.

Second optimization is using character codes instead of strings.


\begin{DoxyCode}
// Slow
string[i] === '\{';

// Fast
const OPEN\_CURLY = 123; // `\{'
string.charCodeAt(i) === OPEN\_CURLY;
\end{DoxyCode}


Third optimization is “fast jumps”. If you find open quotes, you can find next closing quote much faster by {\ttfamily index\+Of}\+:


\begin{DoxyCode}
// Simple jump
next = string.indexOf('"', currentPosition + 1);

// Jump by RegExp
regexp.lastIndex = currentPosion + 1;
regexp.text(string);
next = regexp.lastIndex;
\end{DoxyCode}


The parser can be a well written class. There is no need in copy-\/paste and hardcore optimization there. You can extend the default \href{https://github.com/postcss/postcss/blob/master/lib/parser.es6}{\tt Post\+C\+SS parser}.

\subsubsection*{Node Source}

Every node should have {\ttfamily source} property to generate correct source map. This property contains {\ttfamily start} and {\ttfamily end} properties with {\ttfamily \{ line, column \}}, and {\ttfamily input} property with an \href{https://github.com/postcss/postcss/blob/master/lib/input.es6}{\tt {\ttfamily Input}} instance.

Your tokenizer should save the original position so that you can propagate the values to the parser, to ensure that the source map is correctly updated.

\subsubsection*{Raw Values}

A good Post\+C\+SS parser should provide all information (including spaces symbols) to generate byte-\/to-\/byte equal output. It is not so difficult, but respectful for user input and allow integration smoke tests.

A parser should save all additional symbols to {\ttfamily node.\+raws} object. It is an open structure for you, you can add additional keys. For example, \href{https://github.com/postcss/postcss-scss}{\tt S\+C\+SS parser} saves comment types ({\ttfamily /$\ast$ $\ast$/} or {\ttfamily //}) in {\ttfamily node.\+raws.\+inline}.

The default parser cleans C\+SS values from comments and spaces. It saves the original value with comments to {\ttfamily node.\+raws.\+value.\+raw} and uses it, if the node value was not changed.

\subsubsection*{Tests}

Of course, all parsers in the Post\+C\+SS ecosystem must have tests.

If your parser just extends C\+SS syntax (like \href{https://github.com/postcss/postcss-scss}{\tt S\+C\+SS} or \href{https://github.com/postcss/postcss-safe-parser}{\tt Safe Parser}), you can use the \href{https://github.com/postcss/postcss-parser-tests}{\tt Post\+C\+SS Parser Tests}. It contains unit \& integration tests.

\subsection*{Stringifier}

A style guide generator is a good example of a stringifier. It generates output H\+T\+ML which contains C\+SS components. For this use case, a parser isn\textquotesingle{}t necessary, so the package should just contain a stringifier.

The Stringifier A\+PI is little bit more complicated, than the parser A\+PI. Post\+C\+SS generates a source map, so a stringifier can’t just return a string. It must link every substring with its source node.

A Stringifier is a function which receives \href{http://api.postcss.org/Root.html}{\tt {\ttfamily Root}} node and builder callback. Then it calls builder with every node’s string and node instance.


\begin{DoxyCode}
module.exports = function (root, builder) \{
    // Some magic
    var string = decl.prop + ':' + decl.value + ';';
    builder(string, decl);
    // Some science
\};
\end{DoxyCode}


\subsubsection*{Main Theory}

Post\+C\+SS \href{https://github.com/postcss/postcss/blob/master/lib/stringifier.es6}{\tt default stringifier} is just a class with a method for each node type and many methods to detect raw properties.

In most cases it will be enough just to extend this class, like in \href{https://github.com/postcss/postcss-scss/blob/master/lib/scss-stringifier.es6}{\tt S\+C\+SS stringifier}.

\subsubsection*{Builder Function}

A builder function will be passed to {\ttfamily stringify} function as second argument. For example, the default Post\+C\+SS stringifier class saves it to {\ttfamily this.\+builder} property.

Builder receives output substring and source node to append this substring to the final output.

Some nodes contain other nodes in the middle. For example, a rule has a {\ttfamily \{} at the beginning, many declarations inside and a closing {\ttfamily \}}.

For these cases, you should pass a third argument to builder function\+: `\textquotesingle{}start'{\ttfamily or}\textquotesingle{}end\textquotesingle{}\`{} string\+:


\begin{DoxyCode}
this.builder(rule.selector + '\{', rule, 'start');
// Stringify declarations inside
this.builder('\}', rule, 'end');
\end{DoxyCode}


\subsubsection*{Raw Values}

A good Post\+C\+SS custom syntax saves all symbols and provide byte-\/to-\/byte equal output if there were no changes.

This is why every node has {\ttfamily node.\+raws} object to store space symbol, etc.

Be careful, because sometimes these raw properties will not be present; some nodes may be built manually, or may lose their indentation when they are moved to another parent node.

This is why the default stringifier has a {\ttfamily raw()} method to autodetect raw properties by other nodes. For example, it will look at other nodes to detect indent size and them multiply it with the current node depth.

\subsubsection*{Tests}

A stringifier must have tests too.

You can use unit and integration test cases from \href{https://github.com/postcss/postcss-parser-tests}{\tt Post\+C\+SS Parser Tests}. Just compare input C\+SS with C\+SS after your parser and stringifier. 