Yargs be a node.\+js library fer hearties tryin\textquotesingle{} ter parse optstrings.

With yargs, ye be havin\textquotesingle{} a map that leads straight to yer treasure! Treasure of course, being a simple option hash.

\href{https://travis-ci.org/yargs/yargs}{\tt } \href{https://coveralls.io/github/yargs/yargs}{\tt } \href{https://www.npmjs.com/package/yargs}{\tt } \href{https://ci.appveyor.com/project/bcoe/yargs-ljwvf}{\tt } \href{http://standardjs.com/}{\tt } \href{https://github.com/conventional-changelog/standard-version}{\tt } \href{https://gitter.im/yargs/Lobby?utm_source=share-link&utm_medium=link&utm_campaign=share-link}{\tt }

\begin{quote}
Yargs is the official successor to optimist. Please feel free to submit issues and pull requests. If you\textquotesingle{}d like to contribute and don\textquotesingle{}t know where to start, have a look at \href{https://github.com/yargs/yargs/issues}{\tt the issue list} \+:) \end{quote}


\section*{examples }

\subsection*{With yargs, the options be just a hash! }

plunder.\+js\+:


\begin{DoxyCode}
#!/usr/bin/env node
var argv = require('yargs').argv;

if (argv.ships > 3 && argv.distance < 53.5) \{
    console.log('Plunder more riffiwobbles!');
\} else \{
    console.log('Retreat from the xupptumblers!');
\}
\end{DoxyCode}




 \begin{DoxyVerb}$ ./plunder.js --ships=4 --distance=22
Plunder more riffiwobbles!

$ ./plunder.js --ships 12 --distance 98.7
Retreat from the xupptumblers!
\end{DoxyVerb}




\subsection*{But don\textquotesingle{}t walk the plank just yet! There be more! You can do short options\+: }

short.\+js\+:


\begin{DoxyCode}
#!/usr/bin/env node
var argv = require('yargs').argv;
console.log('(%d,%d)', argv.x, argv.y);
\end{DoxyCode}




 \begin{DoxyVerb}$ ./short.js -x 10 -y 21
(10,21)
\end{DoxyVerb}


\subsection*{And booleans, both long, short, and even grouped\+: }

bool.\+js\+:


\begin{DoxyCode}
#!/usr/bin/env node
var argv = require('yargs').argv;

if (argv.s) \{
    process.stdout.write(argv.fr ? 'Le perroquet dit: ' : 'The parrot says: ');
\}
console.log(
    (argv.fr ? 'couac' : 'squawk') + (argv.p ? '!' : '')
);
\end{DoxyCode}




 \begin{DoxyVerb}$ ./bool.js -s
The parrot says: squawk

$ ./bool.js -sp
The parrot says: squawk!

$ ./bool.js -sp --fr
Le perroquet dit: couac!
\end{DoxyVerb}


\subsection*{And non-\/hyphenated options too! Just use {\ttfamily argv.\+\_\+}! }

nonopt.\+js\+:


\begin{DoxyCode}
#!/usr/bin/env node
var argv = require('yargs').argv;
console.log('(%d,%d)', argv.x, argv.y);
console.log(argv.\_);
\end{DoxyCode}




 \begin{DoxyVerb}$ ./nonopt.js -x 6.82 -y 3.35 rum
(6.82,3.35)
[ 'rum' ]

$ ./nonopt.js "me hearties" -x 0.54 yo -y 1.12 ho
(0.54,1.12)
[ 'me hearties', 'yo', 'ho' ]
\end{DoxyVerb}


\subsection*{Yargs even counts your booleans! }

count.\+js\+:


\begin{DoxyCode}
#!/usr/bin/env node
var argv = require('yargs')
    .count('verbose')
    .alias('v', 'verbose')
    .argv;

VERBOSE\_LEVEL = argv.verbose;

function WARN()  \{ VERBOSE\_LEVEL >= 0 && console.log.apply(console, arguments); \}
function INFO()  \{ VERBOSE\_LEVEL >= 1 && console.log.apply(console, arguments); \}
function DEBUG() \{ VERBOSE\_LEVEL >= 2 && console.log.apply(console, arguments); \}

WARN("Showing only important stuff");
INFO("Showing semi-important stuff too");
DEBUG("Extra chatty mode");
\end{DoxyCode}




 \$ node count.\+js Showing only important stuff

\$ node count.\+js -\/v Showing only important stuff Showing semi-\/important stuff too

\$ node count.\+js -\/vv Showing only important stuff Showing semi-\/important stuff too Extra chatty mode

\$ node count.\+js -\/v --verbose Showing only important stuff Showing semi-\/important stuff too Extra chatty mode

\subsection*{Tell users how to use yer options and make demands. }

area.\+js\+:


\begin{DoxyCode}
#!/usr/bin/env node
var argv = require('yargs')
    .usage('Usage: $0 -w [num] -h [num]')
    .demandOption(['w','h'])
    .argv;

console.log("The area is:", argv.w * argv.h);
\end{DoxyCode}




 \begin{DoxyVerb}$ ./area.js -w 55 -h 11
The area is: 605

$ node ./area.js -w 4.91 -w 2.51
Usage: area.js -w [num] -h [num]

Options:
  -w  [required]
  -h  [required]

Missing required arguments: h
\end{DoxyVerb}


\subsection*{After yer demands have been met, demand more! Ask for non-\/hyphenated arguments! }

demand\+\_\+count.\+js\+:


\begin{DoxyCode}
#!/usr/bin/env node
var argv = require('yargs')
    .demandCommand(2)
    .argv;
console.dir(argv);
\end{DoxyCode}




 \begin{DoxyVerb}$ ./demand_count.js a

Not enough non-option arguments: got 1, need at least 2

$ ./demand_count.js a b
{ _: [ 'a', 'b' ], '$0': 'demand_count.js' }

$ ./demand_count.js a b c
{ _: [ 'a', 'b', 'c' ], '$0': 'demand_count.js' }
\end{DoxyVerb}


\subsection*{E\+V\+EN M\+O\+RE S\+H\+I\+V\+ER ME T\+I\+M\+B\+E\+R\+S! }

default\+\_\+singles.\+js\+:


\begin{DoxyCode}
#!/usr/bin/env node
var argv = require('yargs')
    .default('x', 10)
    .default('y', 10)
    .argv
;
console.log(argv.x + argv.y);
\end{DoxyCode}




 \begin{DoxyVerb}$ ./default_singles.js -x 5
15
\end{DoxyVerb}


default\+\_\+hash.\+js\+:


\begin{DoxyCode}
#!/usr/bin/env node
var argv = require('yargs')
    .default(\{ x : 10, y : 10 \})
    .argv
;
console.log(argv.x + argv.y);
\end{DoxyCode}




 \begin{DoxyVerb}$ ./default_hash.js -y 7
17
\end{DoxyVerb}


\subsection*{And if you really want to get all descriptive about it... }

boolean\+\_\+single.\+js\+:


\begin{DoxyCode}
#!/usr/bin/env node
var argv = require('yargs')
    .boolean('v')
    .argv
;
console.dir(argv.v);
console.dir(argv.\_);
\end{DoxyCode}




 \begin{DoxyVerb}$ ./boolean_single.js -v "me hearties" yo ho
true
[ 'me hearties', 'yo', 'ho' ]
\end{DoxyVerb}


boolean\+\_\+double.\+js\+:


\begin{DoxyCode}
#!/usr/bin/env node
var argv = require('yargs')
    .boolean(['x','y','z'])
    .argv
;
console.dir([ argv.x, argv.y, argv.z ]);
console.dir(argv.\_);
\end{DoxyCode}




 \begin{DoxyVerb}$ ./boolean_double.js -x -z one two three
[ true, false, true ]
[ 'one', 'two', 'three' ]
\end{DoxyVerb}


\subsection*{Yargs is here to help you... }

Ye can describe parameters fer help messages and set aliases. Yargs figures out how ter format a handy help string automatically.

line\+\_\+count.\+js\+:


\begin{DoxyCode}
#!/usr/bin/env node
var argv = require('yargs')
    .usage('Usage: $0 <command> [options]')
    .command('count', 'Count the lines in a file')
    .example('$0 count -f foo.js', 'count the lines in the given file')
    .alias('f', 'file')
    .nargs('f', 1)
    .describe('f', 'Load a file')
    .demandOption(['f'])
    .help('h')
    .alias('h', 'help')
    .epilog('copyright 2015')
    .argv;

var fs = require('fs');
var s = fs.createReadStream(argv.file);

var lines = 0;
s.on('data', function (buf) \{
    lines += buf.toString().match(/\(\backslash\)n/g).length;
\});

s.on('end', function () \{
    console.log(lines);
\});
\end{DoxyCode}




 \$ node line\+\_\+count.\+js count Usage\+: line\+\_\+count.\+js $<$command$>$ \mbox{[}options\mbox{]}

Commands\+: count Count the lines in a file

Options\+: -\/f, --file Load a file \mbox{[}required\mbox{]} -\/h, --help Show help \mbox{[}boolean\mbox{]}

Examples\+: line\+\_\+count.\+js count -\/f foo.\+js count the lines in the given file

copyright 2015

Missing required arguments\+: f

\$ node line\+\_\+count.\+js count --file line\+\_\+count.\+js 26

\$ node line\+\_\+count.\+js count -\/f line\+\_\+count.\+js 26

\section*{methods }

By itself,


\begin{DoxyCode}
require('yargs').argv
\end{DoxyCode}


will use the {\ttfamily process.\+argv} array to construct the {\ttfamily argv} object.

You can pass in the {\ttfamily process.\+argv} yourself\+:


\begin{DoxyCode}
require('yargs')([ '-x', '1', '-y', '2' ]).argv
\end{DoxyCode}


or use {\ttfamily .parse()} to do the same thing\+:


\begin{DoxyCode}
require('yargs').parse([ '-x', '1', '-y', '2' ])
\end{DoxyCode}


The rest of these methods below come in just before the terminating {\ttfamily .argv}.

\subsection*{\label{_alias}%
.alias(key, alias) }

Set key names as equivalent such that updates to a key will propagate to aliases and vice-\/versa.

Optionally {\ttfamily .alias()} can take an object that maps keys to aliases. Each key of this object should be the canonical version of the option, and each value should be a string or an array of strings.

\subsection*{.argv }

Get the arguments as a plain old object.

Arguments without a corresponding flag show up in the {\ttfamily argv.\+\_\+} array.

The script name or node command is available at {\ttfamily argv.\$0} similarly to how {\ttfamily \$0} works in bash or perl.

If {\ttfamily yargs} is executed in an environment that embeds node and there\textquotesingle{}s no script name (e.\+g. \href{http://electron.atom.io/}{\tt Electron} or \href{http://nwjs.io/}{\tt nw.\+js}), it will ignore the first parameter since it expects it to be the script name. In order to override this behavior, use {\ttfamily .parse(process.\+argv.\+slice(1))} instead of {\ttfamily .argv} and the first parameter won\textquotesingle{}t be ignored.

\subsection*{\label{_array}%
.array(key) }

Tell the parser to interpret {\ttfamily key} as an array. If `.array(\textquotesingle{}foo'){\ttfamily is set, }--foo foo bar{\ttfamily will be parsed as}\mbox{[}\textquotesingle{}foo\textquotesingle{}, \textquotesingle{}bar\textquotesingle{}\mbox{]}{\ttfamily rather than as}\textquotesingle{}foo\textquotesingle{}\`{}.

\subsection*{\label{_boolean}%
.boolean(key) }

Interpret {\ttfamily key} as a boolean. If a non-\/flag option follows {\ttfamily key} in {\ttfamily process.\+argv}, that string won\textquotesingle{}t get set as the value of {\ttfamily key}.

{\ttfamily key} will default to {\ttfamily false}, unless a {\ttfamily default(key, undefined)} is explicitly set.

If {\ttfamily key} is an array, interpret all the elements as booleans.

\subsection*{.check(fn) }

Check that certain conditions are met in the provided arguments.

{\ttfamily fn} is called with two arguments, the parsed {\ttfamily argv} hash and an array of options and their aliases.

If {\ttfamily fn} throws or returns a non-\/truthy value, show the thrown error, usage information, and exit.

\subsection*{\label{_choices}%
.choices(key, choices) }

Limit valid values for {\ttfamily key} to a predefined set of {\ttfamily choices}, given as an array or as an individual value.


\begin{DoxyCode}
var argv = require('yargs')
  .alias('i', 'ingredient')
  .describe('i', 'choose your sandwich ingredients')
  .choices('i', ['peanut-butter', 'jelly', 'banana', 'pickles'])
  .help('help')
  .argv
\end{DoxyCode}


If this method is called multiple times, all enumerated values will be merged together. Choices are generally strings or numbers, and value matching is case-\/sensitive.

Optionally {\ttfamily .choices()} can take an object that maps multiple keys to their choices.

Choices can also be specified as {\ttfamily choices} in the object given to {\ttfamily option()}.


\begin{DoxyCode}
var argv = require('yargs')
  .option('size', \{
    alias: 's',
    describe: 'choose a size',
    choices: ['xs', 's', 'm', 'l', 'xl']
  \})
  .argv
\end{DoxyCode}


\subsection*{\label{_coerce}%
.coerce(key, fn) }

Provide a synchronous function to coerce or transform the value(s) given on the command line for {\ttfamily key}.

The coercion function should accept one argument, representing the parsed value from the command line, and should return a new value or throw an error. The returned value will be used as the value for {\ttfamily key} (or one of its aliases) in {\ttfamily argv}.

If the function throws, the error will be treated as a validation failure, delegating to either a custom \href{#fail}{\tt {\ttfamily .fail()}} handler or printing the error message in the console.

Coercion will be applied to a value after all other modifications, such as \href{#normalize}{\tt {\ttfamily .normalize()}}.

{\itshape Examples\+:}


\begin{DoxyCode}
var argv = require('yargs')
  .coerce('file', function (arg) \{
    return require('fs').readFileSync(arg, 'utf8')
  \})
  .argv
\end{DoxyCode}


Optionally {\ttfamily .coerce()} can take an object that maps several keys to their respective coercion function.


\begin{DoxyCode}
var argv = require('yargs')
  .coerce(\{
    date: Date.parse,
    json: JSON.parse
  \})
  .argv
\end{DoxyCode}


You can also map the same function to several keys at one time. Just pass an array of keys as the first argument to {\ttfamily .coerce()}\+:


\begin{DoxyCode}
var path = require('path')
var argv = require('yargs')
  .coerce(['src', 'dest'], path.resolve)
  .argv
\end{DoxyCode}


If you are using dot-\/notion or arrays, .e.\+g., {\ttfamily user.\+email} and {\ttfamily user.\+password}, coercion will be applied to the final object that has been parsed\+:


\begin{DoxyCode}
// --user.name Batman --user.password 123
// gives us: \{name: 'batman', password: '[SECRET]'\}
var argv = require('yargs')
  .option('user')
  .coerce('user', opt => \{
    opt.name = opt.name.toLowerCase()
    opt.password = '[SECRET]'
    return opt
  \})
  .argv
\end{DoxyCode}


\subsection*{.command(cmd, desc, \mbox{[}builder\mbox{]}, \mbox{[}handler\mbox{]}) }

\subsection*{.command(cmd, desc, \mbox{[}module\mbox{]}) }

\subsection*{.command(module) }

Define the commands exposed by your application.

{\ttfamily cmd} should be a string representing the command or an array of strings representing the command and its aliases. Read more about command aliases in the subsection below.

Use {\ttfamily desc} to provide a description for each command your application accepts (the values stored in {\ttfamily argv.\+\_\+}). Set {\ttfamily desc} to {\ttfamily false} to create a hidden command. Hidden commands don\textquotesingle{}t show up in the help output and aren\textquotesingle{}t available for completion.

Optionally, you can provide a {\ttfamily builder} object to give hints about the options that your command accepts\+:


\begin{DoxyCode}
yargs
  .command('get', 'make a get HTTP request', \{
    url: \{
      alias: 'u',
      default: 'http://yargs.js.org/'
    \}
  \})
  .help()
  .argv
\end{DoxyCode}


Note that commands will not automatically inherit configuration {\itshape or} options of their parent context. This means you\textquotesingle{}ll have to re-\/apply configuration if necessary, and make options global manually using the \href{#global}{\tt global} method.

Additionally, the \href{#help}{\tt {\ttfamily help}} and \href{#version}{\tt {\ttfamily version}} options (if used) {\bfseries always} apply globally, just like the \href{#wrap}{\tt {\ttfamily .wrap()}} configuration.

{\ttfamily builder} can also be a function. This function is executed with a {\ttfamily yargs} instance, and can be used to provide {\itshape advanced} command specific help\+:


\begin{DoxyCode}
yargs
  .command('get', 'make a get HTTP request', function (yargs) \{
    return yargs.option('url', \{
      alias: 'u',
      default: 'http://yargs.js.org/'
    \})
  \})
  .help()
  .argv
\end{DoxyCode}


You can also provide a handler function, which will be executed with the parsed {\ttfamily argv} object\+:


\begin{DoxyCode}
yargs
  .command(
    'get',
    'make a get HTTP request',
    function (yargs) \{
      return yargs.option('u', \{
        alias: 'url',
        describe: 'the URL to make an HTTP request to'
      \})
    \},
    function (argv) \{
      console.log(argv.url)
    \}
  )
  .help()
  .argv
\end{DoxyCode}


\subsubsection*{Positional Arguments}

Commands can accept {\itshape optional} and {\itshape required} positional arguments. Required positional arguments take the form {\ttfamily $<$foo$>$}, and optional arguments take the form {\ttfamily \mbox{[}bar\mbox{]}}. The parsed positional arguments will be populated in {\ttfamily argv}\+:


\begin{DoxyCode}
yargs.command('get <source> [proxy]', 'make a get HTTP request')
  .help()
  .argv
\end{DoxyCode}


\paragraph*{Positional Argument Aliases}

Aliases can be provided for positional arguments using the {\ttfamily $\vert$} character. As an example, suppose our application allows either a username {\itshape or} an email as the first argument\+:


\begin{DoxyCode}
yargs.command('get <username|email> [password]', 'fetch a user by username or email.')
  .help()
  .argv
\end{DoxyCode}


In this way, both {\ttfamily argv.\+username} and {\ttfamily argv.\+email} would be populated with the same value when the command is executed.

\paragraph*{Variadic Positional Arguments}

The last positional argument can optionally accept an array of values, by using the {\ttfamily ..} operator\+:


\begin{DoxyCode}
yargs.command('download <url> [files..]', 'download several files')
  .help()
  .argv
\end{DoxyCode}


\subsubsection*{Command Execution}

When a command is given on the command line, yargs will execute the following\+:


\begin{DoxyEnumerate}
\item push the command into the current context
\item reset non-\/global configuration
\item apply command configuration via the {\ttfamily builder}, if given
\item parse and validate args from the command line, including positional args
\item if validation succeeds, run the {\ttfamily handler} function, if given
\item pop the command from the current context
\end{DoxyEnumerate}

\subsubsection*{Command Aliases}

You can define aliases for a command by putting the command and all of its aliases into an array.

Alternatively, a command module may specify an {\ttfamily aliases} property, which may be a string or an array of strings. All aliases defined via the {\ttfamily command} property and the {\ttfamily aliases} property will be concatenated together.

The first element in the array is considered the canonical command, which may define positional arguments, and the remaining elements in the array are considered aliases. Aliases inherit positional args from the canonical command, and thus any positional args defined in the aliases themselves are ignored.

If either the canonical command or any of its aliases are given on the command line, the command will be executed.


\begin{DoxyCode}
#!/usr/bin/env node
require('yargs')
  .command(['start [app]', 'run', 'up'], 'Start up an app', \{\}, (argv) => \{
    console.log('starting up the', argv.app || 'default', 'app')
  \})
  .command(\{
    command: 'configure <key> [value]',
    aliases: ['config', 'cfg'],
    desc: 'Set a config variable',
    builder: (yargs) => yargs.default('value', 'true'),
    handler: (argv) => \{
      console.log(`setting $\{argv.key\} to $\{argv.value\}`)
    \}
  \})
  .demandCommand(1)
  .help()
  .wrap(72)
  .argv
\end{DoxyCode}



\begin{DoxyCode}
$ ./svc.js help
Commands:
  start [app]              Start up an app            [aliases: run, up]
  configure <key> [value]  Set a config variable  [aliases: config, cfg]

Options:
  --help  Show help                                            [boolean]

$ ./svc.js cfg concurrency 4
setting concurrency to 4

$ ./svc.js run web
starting up the web app
\end{DoxyCode}


\subsubsection*{Providing a Command Module}

For complicated commands you can pull the logic into a module. A module simply needs to export\+:


\begin{DoxyItemize}
\item {\ttfamily exports.\+command}\+: string (or array of strings) that executes this command when given on the command line, first string may contain positional args
\item {\ttfamily exports.\+aliases}\+: array of strings (or a single string) representing aliases of {\ttfamily exports.\+command}, positional args defined in an alias are ignored
\item {\ttfamily exports.\+describe}\+: string used as the description for the command in help text, use {\ttfamily false} for a hidden command
\item {\ttfamily exports.\+builder}\+: object declaring the options the command accepts, or a function accepting and returning a yargs instance
\item {\ttfamily exports.\+handler}\+: a function which will be passed the parsed argv.
\end{DoxyItemize}


\begin{DoxyCode}
// my-module.js
exports.command = 'get <source> [proxy]'

exports.describe = 'make a get HTTP request'

exports.builder = \{
  banana: \{
    default: 'cool'
  \},
  batman: \{
    default: 'sad'
  \}
\}

exports.handler = function (argv) \{
  // do something with argv.
\}
\end{DoxyCode}


You then register the module like so\+:


\begin{DoxyCode}
yargs.command(require('my-module'))
  .help()
  .argv
\end{DoxyCode}


Or if the module does not export {\ttfamily command} and {\ttfamily describe} (or if you just want to override them)\+:


\begin{DoxyCode}
yargs.command('get <source> [proxy]', 'make a get HTTP request', require('my-module'))
  .help()
  .argv
\end{DoxyCode}


\subsection*{.command\+Dir(directory, \mbox{[}opts\mbox{]}) }

Apply command modules from a directory relative to the module calling this method.

This allows you to organize multiple commands into their own modules under a single directory and apply all of them at once instead of calling `.command(require('./dir/module\textquotesingle{}))\`{} multiple times.

By default, it ignores subdirectories. This is so you can use a directory structure to represent your command hierarchy, where each command applies its subcommands using this method in its builder function. See the example below.

Note that yargs assumes all modules in the given directory are command modules and will error if non-\/command modules are encountered. In this scenario, you can either move your module to a different directory or use the {\ttfamily exclude} or {\ttfamily visit} option to manually filter it out. More on that below.

{\ttfamily directory} is a relative directory path as a string (required).

{\ttfamily opts} is an options object (optional). The following options are valid\+:


\begin{DoxyItemize}
\item {\ttfamily recurse}\+: boolean, default {\ttfamily false}

Look for command modules in all subdirectories and apply them as a flattened (non-\/hierarchical) list.
\item {\ttfamily extensions}\+: array of strings, default `\mbox{[}\textquotesingle{}js'\mbox{]}\`{}

The types of files to look for when requiring command modules.
\item {\ttfamily visit}\+: function

A synchronous function called for each command module encountered. Accepts {\ttfamily command\+Object}, {\ttfamily path\+To\+File}, and {\ttfamily filename} as arguments. Returns {\ttfamily command\+Object} to include the command; any falsy value to exclude/skip it.
\item {\ttfamily include}\+: Reg\+Exp or function

Whitelist certain modules. See \href{https://www.npmjs.com/package/require-directory#whitelisting}{\tt {\ttfamily require-\/directory} whitelisting} for details.
\item {\ttfamily exclude}\+: Reg\+Exp or function

Blacklist certain modules. See \href{https://www.npmjs.com/package/require-directory#blacklisting}{\tt {\ttfamily require-\/directory} blacklisting} for details.
\end{DoxyItemize}

\subsubsection*{Example command hierarchy using {\ttfamily .command\+Dir()}}

Desired C\+LI\+:


\begin{DoxyCode}
$ myapp --help
$ myapp init
$ myapp remote --help
$ myapp remote add base http://yargs.js.org
$ myapp remote prune base
$ myapp remote prune base fork whatever
\end{DoxyCode}


Directory structure\+:


\begin{DoxyCode}
myapp/
├─ cli.js
└─ cmds/
   ├─ init.js
   ├─ remote.js
   └─ remote\_cmds/
      ├─ add.js
      └─ prune.js
\end{DoxyCode}


cli.\+js\+:


\begin{DoxyCode}
#!/usr/bin/env node
require('yargs')
  .commandDir('cmds')
  .demandCommand(1)
  .help()
  .argv
\end{DoxyCode}


cmds/init.\+js\+:


\begin{DoxyCode}
exports.command = 'init [dir]'
exports.desc = 'Create an empty repo'
exports.builder = \{
  dir: \{
    default: '.'
  \}
\}
exports.handler = function (argv) \{
  console.log('init called for dir', argv.dir)
\}
\end{DoxyCode}


cmds/remote.\+js\+:


\begin{DoxyCode}
exports.command = 'remote <command>'
exports.desc = 'Manage set of tracked repos'
exports.builder = function (yargs) \{
  return yargs.commandDir('remote\_cmds')
\}
exports.handler = function (argv) \{\}
\end{DoxyCode}


cmds/remote\+\_\+cmds/add.\+js\+:


\begin{DoxyCode}
exports.command = 'add <name> <url>'
exports.desc = 'Add remote named <name> for repo at url <url>'
exports.builder = \{\}
exports.handler = function (argv) \{
  console.log('adding remote %s at url %s', argv.name, argv.url)
\}
\end{DoxyCode}


cmds/remote\+\_\+cmds/prune.\+js\+:


\begin{DoxyCode}
exports.command = 'prune <name> [names..]'
exports.desc = 'Delete tracked branches gone stale for remotes'
exports.builder = \{\}
exports.handler = function (argv) \{
  console.log('pruning remotes %s', [].concat(argv.name).concat(argv.names).join(', '))
\}
\end{DoxyCode}


\subsection*{.completion(\mbox{[}cmd\mbox{]}, \mbox{[}description\mbox{]}, \mbox{[}fn\mbox{]}) }

Enable bash-\/completion shortcuts for commands and options.

{\ttfamily cmd}\+: When present in {\ttfamily argv.\+\_\+}, will result in the {\ttfamily .bashrc} completion script being outputted. To enable bash completions, concat the generated script to your {\ttfamily .bashrc} or {\ttfamily .bash\+\_\+profile}.

{\ttfamily description}\+: Provide a description in your usage instructions for the command that generates bash completion scripts.

{\ttfamily fn}\+: Rather than relying on yargs\textquotesingle{} default completion functionality, which shiver me timbers is pretty awesome, you can provide your own completion method.

If invoked without parameters, {\ttfamily .completion()} will make {\ttfamily completion} the command to output the completion script.


\begin{DoxyCode}
var argv = require('yargs')
  .completion('completion', function(current, argv) \{
    // 'current' is the current command being completed.
    // 'argv' is the parsed arguments so far.
    // simply return an array of completions.
    return [
      'foo',
      'bar'
    ];
  \})
  .argv;
\end{DoxyCode}


You can also provide asynchronous completions.


\begin{DoxyCode}
var argv = require('yargs')
  .completion('completion', function(current, argv, done) \{
    setTimeout(function() \{
      done([
        'apple',
        'banana'
      ]);
    \}, 500);
  \})
  .argv;
\end{DoxyCode}


But wait, there\textquotesingle{}s more! You can return an asynchronous promise.


\begin{DoxyCode}
var argv = require('yargs')
  .completion('completion', function(current, argv, done) \{
    return new Promise(function (resolve, reject) \{
      setTimeout(function () \{
        resolve(['apple', 'banana'])
      \}, 10)
    \})
  \})
  .argv;
\end{DoxyCode}


\subsection*{\label{_config}%
.config(\mbox{[}key\mbox{]}, \mbox{[}description\mbox{]}, \mbox{[}parse\+Fn\mbox{]}) }

\subsection*{.config(object) }

Tells the parser that if the option specified by {\ttfamily key} is passed in, it should be interpreted as a path to a J\+S\+ON config file. The file is loaded and parsed, and its properties are set as arguments. Because the file is loaded using Node\textquotesingle{}s require(), the filename M\+U\+ST end in {\ttfamily .json} to be interpreted correctly.

If invoked without parameters, {\ttfamily .config()} will make {\ttfamily -\/-\/config} the option to pass the J\+S\+ON config file.

An optional {\ttfamily description} can be provided to customize the config ({\ttfamily key}) option in the usage string.

An optional {\ttfamily parse\+Fn} can be used to provide a custom parser. The parsing function must be synchronous, and should return an object containing key value pairs or an error.


\begin{DoxyCode}
var argv = require('yargs')
  .config('settings', function (configPath) \{
    return JSON.parse(fs.readFileSync(configPath, 'utf-8'))
  \})
  .argv
\end{DoxyCode}


You can also pass an explicit configuration {\ttfamily object}, it will be parsed and its properties will be set as arguments.


\begin{DoxyCode}
var argv = require('yargs')
  .config(\{foo: 1, bar: 2\})
  .argv
console.log(argv)
\end{DoxyCode}



\begin{DoxyCode}
$ node test.js
\{ \_: [],
  foo: 1,
  bar: 2,
  '$0': 'test.js' \}
\end{DoxyCode}


\subsection*{\label{_conflicts}%
.conflicts(x, y) }

Given the key {\ttfamily x} is set, the key {\ttfamily y} must not be set.

Optionally {\ttfamily .conflicts()} can accept an object specifying multiple conflicting keys.

\subsection*{\label{_count}%
.count(key) }

Interpret {\ttfamily key} as a boolean flag, but set its parsed value to the number of flag occurrences rather than {\ttfamily true} or {\ttfamily false}. Default value is thus {\ttfamily 0}.

\subsection*{\label{_default}%
.default(key, value, \mbox{[}description\mbox{]}) }

\subsection*{.defaults(key, value, \mbox{[}description\mbox{]}) }

{\bfseries Note\+:} The {\ttfamily .defaults()} alias is deprecated. It will be removed in the next major version.

Set {\ttfamily argv\mbox{[}key\mbox{]}} to {\ttfamily value} if no option was specified in {\ttfamily process.\+argv}.

Optionally {\ttfamily .default()} can take an object that maps keys to default values.

But wait, there\textquotesingle{}s more! The default value can be a {\ttfamily function} which returns a value. The name of the function will be used in the usage string\+:


\begin{DoxyCode}
var argv = require('yargs')
  .default('random', function randomValue() \{
    return Math.random() * 256;
  \}).argv;
\end{DoxyCode}


Optionally, {\ttfamily description} can also be provided and will take precedence over displaying the value in the usage instructions\+:


\begin{DoxyCode}
.default('timeout', 60000, '(one-minute)')
\end{DoxyCode}


\subsection*{\label{_demand}%
.demand(count, \mbox{[}max\mbox{]}, \mbox{[}msg\mbox{]}) \mbox{[}D\+E\+P\+R\+E\+C\+A\+T\+ED\mbox{]} }

{\ttfamily demand()} has been deprecated, please instead see \href{#demandOption}{\tt {\ttfamily demand\+Option()}} and \href{#demandCommand}{\tt {\ttfamily demand\+Command()}}.

\subsection*{\label{_demandOption}%
.demand\+Option(key, \mbox{[}msg $\vert$ boolean\mbox{]}) }

\subsection*{.demand\+Option(key, msg) }

If {\ttfamily key} is a string, show the usage information and exit if {\ttfamily key} wasn\textquotesingle{}t specified in {\ttfamily process.\+argv}.

If {\ttfamily key} is an array, demand each element.

If a {\ttfamily msg} string is given, it will be printed when the argument is missing, instead of the standard error message.


\begin{DoxyCode}
// demand an array of keys to be provided
require('yargs')
  .option('run', \{
    alias: 'r',
    describe: 'run your program'
  \})
  .option('path', \{
    alias: 'p',
    describe: 'provide a path to file'
  \})
  .option('spec', \{
    alias: 's',
    describe: 'program specifications'
  \})
  .demandOption(['run', 'path'], 'Please provide both run and path arguments to work with this tool')
  .help()
  .argv
\end{DoxyCode}
 which will provide the following output\+: 
\begin{DoxyCode}
Options:
  --run, -r   run your program                [required]
  --path, -p  provide a path to file          [required]
  --spec, -s  program specifications
  --help      Show help                        [boolean]

  Missing required arguments: run, path
  Please provide both run and path arguments to work with this tool
\end{DoxyCode}


If a {\ttfamily boolean} value is given, it controls whether the option is demanded; this is useful when using {\ttfamily .options()} to specify command line parameters.


\begin{DoxyCode}
// demand individual options within the option constructor
require('yargs')
  .options(\{
    'run': \{
      alias: 'r',
      describe: 'run your program',
      demand: true
    \},
    'path': \{
      alias: 'p',
      describe: 'provide a path to file',
      demand: true
    \},
    'spec': \{
      alias: 's',
      describe: 'program specifications'
    \}
  \})
  .help()
  .argv
\end{DoxyCode}
 which will provide the following output\+: 
\begin{DoxyCode}
Options:
  --run, -r   run your program                                       [required]
  --path, -p  provide a path to file                                 [required]
  --spec, -s  program specifications
  --help      Show help                                               [boolean]

Missing required arguments: run, path
\end{DoxyCode}


\subsection*{\label{_demandCommand}%
.demand\+Command(min, \mbox{[}min\+Msg\mbox{]}) }

\subsection*{.demand\+Command(min, \mbox{[}max\mbox{]}, \mbox{[}min\+Msg\mbox{]}, \mbox{[}max\+Msg\mbox{]}) }

Demand in context of commands. You can demand a minimum and a maximum number a user can have within your program, as well as provide corresponding error messages if either of the demands is not met. 
\begin{DoxyCode}
require('yargs')
  .command(\{
    command: 'configure <key> [value]',
    aliases: ['config', 'cfg'],
    desc: 'Set a config variable',
    builder: (yargs) => yargs.default('value', 'true'),
    handler: (argv) => \{
      console.log(`setting $\{argv.key\} to $\{argv.value\}`)
    \}
  \})
  // provide a minimum demand and a minimum demand message
  .demandCommand(1, 'You need at least one command before moving on')
  .help()
  .argv
\end{DoxyCode}
 which will provide the following output\+: 
\begin{DoxyCode}
Commands:
  configure <key> [value]  Set a config variable         [aliases: config, cfg]

Options:
  --help  Show help                                                   [boolean]

You need at least one command before moving on
\end{DoxyCode}


{\itshape Note\+: in {\ttfamily min\+Msg} and {\ttfamily max\+Msg}, every occurrence of {\ttfamily \$0} will be replaced with the observed value, and every instance of {\ttfamily \$1} will be replaced with the expected value.}

\subsection*{\label{_describe}%
.describe(key, desc) }

Describe a {\ttfamily key} for the generated usage information.

Optionally {\ttfamily .describe()} can take an object that maps keys to descriptions.

\subsection*{.detect\+Locale(boolean) }

Should yargs attempt to detect the os\textquotesingle{} locale? Defaults to {\ttfamily true}.

\subsection*{.env(\mbox{[}prefix\mbox{]}) }

Tell yargs to parse environment variables matching the given prefix and apply them to argv as though they were command line arguments.

Use the \char`\"{}\+\_\+\+\_\+\char`\"{} separator in the environment variable to indicate nested options. (e.\+g. prefix\+\_\+nested\+\_\+\+\_\+foo =$>$ nested.\+foo)

If this method is called with no argument or with an empty string or with {\ttfamily true}, then all env vars will be applied to argv.

Program arguments are defined in this order of precedence\+:


\begin{DoxyEnumerate}
\item Command line args
\item Config file
\item Env var
\item Configured defaults
\end{DoxyEnumerate}


\begin{DoxyCode}
var argv = require('yargs')
  .env('MY\_PROGRAM')
  .option('f', \{
    alias: 'fruit-thing',
    default: 'apple'
  \})
  .argv
console.log(argv)
\end{DoxyCode}



\begin{DoxyCode}
$ node fruity.js
\{ \_: [],
  f: 'apple',
  'fruit-thing': 'apple',
  fruitThing: 'apple',
  '$0': 'fruity.js' \}
\end{DoxyCode}



\begin{DoxyCode}
$ MY\_PROGRAM\_FRUIT\_THING=banana node fruity.js
\{ \_: [],
  fruitThing: 'banana',
  f: 'banana',
  'fruit-thing': 'banana',
  '$0': 'fruity.js' \}
\end{DoxyCode}



\begin{DoxyCode}
$ MY\_PROGRAM\_FRUIT\_THING=banana node fruity.js -f cat
\{ \_: [],
  f: 'cat',
  'fruit-thing': 'cat',
  fruitThing: 'cat',
  '$0': 'fruity.js' \}
\end{DoxyCode}


Env var parsing is disabled by default, but you can also explicitly disable it by calling {\ttfamily .env(false)}, e.\+g. if you need to undo previous configuration.

\subsection*{.epilog(str) }

\subsection*{.epilogue(str) }

A message to print at the end of the usage instructions, e.\+g.


\begin{DoxyCode}
var argv = require('yargs')
  .epilogue('for more information, find our manual at http://example.com');
\end{DoxyCode}


\subsection*{.example(cmd, desc) }

Give some example invocations of your program. Inside {\ttfamily cmd}, the string {\ttfamily \$0} will get interpolated to the current script name or node command for the present script similar to how {\ttfamily \$0} works in bash or perl. Examples will be printed out as part of the help message.

\subsection*{\label{_exitprocess}%
.exit\+Process(enable) }

By default, yargs exits the process when the user passes a help flag, uses the {\ttfamily .version} functionality, or when validation fails. Calling {\ttfamily .exit\+Process(false)} disables this behavior, enabling further actions after yargs have been validated.

\subsection*{\label{_fail}%
.fail(fn) }

Method to execute when a failure occurs, rather than printing the failure message.

{\ttfamily fn} is called with the failure message that would have been printed, the {\ttfamily Error} instance originally thrown and yargs state when the failure occured.


\begin{DoxyCode}
var argv = require('yargs')
  .fail(function (msg, err, yargs) \{
    if (err) throw err // preserve stack
    console.error('You broke it!')
    console.error(msg)
    console.error('You should be doing', yargs.help())
    process.exit(1)
  \})
  .argv
\end{DoxyCode}


\subsection*{.get\+Completion(args, done); }

Allows to programmatically get completion choices for any line.

{\ttfamily args}\+: An array of the words in the command line to complete.

{\ttfamily done}\+: The callback to be called with the resulting completions.

For example\+:


\begin{DoxyCode}
require('yargs')
  .option('foobar')
  .option('foobaz')
  .completion()
  .getCompletion(['./test.js', '--foo'], function (completions) \{
    console.log(completions)
  \})
\end{DoxyCode}


Outputs the same completion choices as {\ttfamily ./test.js -\/-\/foo}{\ttfamily T\+AB}\+: {\ttfamily -\/-\/foobar} and {\ttfamily -\/-\/foobaz}

\subsection*{\label{_global}%
.global(globals) }

Indicate that an option (or group of options) should not be reset when a command is executed, as an example\+:


\begin{DoxyCode}
var argv = require('yargs')
  .option('a', \{
    alias: 'all',
    default: true
  \})
  .option('n', \{
    alias: 'none',
    default: true
  \})
  .command('foo', 'foo command', function (yargs) \{
    return yargs.option('b', \{
      alias: 'bar'
    \})
  \})
  .help('help')
  .global('a')
  .argv
\end{DoxyCode}


If the {\ttfamily foo} command is executed the {\ttfamily all} option will remain, but the {\ttfamily none} option will have been eliminated.

{\ttfamily help}, {\ttfamily version}, and {\ttfamily completion} options default to being global.

\subsection*{\label{_group}%
.group(key(s), group\+Name) }

Given a key, or an array of keys, places options under an alternative heading when displaying usage instructions, e.\+g.,


\begin{DoxyCode}
var yargs = require('yargs')(['--help'])
  .help()
  .group('batman', 'Heroes:')
  .describe('batman', "world's greatest detective")
  .wrap(null)
  .argv
\end{DoxyCode}
 

 Heroes\+: --batman world\textquotesingle{}s greatest detective

Options\+: --help Show help \mbox{[}boolean\mbox{]}

\subsection*{\label{_help}%
.help() }

\subsection*{.help(\mbox{[}option $\vert$ boolean\mbox{]}) }

\subsection*{.help(\mbox{[}option, \mbox{[}description $\vert$ boolean\mbox{]}\mbox{]}) }

\subsection*{.help(\mbox{[}option, \mbox{[}description, \mbox{[}boolean\mbox{]}\mbox{]}\mbox{]}) }

Add an option (e.\+g. {\ttfamily -\/-\/help}) and implicit command that displays the usage string and exits the process.

If present, the {\ttfamily description} parameter customizes the description of the help option in the usage string.

If a boolean argument is provided, it will enable or disable the use of an implicit command. The implicit command is enabled by default, but it can be disabled by passing {\ttfamily false}.

Note that any multi-\/char aliases (e.\+g. {\ttfamily help}) used for the help option will also be used for the implicit command. If there are no multi-\/char aliases (e.\+g. {\ttfamily h}), then all single-\/char aliases will be used for the command.

If invoked without parameters, {\ttfamily .help()} will use {\ttfamily -\/-\/help} as the option and {\ttfamily help} as the implicit command to trigger help output.

Example\+:


\begin{DoxyCode}
var yargs = require("yargs")(['--help'])
  .usage("$0 -operand1 number -operand2 number -operation [add|subtract]")
  .help()
  .argv
\end{DoxyCode}


Later on, {\ttfamily argv} can be retrieved with {\ttfamily yargs.\+argv}.

\subsection*{.implies(x, y) }

Given the key {\ttfamily x} is set, it is required that the key {\ttfamily y} is set.

Optionally {\ttfamily .implies()} can accept an object specifying multiple implications.

\subsection*{.locale() }

Return the locale that yargs is currently using.

By default, yargs will auto-\/detect the operating system\textquotesingle{}s locale so that yargs-\/generated help content will display in the user\textquotesingle{}s language.

To override this behavior with a static locale, pass the desired locale as a string to this method (see below).

\subsection*{.locale(locale) }

Override the auto-\/detected locale from the user\textquotesingle{}s operating system with a static locale. Note that the OS locale can be modified by setting/exporting the {\ttfamily L\+C\+\_\+\+A\+LL} environment variable.


\begin{DoxyCode}
var argv = require('yargs')
  .usage('./$0 - follow ye instructions true')
  .option('option', \{
    alias: 'o',
    describe: "'tis a mighty fine option",
    demand: true
  \})
  .command('run', "Arrr, ya best be knowin' what yer doin'")
  .example('$0 run foo', "shiver me timbers, here's an example for ye")
  .help('help')
  .wrap(70)
  .locale('pirate')
  .argv
\end{DoxyCode}







\begin{DoxyCode}
./test.js - follow ye instructions true

Choose yer command:
  run  Arrr, ya best be knowin' what yer doin'

Options for me hearties!
  --option, -o  'tis a mighty fine option               [requi-yar-ed]
  --help        Parlay this here code of conduct             [boolean]

Ex. marks the spot:
  test.js run foo  shiver me timbers, here's an example for ye

Ye be havin' to set the followin' argument land lubber: option
\end{DoxyCode}


Locales currently supported\+:


\begin{DoxyItemize}
\item {\bfseries de\+:} German.
\item {\bfseries en\+:} American English.
\item {\bfseries es\+:} Spanish.
\item {\bfseries fr\+:} French.
\item {\bfseries hi\+:} Hindi.
\item {\bfseries hu\+:} Hungarian.
\item {\bfseries id\+:} Indonesian.
\item {\bfseries it\+:} Italian.
\item {\bfseries ja\+:} Japanese.
\item {\bfseries ko\+:} Korean.
\item {\bfseries nb\+:} Norwegian Bokmål.
\item {\bfseries pirate\+:} American Pirate.
\item {\bfseries pl\+:} Polish.
\item {\bfseries pt\+:} Portuguese.
\item {\bfseries pt\+\_\+\+BR\+:} Brazilian Portuguese.
\item {\bfseries ru\+:} Russian.
\item {\bfseries th\+:} Thai.
\item {\bfseries tr\+:} Turkish.
\item {\bfseries zh\+\_\+\+CN\+:} Chinese.
\end{DoxyItemize}

To submit a new translation for yargs\+:


\begin{DoxyEnumerate}
\item use {\ttfamily ./locales/en.json} as a starting point.
\item submit a pull request with the new locale file.
\end{DoxyEnumerate}

{\itshape The \href{http://www.microsoft.com/Language/en-US/Search.aspx}{\tt Microsoft Terminology Search} can be useful for finding the correct terminology in your locale.}

\subsection*{\label{_nargs}%
.nargs(key, count) }

The number of arguments that should be consumed after a key. This can be a useful hint to prevent parsing ambiguity. For example\+:


\begin{DoxyCode}
var argv = require('yargs')
  .nargs('token', 1)
  .parse(['--token', '-my-token']);
\end{DoxyCode}


parses as\+:

`\{ \+\_\+\+: \mbox{[}\mbox{]}, token\+: '-\/my-\/token\textquotesingle{}, \textquotesingle{}\$0\textquotesingle{}\+: \textquotesingle{}node test\textquotesingle{} \}\`{}

Optionally {\ttfamily .nargs()} can take an object of {\ttfamily key}/{\ttfamily narg} pairs.

\subsection*{\label{_normalize}%
.normalize(key) }

The key provided represents a path and should have {\ttfamily path.\+normalize()} applied.

\subsection*{\label{_number}%
.number(key) }

Tell the parser to always interpret {\ttfamily key} as a number.

If {\ttfamily key} is an array, all elements will be parsed as numbers.

If the option is given on the command line without a value, {\ttfamily argv} will be populated with {\ttfamily undefined}.

If the value given on the command line cannot be parsed as a number, {\ttfamily argv} will be populated with {\ttfamily NaN}.

Note that decimals, hexadecimals, and scientific notation are all accepted.


\begin{DoxyCode}
var argv = require('yargs')
  .number('n')
  .number(['width', 'height'])
  .argv
\end{DoxyCode}


\subsection*{.option(key, \mbox{[}opt\mbox{]}) }

\subsection*{.options(key, \mbox{[}opt\mbox{]}) }

This method can be used to make yargs aware of options that {\itshape could} exist. You can also pass an {\ttfamily opt} object which can hold further customization, like {\ttfamily .alias()}, {\ttfamily .demand\+Option()} etc. for that option.

For example\+:


\begin{DoxyCode}
var argv = require('yargs')
    .option('f', \{
        alias: 'file',
        demand: true,
        default: '/etc/passwd',
        describe: 'x marks the spot',
        type: 'string'
    \})
    .argv
;
\end{DoxyCode}


is the same as


\begin{DoxyCode}
var argv = require('yargs')
    .alias('f', 'file')
    .demandOption('f')
    .default('f', '/etc/passwd')
    .describe('f', 'x marks the spot')
    .string('f')
    .argv
;
\end{DoxyCode}


Optionally {\ttfamily .options()} can take an object that maps keys to {\ttfamily opt} parameters.


\begin{DoxyCode}
var argv = require('yargs')
    .options(\{
      'f': \{
        alias: 'file',
        demand: true,
        default: '/etc/passwd',
        describe: 'x marks the spot',
        type: 'string'
      \}
    \})
    .argv
;
\end{DoxyCode}


Valid {\ttfamily opt} keys include\+:


\begin{DoxyItemize}
\item {\ttfamily alias}\+: string or array of strings, alias(es) for the canonical option key, see \href{#alias}{\tt {\ttfamily alias()}}
\item {\ttfamily array}\+: boolean, interpret option as an array, see \href{#array}{\tt {\ttfamily array()}}
\item {\ttfamily boolean}\+: boolean, interpret option as a boolean flag, see \href{#boolean}{\tt {\ttfamily boolean()}}
\item {\ttfamily choices}\+: value or array of values, limit valid option arguments to a predefined set, see \href{#choices}{\tt {\ttfamily choices()}}
\item {\ttfamily coerce}\+: function, coerce or transform parsed command line values into another value, see \href{#coerce}{\tt {\ttfamily coerce()}}
\item {\ttfamily config}\+: boolean, interpret option as a path to a J\+S\+ON config file, see \href{#config}{\tt {\ttfamily config()}}
\item {\ttfamily config\+Parser}\+: function, provide a custom config parsing function, see \href{#config}{\tt {\ttfamily config()}}
\item {\ttfamily count}\+: boolean, interpret option as a count of boolean flags, see \href{#count}{\tt {\ttfamily count()}}
\item {\ttfamily default}\+: value, set a default value for the option, see \href{#default}{\tt {\ttfamily default()}}
\item {\ttfamily default\+Description}\+: string, use this description for the default value in help content, see \href{#default}{\tt {\ttfamily default()}}
\item {\ttfamily demand\+Option}\+: boolean or string, demand the option be given, with optional error message, see \href{#demandOption}{\tt {\ttfamily demand\+Option()}}
\item {\ttfamily desc}/{\ttfamily describe}/{\ttfamily description}\+: string, the option description for help content, see \href{#describe}{\tt {\ttfamily describe()}}
\item {\ttfamily global}\+: boolean, indicate that this key should not be \href{#reset}{\tt reset} when a command is invoked, see \href{#global}{\tt {\ttfamily global()}}
\item {\ttfamily group}\+: string, when displaying usage instructions place the option under an alternative group heading, see \href{#group}{\tt {\ttfamily group()}}
\item {\ttfamily nargs}\+: number, specify how many arguments should be consumed for the option, see \href{#nargs}{\tt {\ttfamily nargs()}}
\item {\ttfamily normalize}\+: boolean, apply {\ttfamily path.\+normalize()} to the option, see \href{#normalize}{\tt {\ttfamily normalize()}}
\item {\ttfamily number}\+: boolean, interpret option as a number, \href{#number}{\tt {\ttfamily number()}}
\item {\ttfamily requires\+Arg}\+: boolean, require the option be specified with a value, see \href{#requiresArg}{\tt {\ttfamily requires\+Arg()}}
\item {\ttfamily skip\+Validation}\+: boolean, skips validation if the option is present, see \href{#skipValidation}{\tt {\ttfamily skip\+Validation()}}
\item {\ttfamily string}\+: boolean, interpret option as a string, see \href{#string}{\tt {\ttfamily string()}}
\item {\ttfamily type}\+: one of the following strings
\begin{DoxyItemize}
\item `\textquotesingle{}array'{\ttfamily \+: synonymous for}array\+: true{\ttfamily , see \mbox{[}}array(){\ttfamily \mbox{]}(\#array) -\/}\textquotesingle{}boolean\textquotesingle{}{\ttfamily \+: synonymous for}boolean\+: true{\ttfamily , see \mbox{[}}boolean(){\ttfamily \mbox{]}(\#boolean) -\/}\textquotesingle{}count\textquotesingle{}{\ttfamily \+: synonymous for}count\+: true{\ttfamily , see \mbox{[}}count(){\ttfamily \mbox{]}(\#count) -\/}\textquotesingle{}number\textquotesingle{}{\ttfamily \+: synonymous for}number\+: true{\ttfamily , see \mbox{[}}number(){\ttfamily \mbox{]}(\#number) -\/}\textquotesingle{}string\textquotesingle{}{\ttfamily \+: synonymous for}string\+: true{\ttfamily , see \mbox{[}}string()\`{}\mbox{]}(\#string)
\end{DoxyItemize}
\end{DoxyItemize}

\subsection*{.parse(args, \mbox{[}context\mbox{]}, \mbox{[}parse\+Callback\mbox{]}) }

Parse {\ttfamily args} instead of {\ttfamily process.\+argv}. Returns the {\ttfamily argv} object. {\ttfamily args} may either be a pre-\/processed argv array, or a raw argument string.

A {\ttfamily context} object can optionally be given as the second argument to {\ttfamily parse()}, providing a useful mechanism for passing state information to commands\+:


\begin{DoxyCode}
const parser = yargs
  .command('lunch-train <restaurant>', 'start lunch train', function () \{\}, function (argv) \{
    console.log(argv.restaurant, argv.time)
  \})
  .parse("lunch-train rudy's", \{time: '12:15'\})
\end{DoxyCode}


A {\ttfamily parse\+Callback} can also be provided to {\ttfamily .parse()}. If a callback is given, it will be invoked with three arguments\+:


\begin{DoxyEnumerate}
\item {\ttfamily err}\+: populated if any validation errors raised while parsing.
\item {\ttfamily argv}\+: the parsed argv object.
\item {\ttfamily output}\+: any text that would have been output to the terminal, had a callback not been provided.
\end{DoxyEnumerate}


\begin{DoxyCode}
// providing the `fn` argument to `parse()` runs yargs in headless mode, this
// makes it easy to use yargs in contexts other than the CLI, e.g., writing
// a chat-bot.
const parser = yargs
  .command('lunch-train <restaurant> <time>', 'start lunch train', function () \{\}, function (argv) \{
    api.scheduleLunch(argv.restaurant, moment(argv.time))
  \})
  .help()

parser.parse(bot.userText, function (err, argv, output) \{
  if (output) bot.respond(output)
\})
\end{DoxyCode}


{\itshape {\bfseries Note\+:}} Providing a callback to {\ttfamily parse()} disables the \href{#exitprocess}{\tt {\ttfamily exit\+Process} setting} until after the callback is invoked.

\subsection*{.pkg\+Conf(key, \mbox{[}cwd\mbox{]}) }

Similar to \href{#config}{\tt {\ttfamily config()}}, indicates that yargs should interpret the object from the specified key in package.\+json as a configuration object.

{\ttfamily cwd} can optionally be provided, the package.\+json will be read from this location.

\subsection*{.recommend\+Commands() }

Should yargs provide suggestions regarding similar commands if no matching command is found?

\subsection*{.require(key, \mbox{[}msg $\vert$ boolean\mbox{]}) }

\subsection*{.required(key, \mbox{[}msg $\vert$ boolean\mbox{]}) }

An alias for \href{#demand}{\tt {\ttfamily demand()}}. See docs there.

\subsection*{\label{_requiresArg}%
.requires\+Arg(key) }

Specifies either a single option key (string), or an array of options that must be followed by option values. If any option value is missing, show the usage information and exit.

The default behavior is to set the value of any key not followed by an option value to {\ttfamily true}.

\subsection*{\label{_reset}%
.reset() }

Reset the argument object built up so far. This is useful for creating nested command line interfaces. Use \href{#global}{\tt global} to specify keys that should not be reset.


\begin{DoxyCode}
var yargs = require('yargs')
  .usage('$0 command')
  .command('hello', 'hello command')
  .command('world', 'world command')
  .demandCommand(1, 'must provide a valid command'),
  argv = yargs.argv,
  command = argv.\_[0];

if (command === 'hello') \{
  yargs.reset()
    .usage('$0 hello')
    .help('h')
    .example('$0 hello', 'print the hello message!')
    .argv

  console.log('hello!');
\} else if (command === 'world')\{
  yargs.reset()
    .usage('$0 world')
    .help('h')
    .example('$0 world', 'print the world message!')
    .argv

  console.log('world!');
\} else \{
  yargs.showHelp();
\}
\end{DoxyCode}


\subsection*{.show\+Completion\+Script() }

Generate a bash completion script. Users of your application can install this script in their {\ttfamily .bashrc}, and yargs will provide completion shortcuts for commands and options.

\subsection*{.show\+Help(console\+Level=\textquotesingle{}error\textquotesingle{}) }

Print the usage data using the \href{https://nodejs.org/api/console.html}{\tt {\ttfamily console}} function {\ttfamily console\+Level} for printing.

Example\+:


\begin{DoxyCode}
var yargs = require("yargs")
  .usage("$0 -operand1 number -operand2 number -operation [add|subtract]");
yargs.showHelp(); //prints to stderr using console.error()
\end{DoxyCode}


Or, to print the usage data to {\ttfamily stdout} instead, you can specify the use of {\ttfamily console.\+log}\+:


\begin{DoxyCode}
yargs.showHelp("log"); //prints to stdout using console.log()
\end{DoxyCode}


Later on, {\ttfamily argv} can be retrieved with {\ttfamily yargs.\+argv}.

\subsection*{.show\+Help\+On\+Fail(enable, \mbox{[}message\mbox{]}) }

By default, yargs outputs a usage string if any error is detected. Use the {\ttfamily .show\+Help\+On\+Fail()} method to customize this behavior. If {\ttfamily enable} is {\ttfamily false}, the usage string is not output. If the {\ttfamily message} parameter is present, this message is output after the error message.

line\+\_\+count.\+js\+:


\begin{DoxyCode}
#!/usr/bin/env node
var argv = require('yargs')
    .usage('Count the lines in a file.\(\backslash\)nUsage: $0 -f <file>')
    .demandOption('f')
    .alias('f', 'file')
    .describe('f', 'Load a file')
    .string('f')
    .showHelpOnFail(false, 'Specify --help for available options')
    .help('help')
    .argv;

// etc.
\end{DoxyCode}







\begin{DoxyCode}
$ node line\_count.js
Missing argument value: f

Specify --help for available options
\end{DoxyCode}


\subsection*{\label{_skipValidation}%
.skip\+Validation(key) }

Specifies either a single option key (string), or an array of options. If any of the options is present, yargs validation is skipped.

\subsection*{.strict() }

Any command-\/line argument given that is not demanded, or does not have a corresponding description, will be reported as an error.

\subsection*{\label{_string}%
.string(key) }

Tell the parser logic not to interpret {\ttfamily key} as a number or boolean. This can be useful if you need to preserve leading zeros in an input.

If {\ttfamily key} is an array, interpret all the elements as strings.

`.string('\+\_\+\textquotesingle{})\`{} will result in non-\/hyphenated arguments being interpreted as strings, regardless of whether they resemble numbers.

\subsection*{.update\+Locale(obj) }

\subsection*{.update\+Strings(obj) }

Override the default strings used by yargs with the key/value pairs provided in {\ttfamily obj}\+:


\begin{DoxyCode}
var argv = require('yargs')
  .command('run', 'the run command')
  .help('help')
  .updateStrings(\{
    'Commands:': 'My Commands -->\(\backslash\)n'
  \})
  .wrap(null)
  .argv
\end{DoxyCode}







\begin{DoxyCode}
My Commands -->

  run  the run command

Options:
  --help  Show help  [boolean]
\end{DoxyCode}


If you explicitly specify a {\ttfamily locale()}, you should do so {\itshape before} calling {\ttfamily update\+Strings()}.

\subsection*{.usage(message, \mbox{[}opts\mbox{]}) }

Set a usage message to show which commands to use. Inside {\ttfamily message}, the string {\ttfamily \$0} will get interpolated to the current script name or node command for the present script similar to how {\ttfamily \$0} works in bash or perl.

{\ttfamily opts} is optional and acts like calling {\ttfamily .options(opts)}.

\subsection*{\label{_version}%
.version(\mbox{[}option\mbox{]}, \mbox{[}description\mbox{]}, \mbox{[}version\mbox{]}) }

Add an option (e.\+g. {\ttfamily -\/-\/version}) that displays the version number (given by the {\ttfamily version} parameter) and exits the process.

If no arguments are passed to {\ttfamily version} ({\ttfamily .\mbox{\hyperlink{namespacesetup_a2aa722b36a933088812b50ea79b97a5c}{version()}}}), yargs will parse the {\ttfamily package.\+json} of your module and use its {\ttfamily version} value. The default value of {\ttfamily option} is {\ttfamily -\/-\/version}.

You can provide a {\ttfamily function} for version, rather than a string. This is useful if you want to use a version stored in a location other than package.\+json\+:


\begin{DoxyCode}
var argv = require('yargs')
  .version(function() \{
    return require('../lib/version').version;
  \})
  .argv;
\end{DoxyCode}


\subsection*{\label{_wrap}%
.wrap(columns) }

Format usage output to wrap at {\ttfamily columns} many columns.

By default wrap will be set to {\ttfamily Math.\+min(80, window\+Width)}. Use {\ttfamily .wrap(null)} to specify no column limit (no right-\/align). Use {\ttfamily .wrap(yargs.\+terminal\+Width())} to maximize the width of yargs\textquotesingle{} usage instructions.

\section*{parsing tricks }

\subsection*{stop parsing }

Use {\ttfamily -\/-\/} to stop parsing flags and stuff the remainder into {\ttfamily argv.\+\_\+}. \begin{DoxyVerb}$ node examples/reflect.js -a 1 -b 2 -- -c 3 -d 4
{ _: [ '-c', '3', '-d', '4' ],
  a: 1,
  b: 2,
  '$0': 'examples/reflect.js' }
\end{DoxyVerb}


\subsection*{negate fields }

If you want to explicitly set a field to false instead of just leaving it undefined or to override a default you can do {\ttfamily -\/-\/no-\/key}. \begin{DoxyVerb}$ node examples/reflect.js -a --no-b
{ _: [], a: true, b: false, '$0': 'examples/reflect.js' }
\end{DoxyVerb}


\subsection*{numbers }

Every argument that looks like a number ({\ttfamily !is\+NaN(Number(arg))}) is converted to one. This way you can just {\ttfamily net.\+create\+Connection(argv.\+port)} and you can add numbers out of {\ttfamily argv} with {\ttfamily +} without having that mean concatenation, which is super frustrating.

\subsection*{duplicates }

If you specify a flag multiple times it will get turned into an array containing all the values in order. \begin{DoxyVerb}$ node examples/reflect.js -x 5 -x 8 -x 0
{ _: [], x: [ 5, 8, 0 ], '$0': 'examples/reflect.js' }
\end{DoxyVerb}


\subsection*{dot notation }

When you use dots ({\ttfamily .}s) in argument names, an implicit object path is assumed. This lets you organize arguments into nested objects. \begin{DoxyVerb}$ node examples/reflect.js --foo.bar.baz=33 --foo.quux=5
{ _: [],
  foo: { bar: { baz: 33 }, quux: 5 },
  '$0': 'examples/reflect.js' }
\end{DoxyVerb}


\subsection*{short numbers }

Short numeric {\ttfamily -\/n5} style arguments work too\+: \begin{DoxyVerb}$ node examples/reflect.js -n123 -m456
{ _: [], n: 123, m: 456, '$0': 'examples/reflect.js' }
\end{DoxyVerb}


\section*{installation }

With \href{https://github.com/npm/npm}{\tt npm}, just do\+: \begin{DoxyVerb}npm install yargs
\end{DoxyVerb}


or clone this project on github\+: \begin{DoxyVerb}git clone http://github.com/yargs/yargs.git
\end{DoxyVerb}


To run the tests with npm, just do\+: \begin{DoxyVerb}npm test
\end{DoxyVerb}


\section*{configuration }

Using the {\ttfamily yargs} stanza in your {\ttfamily package.\+json} you can turn on and off some of yargs\textquotesingle{} parsing features\+:


\begin{DoxyCode}
\{
  "yargs": \{
    "short-option-groups": true,
    "camel-case-expansion": true,
    "dot-notation": true,
    "parse-numbers": true,
    "boolean-negation": true
  \}
\}
\end{DoxyCode}


See the \href{https://github.com/yargs/yargs-parser#configuration}{\tt yargs-\/parser} module for detailed documentation of this feature.

\section*{inspired by }

This module is loosely inspired by Perl\textquotesingle{}s \href{http://search.cpan.org/~photo/Getopt-Casual-0.13.1/Casual.pm}{\tt Getopt\+::\+Casual}. 