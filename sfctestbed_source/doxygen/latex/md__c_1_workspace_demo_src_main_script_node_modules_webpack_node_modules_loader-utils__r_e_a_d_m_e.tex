\subsection*{Methods}

\subsubsection*{{\ttfamily get\+Loader\+Config}}

Recommended way to retrieve the loader config\+:


\begin{DoxyCode}
// inside your loader
config = loaderUtils.getLoaderConfig(this, "myLoader");
\end{DoxyCode}


Tries to read the loader config from the {\ttfamily webpack.\+config.\+js} under the given property name ({\ttfamily \char`\"{}my\+Loader\char`\"{}} in this case) and merges the result with the loader query. For example, if your {\ttfamily webpack.\+config.\+js} had this property...


\begin{DoxyCode}
cheesecakeLoader: \{
    type: "delicious",
    slices: 4
\}
\end{DoxyCode}


...and your loader was called with {\ttfamily ?slices=8}, {\ttfamily get\+Loader\+Config(this, \char`\"{}cheesecake\+Loader\char`\"{})} would return


\begin{DoxyCode}
\{
    type: "delicious",
    slices: 8
\}
\end{DoxyCode}


It is recommended that you use the camel\+Cased loader name as your default config property name.

\subsubsection*{{\ttfamily parse\+Query}}


\begin{DoxyCode}
var query = loaderUtils.parseQuery(this.query);
assert(typeof query == "object");
if(query.flag)
    // ...
\end{DoxyCode}



\begin{DoxyCode}
null                   -> \{\}
?                      -> \{\}
?flag                  -> \{ flag: true \}
?+flag                 -> \{ flag: true \}
?-flag                 -> \{ flag: false \}
?xyz=test              -> \{ xyz: "test" \}
?xyz[]=a               -> \{ xyz: ["a"] \}
?flag1&flag2           -> \{ flag1: true, flag2: true \}
?+flag1,-flag2         -> \{ flag1: true, flag2: false \}
?xyz[]=a,xyz[]=b       -> \{ xyz: ["a", "b"] \}
?a%2C%26b=c%2C%26d     -> \{ "a,&b": "c,&d" \}
?\{json:5,data:\{a:1\}\}   -> \{ json: 5, data: \{ a: 1 \} \}
\end{DoxyCode}


\subsubsection*{{\ttfamily stringify\+Request}}

Turns a request into a string that can be used inside {\ttfamily require()} or {\ttfamily import} while avoiding absolute paths. Use it instead of {\ttfamily J\+S\+O\+N.\+stringify(...)} if you\textquotesingle{}re generating code inside a loader.

{\bfseries Why is this necessary?} Since webpack calculates the hash before module paths are translated into module ids, we must avoid absolute paths to ensure consistent hashes across different compilations.

This function\+:


\begin{DoxyItemize}
\item resolves absolute requests into relative requests if the request and the module are on the same hard drive
\item replaces {\ttfamily \textbackslash{}} with {\ttfamily /} if the request and the module are on the same hard drive
\item won\textquotesingle{}t change the path at all if the request and the module are on different hard drives
\item applies {\ttfamily J\+S\+O\+N.\+stringify} to the result
\end{DoxyItemize}


\begin{DoxyCode}
loaderUtils.stringifyRequest(this, "./test.js");
// "\(\backslash\)"./test.js\(\backslash\)""

loaderUtils.stringifyRequest(this, ".\(\backslash\)\(\backslash\)test.js");
// "\(\backslash\)"./test.js\(\backslash\)""

loaderUtils.stringifyRequest(this, "test");
// "\(\backslash\)"test\(\backslash\)""

loaderUtils.stringifyRequest(this, "test/lib/index.js");
// "\(\backslash\)"test/lib/index.js\(\backslash\)""

loaderUtils.stringifyRequest(this, "otherLoader?andConfig!test?someConfig");
// "\(\backslash\)"otherLoader?andConfig!test?someConfig\(\backslash\)""

loaderUtils.stringifyRequest(this, require.resolve("test"));
// "\(\backslash\)"../node\_modules/some-loader/lib/test.js\(\backslash\)""

loaderUtils.stringifyRequest(this, "C:\(\backslash\)\(\backslash\)module\(\backslash\)\(\backslash\)test.js");
// "\(\backslash\)"../../test.js\(\backslash\)"" (on Windows, in case the module and the request are on the same drive)

loaderUtils.stringifyRequest(this, "C:\(\backslash\)\(\backslash\)module\(\backslash\)\(\backslash\)test.js");
// "\(\backslash\)"C:\(\backslash\)\(\backslash\)module\(\backslash\)\(\backslash\)test.js\(\backslash\)"" (on Windows, in case the module and the request are on different drives)

loaderUtils.stringifyRequest(this, "\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)network-drive\(\backslash\)\(\backslash\)test.js");
// "\(\backslash\)"\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)network-drive\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)test.js\(\backslash\)"" (on Windows, in case the module and the request are on different
       drives)
\end{DoxyCode}


\subsubsection*{{\ttfamily url\+To\+Request}}

Converts some resource \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} to a webpack module request.


\begin{DoxyCode}
var url = "path/to/module.js";
var request = loaderUtils.urlToRequest(url); // "./path/to/module.js"
\end{DoxyCode}


\paragraph*{Module U\+R\+Ls}

Any \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} containing a {\ttfamily $\sim$} will be interpreted as a module request. Anything after the {\ttfamily $\sim$} will be considered the request path.


\begin{DoxyCode}
var url = "~path/to/module.js";
var request = loaderUtils.urlToRequest(url); // "path/to/module.js"
\end{DoxyCode}


\paragraph*{Root-\/relative U\+R\+Ls}

U\+R\+Ls that are root-\/relative (start with {\ttfamily /}) can be resolved relative to some arbitrary path by using the {\ttfamily root} parameter\+:


\begin{DoxyCode}
var url = "/path/to/module.js";
var root = "./root";
var request = loaderUtils.urlToRequest(url, root); // "./root/path/to/module.js"
\end{DoxyCode}


To convert a root-\/relative \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} into a module \mbox{\hyperlink{namespace_u_r_l}{U\+RL}}, specify a {\ttfamily root} value that starts with {\ttfamily $\sim$}\+:


\begin{DoxyCode}
var url = "/path/to/module.js";
var root = "~";
var request = loaderUtils.urlToRequest(url, root); // "path/to/module.js"
\end{DoxyCode}


\subsubsection*{{\ttfamily interpolate\+Name}}

Interpolates a filename template using multiple placeholders and/or a regular expression. The template and regular expression are set as query params called {\ttfamily name} and {\ttfamily reg\+Exp} on the current loader\textquotesingle{}s context.


\begin{DoxyCode}
var interpolatedName = loaderUtils.interpolateName(loaderContext, name, options);
\end{DoxyCode}


The following tokens are replaced in the {\ttfamily name} parameter\+:


\begin{DoxyItemize}
\item {\ttfamily \mbox{[}ext\mbox{]}} the extension of the resource
\item {\ttfamily \mbox{[}name\mbox{]}} the basename of the resource
\item {\ttfamily \mbox{[}path\mbox{]}} the path of the resource relative to the {\ttfamily context} query parameter or option.
\item {\ttfamily \mbox{[}folder\mbox{]}} the folder of the resource is in.
\item {\ttfamily \mbox{[}emoji\mbox{]}} a random emoji representation of {\ttfamily options.\+content}
\item {\ttfamily \mbox{[}emoji\+:$<$length$>$\mbox{]}} same as above, but with a customizable number of emojis
\item {\ttfamily \mbox{[}hash\mbox{]}} the hash of {\ttfamily options.\+content} (Buffer) (by default it\textquotesingle{}s the hex digest of the md5 hash)
\item {\ttfamily \mbox{[}$<$hash\+Type$>$\+:hash\+:$<$digest\+Type$>$\+:$<$length$>$\mbox{]}} optionally one can configure
\begin{DoxyItemize}
\item other {\ttfamily hash\+Type}s, i. e. {\ttfamily sha1}, {\ttfamily md5}, {\ttfamily sha256}, {\ttfamily sha512}
\item other {\ttfamily digest\+Type}s, i. e. {\ttfamily hex}, {\ttfamily base26}, {\ttfamily base32}, {\ttfamily base36}, {\ttfamily base49}, {\ttfamily base52}, {\ttfamily base58}, {\ttfamily base62}, {\ttfamily base64}
\item and {\ttfamily length} the length in chars
\end{DoxyItemize}
\item {\ttfamily \mbox{[}N\mbox{]}} the N-\/th match obtained from matching the current file name against {\ttfamily options.\+reg\+Exp}
\end{DoxyItemize}

Examples


\begin{DoxyCode}
// loaderContext.resourcePath = "/app/js/javascript.js"
loaderUtils.interpolateName(loaderContext, "js/[hash].script.[ext]", \{ content: ... \});
// => js/9473fdd0d880a43c21b7778d34872157.script.js

// loaderContext.resourcePath = "/app/page.html"
loaderUtils.interpolateName(loaderContext, "html-[hash:6].html", \{ content: ... \});
// => html-9473fd.html

// loaderContext.resourcePath = "/app/flash.txt"
loaderUtils.interpolateName(loaderContext, "[hash]", \{ content: ... \});
// => c31e9820c001c9c4a86bce33ce43b679

// loaderContext.resourcePath = "/app/img/image.gif"
loaderUtils.interpolateName(loaderContext, "[emoji]", \{ content: ... \});
// => 👍

// loaderContext.resourcePath = "/app/img/image.gif"
loaderUtils.interpolateName(loaderContext, "[emoji:4]", \{ content: ... \});
// => 🙍🏢📤🐝

// loaderContext.resourcePath = "/app/img/image.png"
loaderUtils.interpolateName(loaderContext, "[sha512:hash:base64:7].[ext]", \{ content: ... \});
// => 2BKDTjl.png
// use sha512 hash instead of md5 and with only 7 chars of base64

// loaderContext.resourcePath = "/app/img/myself.png"
// loaderContext.query.name =
loaderUtils.interpolateName(loaderContext, "picture.png");
// => picture.png

// loaderContext.resourcePath = "/app/dir/file.png"
loaderUtils.interpolateName(loaderContext, "[path][name].[ext]?[hash]", \{ content: ... \});
// => /app/dir/file.png?9473fdd0d880a43c21b7778d34872157

// loaderContext.resourcePath = "/app/js/page-home.js"
loaderUtils.interpolateName(loaderContext, "script-[1].[ext]", \{ regExp: "page-(.*)\(\backslash\)\(\backslash\).js", content: ... \});
// => script-home.js
\end{DoxyCode}


\subsubsection*{{\ttfamily get\+Hash\+Digest}}


\begin{DoxyCode}
var digestString = loaderUtils.getHashDigest(buffer, hashType, digestType, maxLength);
\end{DoxyCode}



\begin{DoxyItemize}
\item {\ttfamily buffer} the content that should be hashed
\item {\ttfamily hash\+Type} one of {\ttfamily sha1}, {\ttfamily md5}, {\ttfamily sha256}, {\ttfamily sha512} or any other node.\+js supported hash type
\item {\ttfamily digest\+Type} one of {\ttfamily hex}, {\ttfamily base26}, {\ttfamily base32}, {\ttfamily base36}, {\ttfamily base49}, {\ttfamily base52}, {\ttfamily base58}, {\ttfamily base62}, {\ttfamily base64}
\item {\ttfamily max\+Length} the maximum length in chars
\end{DoxyItemize}

\subsection*{License}

M\+IT (\href{http://www.opensource.org/licenses/mit-license.php}{\tt http\+://www.\+opensource.\+org/licenses/mit-\/license.\+php}) 