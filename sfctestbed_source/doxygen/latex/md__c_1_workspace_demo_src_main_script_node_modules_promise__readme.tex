\href{https://promisesaplus.com/}{\tt } \section*{promise}

This is a simple implementation of Promises. It is a super set of E\+S6 Promises designed to have readable, performant code and to provide just the extensions that are absolutely necessary for using promises today.

For detailed tutorials on its use, see www.\+promisejs.\+org

{\bfseries N.\+B.} This promise exposes internals via underscore ({\ttfamily \+\_\+}) prefixed properties. If you use these, your code will break with each new release.

\href{https://travis-ci.org/then/promise}{\tt } \href{https://gemnasium.com/then/promise}{\tt } \href{https://npmjs.org/package/promise}{\tt } \href{https://npmjs.org/package/promise}{\tt }

\subsection*{Installation}

{\bfseries Server\+:} \begin{DoxyVerb}$ npm install promise
\end{DoxyVerb}


{\bfseries Client\+:}

You can use browserify on the client, or use the pre-\/compiled script that acts as a polyfill.


\begin{DoxyCode}
<script src="https://www.promisejs.org/polyfills/promise-6.1.0.js"></script>
\end{DoxyCode}


Note that the \href{https://github.com/es-shims/es5-shim}{\tt es5-\/shim} must be loaded before this library to support browsers pre I\+E9.


\begin{DoxyCode}
<script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/3.4.0/es5-shim.min.js"></script>
\end{DoxyCode}


\subsection*{Usage}

The example below shows how you can load the promise library (in a way that works on both client and server using node or browserify). It then demonstrates creating a promise from scratch. You simply call {\ttfamily new Promise(fn)}. There is a complete specification for what is returned by this method in \href{http://promises-aplus.github.com/promises-spec/}{\tt Promises/\+A+}.


\begin{DoxyCode}
var Promise = require('promise');

var promise = new Promise(function (resolve, reject) \{
  get('http://www.google.com', function (err, res) \{
    if (err) reject(err);
    else resolve(res);
  \});
\});
\end{DoxyCode}


If you need \href{https://iojs.org/api/domain.html}{\tt domains} support, you should instead use\+:


\begin{DoxyCode}
var Promise = require('promise/domains');
\end{DoxyCode}


If you are in an environment that implements {\ttfamily set\+Immediate} and don\textquotesingle{}t want the optimisations provided by asap, you can use\+:


\begin{DoxyCode}
var Promise = require('promise/setimmediate');
\end{DoxyCode}


If you only want part of the features, e.\+g. just a pure E\+S6 polyfill\+:


\begin{DoxyCode}
var Promise = require('promise/lib/es6-extensions');
// or require('promise/domains/es6-extensions');
// or require('promise/setimmediate/es6-extensions');
\end{DoxyCode}


\subsection*{Unhandled Rejections}

By default, promises silence any unhandled rejections.

You can enable logging of unhandled Reference\+Errors and Type\+Errors via\+:


\begin{DoxyCode}
require('promise/lib/rejection-tracking').enable();
\end{DoxyCode}


Due to the performance cost, you should only do this during development.

You can enable logging of all unhandled rejections if you need to debug an exception you think is being swallowed by promises\+:


\begin{DoxyCode}
require('promise/lib/rejection-tracking').enable(
  \{allRejections: true\}
);
\end{DoxyCode}


Due to the high probability of false positives, I only recommend using this when debugging specific issues that you think may be being swallowed. For the preferred debugging method, see {\ttfamily Promise\+::done(on\+Fulfilled, on\+Rejected)}.

{\ttfamily rejection-\/tracking.\+enable(options)} takes the following options\+:


\begin{DoxyItemize}
\item all\+Rejections ({\ttfamily boolean}) -\/ track all exceptions, not just reference errors and type errors. Note that this has a high probability of resulting in false positives if your code loads data optimisticly
\item whitelist ({\ttfamily Array$<$Error\+Constructor$>$}) -\/ this defaults to {\ttfamily \mbox{[}Reference\+Error, Type\+Error\mbox{]}} but you can override it with your own list of error constructors to track.
\item {\ttfamily on\+Unhandled(id, error)} and {\ttfamily on\+Handled(id, error)} -\/ you can use these to provide your own customised display for errors. Note that if possible you should indicate that the error was a false positive if {\ttfamily on\+Handled} is called. {\ttfamily on\+Handled} is only called if {\ttfamily on\+Unhandled} has already been called.
\end{DoxyItemize}

To reduce the chance of false-\/positives there is a delay of up to 2 seconds before errors are logged. This means that if you attach an error handler within 2 seconds, it won\textquotesingle{}t be logged as a false positive. Reference\+Errors and Type\+Errors are only subject to a 100ms delay due to the higher likelihood that the error is due to programmer error.

\subsection*{A\+PI}

Before all examples, you will need\+:


\begin{DoxyCode}
var Promise = require('promise');
\end{DoxyCode}


\subsubsection*{new Promise(resolver)}

This creates and returns a new promise. {\ttfamily resolver} must be a function. The {\ttfamily resolver} function is passed two arguments\+:


\begin{DoxyEnumerate}
\item {\ttfamily resolve} should be called with a single argument. If it is called with a non-\/promise value then the promise is fulfilled with that value. If it is called with a promise (A) then the returned promise takes on the state of that new promise (A).
\item {\ttfamily reject} should be called with a single argument. The returned promise will be rejected with that argument.
\end{DoxyEnumerate}

\subsubsection*{Static Functions}

These methods are invoked by calling {\ttfamily Promise.\+method\+Name}.

\paragraph*{Promise.\+resolve(value)}

(deprecated aliases\+: {\ttfamily Promise.\+from(value)}, {\ttfamily Promise.\+cast(value)})

Converts values and foreign promises into Promises/\+A+ promises. If you pass it a value then it returns a Promise for that value. If you pass it something that is close to a promise (such as a j\+Query attempt at a promise) it returns a Promise that takes on the state of {\ttfamily value} (rejected or fulfilled).

\paragraph*{Promise.\+reject(value)}

Returns a rejected promise with the given value.

\paragraph*{Promise.\+all(array)}

Returns a promise for an array. If it is called with a single argument that {\ttfamily Array.\+is\+Array} then this returns a promise for a copy of that array with any promises replaced by their fulfilled values. e.\+g.


\begin{DoxyCode}
Promise.all([Promise.resolve('a'), 'b', Promise.resolve('c')])
  .then(function (res) \{
    assert(res[0] === 'a')
    assert(res[1] === 'b')
    assert(res[2] === 'c')
  \})
\end{DoxyCode}


\paragraph*{Promise.\+denodeify(fn)}

{\itshape Non Standard}

Takes a function which accepts a node style callback and returns a new function that returns a promise instead.

e.\+g.


\begin{DoxyCode}
var fs = require('fs')

var read = Promise.denodeify(fs.readFile)
var write = Promise.denodeify(fs.writeFile)

var p = read('foo.json', 'utf8')
  .then(function (str) \{
    return write('foo.json', JSON.stringify(JSON.parse(str), null, '  '), 'utf8')
  \})
\end{DoxyCode}


\paragraph*{Promise.\+nodeify(fn)}

{\itshape Non Standard}

The twin to {\ttfamily denodeify} is useful when you want to export an A\+PI that can be used by people who haven\textquotesingle{}t learnt about the brilliance of promises yet.


\begin{DoxyCode}
module.exports = Promise.nodeify(awesomeAPI)
function awesomeAPI(a, b) \{
  return download(a, b)
\}
\end{DoxyCode}


If the last argument passed to {\ttfamily module.\+exports} is a function, then it will be treated like a node.\+js callback and not parsed on to the child function, otherwise the A\+PI will just return a promise.

\subsubsection*{Prototype Methods}

These methods are invoked on a promise instance by calling {\ttfamily my\+Promise.\+method\+Name}

\subsubsection*{Promise\+::then(on\+Fulfilled, on\+Rejected)}

This method follows the \href{http://promises-aplus.github.io/promises-spec/}{\tt Promises/\+A+ spec}. It explains things very clearly so I recommend you read it.

Either {\ttfamily on\+Fulfilled} or {\ttfamily on\+Rejected} will be called and they will not be called more than once. They will be passed a single argument and will always be called asynchronously (in the next turn of the event loop).

If the promise is fulfilled then {\ttfamily on\+Fulfilled} is called. If the promise is rejected then {\ttfamily on\+Rejected} is called.

The call to {\ttfamily .then} also returns a promise. If the handler that is called returns a promise, the promise returned by {\ttfamily .then} takes on the state of that returned promise. If the handler that is called returns a value that is not a promise, the promise returned by {\ttfamily .then} will be fulfilled with that value. If the handler that is called throws an exception then the promise returned by {\ttfamily .then} is rejected with that exception.

\paragraph*{Promise\+::catch(on\+Rejected)}

Sugar for {\ttfamily Promise\+::then(null, on\+Rejected)}, to mirror {\ttfamily catch} in synchronous code.

\paragraph*{Promise\+::done(on\+Fulfilled, on\+Rejected)}

{\itshape Non Standard}

The same semantics as {\ttfamily .then} except that it does not return a promise and any exceptions are re-\/thrown so that they can be logged (crashing the application in non-\/browser environments)

\paragraph*{Promise\+::nodeify(callback)}

{\itshape Non Standard}

If {\ttfamily callback} is {\ttfamily null} or {\ttfamily undefined} it just returns {\ttfamily this}. If {\ttfamily callback} is a function it is called with rejection reason as the first argument and result as the second argument (as per the node.\+js convention).

This lets you write A\+PI functions that look like\+:


\begin{DoxyCode}
function awesomeAPI(foo, bar, callback) \{
  return internalAPI(foo, bar)
    .then(parseResult)
    .then(null, retryErrors)
    .nodeify(callback)
\}
\end{DoxyCode}


People who use typical node.\+js style callbacks will be able to just pass a callback and get the expected behavior. The enlightened people can not pass a callback and will get awesome promises.

\subsection*{License}

M\+IT 