\section*{Service Worker Precache}

Service Worker Precache is a module for generating a service worker that precaches resources. It integrates with your build process. Once configured, it detects all your static resources (H\+T\+ML, Java\+Script, C\+SS, images, etc.) and generates a hash of each file\textquotesingle{}s contents. Information about each file\textquotesingle{}s \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} and versioned hash are stored in the generated service worker file, along with logic to serve those files cache-\/first, and automatically keep those files up to date when changes are detected in subsequent builds.

Serving your local static resources cache-\/first means that you can get all the crucial scaffolding for your web app—your App Shell—on the screen without having to wait for any network responses.

The module can be used in Java\+Script-\/based build scripts, like those written with \href{http://gulpjs.com/}{\tt {\ttfamily gulp}}, and it also provides a \href{#command-line-interface}{\tt command-\/line interface}. You can use the module directly, or if you\textquotesingle{}d prefer, use one of the \href{#wrappers-and-starter-kits}{\tt wrappers} around {\ttfamily sw-\/precache} for specific build environments, like \href{https://webpack.github.io/}{\tt {\ttfamily webpack}}.

It can be used alongside the \href{https://github.com/GoogleChrome/sw-toolbox}{\tt {\ttfamily sw-\/toolbox}} library, which works well when following the App Shell + dynamic content model.

The full documentation is in this R\+E\+A\+D\+ME, and the getting started guide provides a quicker jumping off point.

To learn more about the internals of the generated service worker, you can read \href{https://medium.com/@Huxpro/how-does-sw-precache-works-2d99c3d3c725}{\tt this deep-\/dive} by \href{https://twitter.com/Huxpro}{\tt Huang Xuan}.

\section*{Table of Contents}


\begin{DoxyItemize}
\item \href{#install}{\tt Install}
\item \href{#usage}{\tt Usage}
\begin{DoxyItemize}
\item \href{#overview}{\tt Overview}
\item \href{#example}{\tt Example}
\item \href{#considerations}{\tt Considerations}
\item \href{#command-line-interface}{\tt Command-\/line interface}
\end{DoxyItemize}
\item \href{#runtime-caching}{\tt Runtime Caching}
\item \href{#api}{\tt A\+PI}
\begin{DoxyItemize}
\item \href{#methods}{\tt Methods}
\begin{DoxyItemize}
\item \href{#generateoptions-callback}{\tt generate(options, callback)}
\item \href{#writefilepath-options-callback}{\tt write(file\+Path, options, callback)}
\end{DoxyItemize}
\item \href{#options-parameter}{\tt Options Parameter}
\begin{DoxyItemize}
\item \href{#cacheid-string}{\tt cache\+Id \mbox{[}String\mbox{]}}
\item \href{#clientsclaim-boolean}{\tt clients\+Claim \mbox{[}Boolean\mbox{]}}
\item \href{#directoryindex-string}{\tt directory\+Index \mbox{[}String\mbox{]}}
\item \href{#dontcachebusturlsmatching-regex}{\tt dont\+Cache\+Bust\+Urls\+Matching \mbox{[}Regex\mbox{]}}
\item \href{#dynamicurltodependencies-objectstringbufferarraystring}{\tt dynamic\+Url\+To\+Dependencies \mbox{[}Object\&\#x27e8;String,Buffer,Array\&\#x27e8;String\&\#x27e9;\&\#x27e9;\mbox{]}}
\item \href{#handlefetch-boolean}{\tt handle\+Fetch \mbox{[}boolean\mbox{]}}
\item \href{#ignoreurlparametersmatching-arrayregex}{\tt ignore\+Url\+Parameters\+Matching \mbox{[}Array\&\#x27e8;Regex\&\#x27e9;\mbox{]}}
\item \href{#importscripts-arraystring}{\tt import\+Scripts \mbox{[}Array\&\#x27e8;String\&\#x27e9;\mbox{]}}
\item \href{#logger-function}{\tt logger \mbox{[}function\mbox{]}}
\item \href{#maximumfilesizetocacheinbytes-number}{\tt maximum\+File\+Size\+To\+Cache\+In\+Bytes \mbox{[}Number\mbox{]}}
\item \href{#navigatefallback-string}{\tt navigate\+Fallback \mbox{[}String\mbox{]}}
\item \href{#navigatefallbackwhitelist-arrayregexp}{\tt navigate\+Fallback\+Whitelist \mbox{[}Array\&\#x27e8;Reg\+Exp\&\#x27e9;\mbox{]}}
\item \href{#replaceprefix-string}{\tt replace\+Prefix \mbox{[}String\mbox{]}}
\item \href{#runtimecaching-arrayobject}{\tt runtime\+Caching \mbox{[}Array\&\#x27e8;Object\&\#x27e9;\mbox{]}}
\item \href{#skipwaiting-boolean}{\tt skip\+Waiting \mbox{[}Boolean\mbox{]}}
\item \href{#staticfileglobs-arraystring}{\tt static\+File\+Globs \mbox{[}Array\&\#x27e8;String\&\#x27e9;\mbox{]}}
\item \href{#stripprefix-string}{\tt strip\+Prefix \mbox{[}String\mbox{]}}
\item \href{#stripprefixmulti-object}{\tt strip\+Prefix\+Multi \mbox{[}Object\mbox{]}}
\item \href{#templatefilepath-string}{\tt template\+File\+Path \mbox{[}String\mbox{]}}
\item \href{#verbose-boolean}{\tt verbose \mbox{[}boolean\mbox{]}}
\end{DoxyItemize}
\end{DoxyItemize}
\item \href{#wrappers-and-starter-kits}{\tt Wrappers and Starter Kits}
\begin{DoxyItemize}
\item \href{#clis}{\tt C\+L\+Is}
\item \href{#starter-kits}{\tt Starter Kits}
\item \href{#recipes-for-writing-a-custom-wrapper}{\tt Recipes for writing a custom wrapper}
\end{DoxyItemize}
\item \href{#acknowledgements}{\tt Acknowledgements}
\item \href{#future-of-service-worker-tooling}{\tt Future of Service Worker tooling}
\item \href{#license}{\tt License}
\end{DoxyItemize}

\subsection*{Install}

Local build integration\+: 
\begin{DoxyCode}
$ npm install --save-dev sw-precache
\end{DoxyCode}


Global command-\/line interface\+: 
\begin{DoxyCode}
$ npm install --global sw-precache
\end{DoxyCode}


\subsection*{Usage}

\subsubsection*{Overview}


\begin{DoxyEnumerate}
\item {\bfseries Make sure your site is served using H\+T\+T\+P\+S!} Service worker functionality is only available on pages that are accessed via H\+T\+T\+PS. ({\ttfamily \href{http://localhost}{\tt http\+://localhost}} will also work, to facilitate testing.) The rationale for this restriction is outlined in the \href{http://www.chromium.org/Home/chromium-security/prefer-secure-origins-for-powerful-new-features}{\tt \char`\"{}\+Prefer Secure Origins For Powerful New Features\char`\"{} document}.
\item {\bfseries Incorporate {\ttfamily sw-\/precache} into your {\ttfamily node}-\/based build script.} It should work well with either {\ttfamily gulp} or {\ttfamily Grunt}, or other build scripts that run on {\ttfamily node}. In fact, we\textquotesingle{}ve provided examples of both in the {\ttfamily demo/} directory. Each build script in {\ttfamily demo} has a function called {\ttfamily write\+Service\+Worker\+File()} that shows how to use the A\+PI. Both scripts generate fully-\/functional Java\+Script code that takes care of precaching and fetching all the resources your site needs to function offline. There is also a \href{#command-line-interface}{\tt command-\/line interface} available, for those using alternate build setups.
\item {\bfseries Register the service worker Java\+Script.} The Java\+Script that\textquotesingle{}s generated needs to be registered as the controlling service worker for your pages. This technically only needs to be done from within a top-\/level \char`\"{}entry\char`\"{} page for your site, since the registration includes a \href{https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#service-worker-registration-scope}{\tt {\ttfamily scope}} which will apply to all pages underneath your top-\/level page. \href{/demo/app/js/service-worker-registration.js}{\tt {\ttfamily service-\/worker-\/registration.\+js}} is a sample script that illustrates the best practices for registering the generated service worker and handling the various \href{https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#service-worker-state.1}{\tt lifecycle} events.
\end{DoxyEnumerate}

\subsubsection*{Example}

The project\textquotesingle{}s \href{/demo/gulpfile.js}{\tt sample {\ttfamily gulpfile.\+js}} illustrates the full use of sw-\/precache in context. (Note that the sample gulpfile.\+js is the one in the {\ttfamily demo} folder, not the one in the root of the project.) You can run the sample by cloning this repo, using \href{https://docs.npmjs.com/}{\tt {\ttfamily npm install}} to pull in the dependencies, changing to the {\ttfamily demo/} directory, running {\ttfamily \`{}npm bin\`{}/gulp serve-\/dist}, and then visiting \href{http://localhost:3000}{\tt http\+://localhost\+:3000}.

There\textquotesingle{}s also a \href{/demo/Gruntfile.js}{\tt sample {\ttfamily Gruntfile.\+js}} that shows service worker generation in Grunt. Though, it doesn\textquotesingle{}t run a server on localhost.

Here\textquotesingle{}s a simpler gulp example for a basic use case. It assumes your site\textquotesingle{}s resources are located under {\ttfamily app} and that you\textquotesingle{}d like to cache {\itshape all} your Java\+Script, H\+T\+ML, C\+SS, and image files.


\begin{DoxyCode}
gulp.task('generate-service-worker', function(callback) \{
  var swPrecache = require('sw-precache');
  var rootDir = 'app';

  swPrecache.write(`$\{rootDir\}/service-worker.js`, \{
    staticFileGlobs: [rootDir + '/**/*.\{js,html,css,png,jpg,gif,svg,eot,ttf,woff\}'],
    stripPrefix: rootDir
  \}, callback);
\});
\end{DoxyCode}


This task will create {\ttfamily app/service-\/worker.\+js}, which your client pages need to \href{https://slightlyoff.github.io/ServiceWorker/spec/service_worker/#navigator-service-worker-register}{\tt register} before it can take control of your site\textquotesingle{}s pages. \href{/demo/app/js/service-worker-registration.js}{\tt {\ttfamily service-\/worker-\/registration.\+js}} is a ready-\/to-\/ use script to handle registration.

\subsubsection*{Considerations}


\begin{DoxyItemize}
\item Service worker caching should be considered a progressive enhancement. If you follow the model of conditionally registering a service worker only if it\textquotesingle{}s supported (determined by `if(\textquotesingle{}service\+Worker' in navigator)\`{}), you\textquotesingle{}ll get offline support on browsers with service workers and on browsers that don\textquotesingle{}t support service workers, the offline-\/specific code will never be called. There\textquotesingle{}s no overhead/breakage for older browsers if you add {\ttfamily sw-\/precache} to your build.
\item {\bfseries All} resources that are precached will be fetched by a service worker running in a separate thread as soon as the service worker is installed. You should be judicious in what you list in the {\ttfamily dynamic\+Url\+To\+Dependencies} and {\ttfamily static\+File\+Globs} options, since listing files that are non-\/essential (large images that are not shown on every page, for instance) will result in browsers downloading more data than is strictly necessary.
\item Precaching doesn\textquotesingle{}t make sense for all types of resources (see the previous point). Other caching strategies, like those outlined in the \href{https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/}{\tt Offline Cookbook}, can be used in conjunction with {\ttfamily sw-\/precache} to provide the best experience for your users. If you do implement additional caching logic, put the code in a separate Java\+Script file and include it using the {\ttfamily import\+Scripts()} method.
\item {\ttfamily sw-\/precache} uses a \href{http://jakearchibald.com/2014/offline-cookbook/#cache-falling-back-to-network}{\tt cache-\/first} strategy, which results in a copy of any cached content being returned without consulting the network. A useful pattern to adopt with this strategy is to display a toast/alert to your users when there\textquotesingle{}s new content available, and give them an opportunity to reload the page to pick up that new content (which the service worker will have added to the cache, and will be available at the next page load). The sample \href{/demo/app/js/service-worker-registration.js}{\tt {\ttfamily service-\/worker-\/registration.\+js}} file \href{https://github.com/GoogleChrome/sw-precache/blob/7688ee8ccdaddd9171af352384d04d16d712f9d3/demo/app/js/service-worker-registration.js#L51}{\tt illustrates} the service worker lifecycle event you can listen for to trigger this message.
\end{DoxyItemize}

\subsubsection*{Command-\/line interface}

For those who would prefer not to use {\ttfamily sw-\/precache} as part of a {\ttfamily gulp} or {\ttfamily Grunt} build, there\textquotesingle{}s a \href{cli.js}{\tt command-\/line interface} which supports the \href{#options-parameter}{\tt options listed} in the A\+PI, provided via flags or an external Java\+Script configuration file.

{\bfseries Warning\+:} When using {\ttfamily sw-\/precache} \char`\"{}by hand\char`\"{}, outside of an automated build process, it\textquotesingle{}s your responsibility to re-\/run the command each time there\textquotesingle{}s a change to any local resources! If {\ttfamily sw-\/precache} is not run again, the previously cached local resources will be reused indefinitely.

Sensible defaults are assumed for options that are not provided. For example, if you are inside the top-\/level directory that contains your site\textquotesingle{}s contents, and you\textquotesingle{}d like to generate a {\ttfamily service-\/worker.\+js} file that will automatically precache all of the local files, you can simply run


\begin{DoxyCode}
$ sw-precache
\end{DoxyCode}


Alternatively, if you\textquotesingle{}d like to only precache {\ttfamily .html} files that live within {\ttfamily dist/}, which is a subdirectory of the current directory, you could run


\begin{DoxyCode}
$ sw-precache --root=dist --static-file-globs='dist/**/*.html'
\end{DoxyCode}


{\bfseries Note\+:} Be sure to use quotes around parameter values that have special meanings to your shell (such as the {\ttfamily $\ast$} characters in the sample command line above, for example).

Finally, there\textquotesingle{}s support for passing complex configurations using {\ttfamily -\/-\/config $<$file$>$}. Any of the options from the file can be overridden via a command-\/line flag. We strongly recommend passing it an external Java\+Script file defining config via \href{https://nodejs.org/api/modules.html#modules_module_exports}{\tt {\ttfamily module.\+exports}}. For example, assume there\textquotesingle{}s a {\ttfamily path/to/sw-\/precache-\/config.\+js} file that contains\+:


\begin{DoxyCode}
module.exports = \{
  staticFileGlobs: [
    'app/css/**.css',
    'app/**.html',
    'app/images/**.*',
    'app/js/**.js'
  ],
  stripPrefix: 'app/',
  runtimeCaching: [\{
    urlPattern: /this\(\backslash\)\(\backslash\).is\(\backslash\)\(\backslash\).a\(\backslash\)\(\backslash\).regex/,
    handler: 'networkFirst'
  \}]
\};
\end{DoxyCode}


That file could be passed to the command-\/line interface, while also setting the {\ttfamily verbose} option, via


\begin{DoxyCode}
$ sw-precache --config=path/to/sw-precache-config.js --verbose
\end{DoxyCode}


This provides the most flexibility, such as providing a regular expression for the {\ttfamily runtime\+Caching.\+url\+Pattern} option.

We also support passing in a J\+S\+ON file for {\ttfamily -\/-\/config}, though this provides less flexibility\+:


\begin{DoxyCode}
\{
  "staticFileGlobs": [
    "app/css/**.css",
    "app/**.html",
    "app/images/**.*",
    "app/js/**.js"
  ],
  "stripPrefix": "app/",
  "runtimeCaching": [\{
    "urlPattern": "/express/style/path/(.*)",
    "handler": "networkFirst"
  \}]
\}
\end{DoxyCode}


\subsection*{Runtime Caching}

It\textquotesingle{}s often desireable, even necessary to use precaching and runtime caching together. You may have seen our \href{https://github.com/GoogleChrome/sw-toolbox}{\tt {\ttfamily sw-\/toolbox}} tool, which handles runtime caching, and wondered how to use them together. Fortunately, {\ttfamily sw-\/precache} handles this for you.

The {\ttfamily sw-\/precache} module has the ability to include the {\ttfamily sw-\/toolbox} code and configuration alongside its own configuration. Using the {\ttfamily runtime\+Caching} configuration option in {\ttfamily sw-\/precache} (\href{#runtimecaching-arrayobject}{\tt see below}) is a shortcut that accomplishes what you could do manually by importing {\ttfamily sw-\/toolbox} in your service worker and writing your own routing rules.

\subsection*{A\+PI}

\subsubsection*{Methods}

The {\ttfamily sw-\/precache} module exposes two methods\+: {\ttfamily generate} and {\ttfamily write}.

\paragraph*{generate(options, callback)}

{\ttfamily generate} takes in \href{#options}{\tt options}, generates a service worker from them and passes the result to a callback function, which must have the following interface\+:

{\ttfamily callback(error, service\+Worker\+String)}

In the 1.\+x releases of {\ttfamily sw-\/precache}, this was the default and only method exposed by the module.

Since 2.\+2.\+0, {\ttfamily generate()} also returns a \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise}{\tt {\ttfamily Promise}}.

\paragraph*{write(file\+Path, options, callback)}

{\ttfamily write} takes in \href{#options}{\tt options}, generates a service worker from them, and writes the service worker to a specified file. This method always invokes {\ttfamily callback(error)}. If no error was found, the {\ttfamily error} parameter will be {\ttfamily null}

Since 2.\+2.\+0, {\ttfamily write()} also returns a \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise}{\tt {\ttfamily Promise}}.

\subsubsection*{Options Parameter}

Both the {\ttfamily generate()} and {\ttfamily write()} methods take the same options.

\paragraph*{cache\+Id \mbox{[}String\mbox{]}}

A string used to distinguish the caches created by different web applications that are served off of the same origin and path. While serving completely different sites from the same \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} is not likely to be an issue in a production environment, it avoids cache-\/conflicts when testing various projects all served off of {\ttfamily \href{http://localhost}{\tt http\+://localhost}}. You may want to set it to, e.\+g., the {\ttfamily name} property from your {\ttfamily package.\+json}.

{\itshape Default}\+: `'\textquotesingle{}\`{}

\paragraph*{clients\+Claim \mbox{[}Boolean\mbox{]}}

Controls whether or not the generated service worker will call \href{https://developer.mozilla.org/en-US/docs/Web/API/Clients/claim}{\tt {\ttfamily clients.\+claim()}} inside the {\ttfamily activate} handler.

Calling {\ttfamily clients.\+claim()} allows a newly registered service worker to take control of a page immediately, instead of having to wait until the next page navigation.

{\itshape Default}\+: {\ttfamily true}

\paragraph*{directory\+Index \mbox{[}String\mbox{]}}

Sets a default filename to return for \mbox{\hyperlink{namespace_u_r_l}{U\+RL}}\textquotesingle{}s formatted like directory paths (in other words, those ending in `'/\textquotesingle{}{\ttfamily ).}sw-\/precache{\ttfamily will take that translation into account and serve the contents a relative}directory\+Index{\ttfamily file when there\textquotesingle{}s no other match for a \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} ending in}\textquotesingle{}/\textquotesingle{}{\ttfamily . To turn off this behavior, set}directory\+Index{\ttfamily to}false{\ttfamily or}null{\ttfamily . To override this behavior for one or more U\+R\+Ls, use the}dynamic\+Url\+To\+Dependencies\`{} option to explicitly set up mappings between a directory \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} and a corresponding file.

{\itshape Default}\+: `\textquotesingle{}index.\+html'\`{}

\paragraph*{dont\+Cache\+Bust\+Urls\+Matching \mbox{[}Regex\mbox{]}}

It\textquotesingle{}s very important that the requests {\ttfamily sw-\/precache} makes to populate your cache result in the most up-\/to-\/date version of a resource at a given \mbox{\hyperlink{namespace_u_r_l}{U\+RL}}. Requests that are fulfilled with out-\/of-\/date responses (like those found in your browser\textquotesingle{}s H\+T\+TP cache) can end up being read from the service worker\textquotesingle{}s cache indefinitely. Jake Archibald\textquotesingle{}s \href{https://jakearchibald.com/2016/caching-best-practices/#a-service-worker-can-extend-the-life-of-these-bugs}{\tt blog post} provides more context about this problem.

In the interest of avoiding that scenario, {\ttfamily sw-\/precache} will, by default, append a cache-\/busting parameter to the end of each \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} it requests when populating or updating its cache. Developers who are explicitly doing \char`\"{}the right
thing\char`\"{} when it comes to setting H\+T\+TP caching headers on their responses might want to opt out of this cache-\/busting. For example, if all of your static resources already include versioning information in their U\+R\+Ls (via a tool like \href{https://github.com/sindresorhus/gulp-rev}{\tt {\ttfamily gulp-\/rev}}), and are served with long-\/lived H\+T\+TP caching headers, then the extra cache-\/busting \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} parameter is not needed, and can be safely excluded.

{\ttfamily dont\+Cache\+Bust\+Urls\+Matching} gives you a way of opting-\/in to skipping the cache busting behavior for a subset of your U\+R\+Ls (or all of them, if a catch-\/all value like {\ttfamily /./} is used). If set, then the \href{https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/pathname}{\tt pathname} of each \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} that\textquotesingle{}s prefetched will be matched against this value. If there\textquotesingle{}s a match, then the \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} will be prefetched as-\/is, without an additional cache-\/busting \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} parameter appended.

Note\+: Prior to {\ttfamily sw-\/precache} v5.\+0.\+0, {\ttfamily dont\+Cache\+Bust\+Urls\+Matching} matched against the entire request \mbox{\hyperlink{namespace_u_r_l}{U\+RL}}. As of v5.\+0.\+0, it only matches against the \mbox{\hyperlink{namespace_u_r_l}{U\+RL}}\textquotesingle{}s \href{https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/pathname}{\tt pathname}.

{\itshape Default}\+: not set

\paragraph*{dynamic\+Url\+To\+Dependencies \mbox{[}Object\&\#x27e8;String,Buffer,Array\&\#x27e8;String\&\#x27e9;\&\#x27e9;\mbox{]}}

Maps a dynamic \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} string to an array of all the files that \mbox{\hyperlink{namespace_u_r_l}{U\+RL}}\textquotesingle{}s contents depend on. E.\+g., if the contents of {\ttfamily /pages/home} are generated server-\/side via the templates {\ttfamily layout.\+jade} and {\ttfamily home.\+jade}, then specify `'/pages/home\textquotesingle{}\+: \mbox{[}\textquotesingle{}layout.\+jade\textquotesingle{}, \textquotesingle{}home.\+jade\textquotesingle{}\mbox{]}{\ttfamily . The M\+D5 hash is used to determine whether }/pages/home{\ttfamily has changed will depend on the hashes of both}layout.\+jade$<$tt$>$and home.\+jade\`{}.

An alternative value for the mapping is supported as well. You can specify a string or a Buffer instance rather than an array of file names. If you use this option, then the hash of the string/\+Buffer will be used to determine whether the \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} used as a key has changed. For example, `'/pages/dynamic\textquotesingle{}\+: dynamic\+String\+Value{\ttfamily could be used if the contents of }/pages/dynamic{\ttfamily changes whenever the string stored in}dynamic\+String\+Value\`{} changes.

{\itshape Default}\+: {\ttfamily \{\}}

\paragraph*{handle\+Fetch \mbox{[}boolean\mbox{]}}

Determines whether the {\ttfamily fetch} event handler is included in the generated service worker code. It is useful to set this to {\ttfamily false} in development builds, to ensure that features like live reload still work. Otherwise, the content would always be served from the service worker cache.

{\itshape Default}\+: {\ttfamily true}

\paragraph*{ignore\+Url\+Parameters\+Matching \mbox{[}Array\&\#x27e8;Regex\&\#x27e9;\mbox{]}}

{\ttfamily sw-\/precache} finds matching cache entries by doing a comparison with the full request \mbox{\hyperlink{namespace_u_r_l}{U\+RL}}. It\textquotesingle{}s common for sites to support \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} query parameters that don\textquotesingle{}t affect the site\textquotesingle{}s content and should be effectively ignored for the purposes of cache matching. One example is the \href{https://support.google.com/analytics/answer/1033867}{\tt {\ttfamily utm\+\_\+}-\/prefixed} parameters used for tracking campaign performance. By default, {\ttfamily sw-\/precache} will ignore {\ttfamily key=value} when {\ttfamily key} matches {\itshape any} of the regular expressions provided in this option. To ignore all parameters, use {\ttfamily \mbox{[}/./\mbox{]}}. To take all parameters into account when matching, use {\ttfamily \mbox{[}\mbox{]}}.

{\itshape Default}\+: {\ttfamily \mbox{[}/$^\wedge$utm\+\_\+/\mbox{]}}

\paragraph*{import\+Scripts \mbox{[}Array\&\#x27e8;String\&\#x27e9;\mbox{]}}

Writes calls to \href{https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/basic_usage#Importing_scripts_and_libraries}{\tt {\ttfamily import\+Scripts()}} to the resulting service worker to import the specified scripts.

{\itshape Default}\+: {\ttfamily \mbox{[}\mbox{]}}

\paragraph*{logger \mbox{[}function\mbox{]}}

Specifies a callback function for logging which resources are being precached and a precache size. Use {\ttfamily function() \{\}} if you\textquotesingle{}d prefer that nothing is logged. Within a {\ttfamily gulp} script, it\textquotesingle{}s recommended that you use \href{https://github.com/gulpjs/gulp-util}{\tt {\ttfamily gulp-\/util}} and pass in {\ttfamily gutil.\+log}.

{\itshape Default}\+: {\ttfamily console.\+log}

\paragraph*{maximum\+File\+Size\+To\+Cache\+In\+Bytes \mbox{[}Number\mbox{]}}

Sets the maximum allowed size for a file in the precache list.

{\itshape Default}\+: {\ttfamily 2097152} (2 megabytes)

\paragraph*{navigate\+Fallback \mbox{[}String\mbox{]}}

Sets an H\+T\+ML document to use as a fallback for U\+R\+Ls not found in the {\ttfamily sw-\/precache} cache. This fallback \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} needs to be cached via {\ttfamily static\+File\+Globs} or {\ttfamily dynamic\+Url\+To\+Dependencies} otherwise it won\textquotesingle{}t work.


\begin{DoxyCode}
// via staticFileGlobs
staticFileGlobs: ['/shell.html']
navigateFallback: '/shell.html'

// via dynamicUrlToDependencies
dynamicUrlToDependencies: \{
  '/shell': ['/shell.hbs']
\},
navigateFallback: '/shell'
\end{DoxyCode}


This comes in handy when used with a web application that performs client-\/side \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} routing using the \href{https://developer.mozilla.org/en-US/docs/Web/API/History}{\tt History A\+PI}. It allows any arbitrary \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} that the client generates to map to a fallback cached H\+T\+ML entry. This fallback entry ideally should serve as an \char`\"{}application shell\char`\"{} that is able to load the appropriate resources client-\/side, based on the request \mbox{\hyperlink{namespace_u_r_l}{U\+RL}}.

{\bfseries Note\+:} This is {\bfseries not} intended to be used to route failed navigations to a generic \char`\"{}offline fallback\char`\"{} page. The {\ttfamily navigate\+Fallback} page is used whether the browser is online or offline. If you want to implement an \char`\"{}offline fallback\char`\"{}, then using an approach similar to \href{https://googlechrome.github.io/samples/service-worker/custom-offline-page/}{\tt this example} is more appropriate.

{\itshape Default}\+: `'\textquotesingle{}\`{}

\paragraph*{navigate\+Fallback\+Whitelist \mbox{[}Array\&\#x27e8;Reg\+Exp\&\#x27e9;\mbox{]}}

Works to limit the effect of {\ttfamily navigate\+Fallback}, so that the fallback only applies to requests for U\+R\+Ls with paths that match at least one \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp}{\tt {\ttfamily Reg\+Exp}}.

This option is useful if you want to fallback to the cached App Shell for certain specific subsections of your site, but not have that behavior apply to all of your site\textquotesingle{}s U\+R\+Ls.

For example, if you would like to have {\ttfamily navigate\+Fallback} only apply to navigation requests to U\+R\+Ls whose path begins with {\ttfamily /guide/} (e.\+g. {\ttfamily \href{https://example.com/guide/1234}{\tt https\+://example.\+com/guide/1234}}), the following configuration could be used\+:


\begin{DoxyCode}
navigateFallback: '/shell',
navigateFallbackWhitelist: [/^\(\backslash\)/guide\(\backslash\)//]
\end{DoxyCode}


If set to {\ttfamily \mbox{[}\mbox{]}} (the default), the whitelist will be effectively bypassed, and {\ttfamily navigate\+Fallback} will apply to all navigation requests, regardless of \mbox{\hyperlink{namespace_u_r_l}{U\+RL}}.

{\itshape Default}\+: {\ttfamily \mbox{[}\mbox{]}}

\paragraph*{replace\+Prefix \mbox{[}String\mbox{]}}

Replaces a specified string at the beginning of path \mbox{\hyperlink{namespace_u_r_l}{U\+RL}}\textquotesingle{}s at runtime. Use this option when you are serving static files from a different directory at runtime than you are at build time. For example, if your local files are under {\ttfamily dist/app/} but your static asset root is at {\ttfamily /public/}, you\textquotesingle{}d strip \textquotesingle{}dist/app/\textquotesingle{} and replace it with \textquotesingle{}/public/\textquotesingle{}.

{\itshape Default}\+: `'\textquotesingle{}\`{}

\paragraph*{runtime\+Caching \mbox{[}Array\&\#x27e8;Object\&\#x27e9;\mbox{]}}

Configures runtime caching for dynamic content. If you use this option, the {\ttfamily sw-\/toolbox} library configured with the caching strategies you specify will automatically be included in your generated service worker file.

Each {\ttfamily Object} in the {\ttfamily Array} needs a {\ttfamily url\+Pattern}, which is either a \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp}{\tt {\ttfamily Reg\+Exp}} or a string, following the conventions of the {\ttfamily sw-\/toolbox} library\textquotesingle{}s \href{https://googlechrome.github.io/sw-toolbox/api.html#main}{\tt routing configuration}. Also required is a {\ttfamily handler}, which should be either a string corresponding to one of the \href{https://googlechrome.github.io/sw-toolbox/api.html#handlers}{\tt built-\/in handlers} under the {\ttfamily toolbox.} namespace, or a function corresponding to your custom \href{https://googlechrome.github.io/sw-toolbox/api.html#handlers}{\tt request handler}. Optionally, {\ttfamily method} can be added to specify one of the \href{https://googlechrome.github.io/sw-toolbox/api.html#expressive-approach}{\tt supported H\+T\+TP methods} (\+\_\+default\+: `\textquotesingle{}get'{\ttfamily \+\_\+). There is also support for}options{\ttfamily , which corresponds to the same options supported by a \mbox{[}}sw-\/toolbox\`{} handler\mbox{]}(\href{https://googlechrome.github.io/sw-toolbox/api.html#handlers}{\tt https\+://googlechrome.\+github.\+io/sw-\/toolbox/api.\+html\#handlers}).

For example, the following defines runtime caching behavior for two different \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} patterns. It uses a different handler for each, and specifies a dedicated cache with maximum size for requests that match {\ttfamily /articles/}\+:


\begin{DoxyCode}
runtimeCaching: [\{
  urlPattern: /^https:\(\backslash\)/\(\backslash\)/example\(\backslash\).com\(\backslash\)/api/,
  handler: 'networkFirst'
\}, \{
  urlPattern: /\(\backslash\)/articles\(\backslash\)//,
  handler: 'fastest',
  options: \{
    cache: \{
      maxEntries: 10,
      name: 'articles-cache'
    \}
  \}
\}]
\end{DoxyCode}


The \`{}sw-\/precache\`{} + \`{}sw-\/toolbox\`{} explainer has more information about how and why you\textquotesingle{}d use both libraries together.

{\itshape Default}\+: {\ttfamily \mbox{[}\mbox{]}}

\paragraph*{skip\+Waiting \mbox{[}Boolean\mbox{]}}

Controls whether or not the generated service worker will call \href{https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/skipWaiting}{\tt {\ttfamily skip\+Waiting()}} inside the {\ttfamily install} handler.

By default, when there\textquotesingle{}s an update to a previously installed service worker, then the new service worker delays activation and stays in a {\ttfamily waiting} state until all pages controlled by the old service worker are unloaded. Calling {\ttfamily skip\+Waiting()} allows a newly registered service worker to bypass the {\ttfamily waiting} state.

When {\ttfamily skip\+Waiting} is {\ttfamily true}, the new service worker\textquotesingle{}s {\ttfamily activate} handler will be called immediately, and any out of date cache entries from the previous service worker will be deleted. Please keep this in mind if you rely on older cached resources to be available throughout the page\textquotesingle{}s lifetime, because, for example, you \href{https://github.com/GoogleChrome/sw-precache/issues/180}{\tt defer the loading of some resources} until they\textquotesingle{}re needed at runtime.

{\itshape Default}\+: {\ttfamily true}

\paragraph*{static\+File\+Globs \mbox{[}Array\&\#x27e8;String\&\#x27e9;\mbox{]}}

An array of one or more string patterns that will be passed in to \href{https://github.com/isaacs/node-glob}{\tt {\ttfamily glob}}. All files matching these globs will be automatically precached by the generated service worker. You\textquotesingle{}ll almost always want to specify something for this.

{\itshape Default}\+: {\ttfamily \mbox{[}\mbox{]}}

\paragraph*{strip\+Prefix \mbox{[}String\mbox{]}}

Removes a specified string from the beginning of path \mbox{\hyperlink{namespace_u_r_l}{U\+RL}}\textquotesingle{}s at runtime. Use this option when there\textquotesingle{}s a discrepancy between a relative path at build time and the same path at run time. For example, if all your local files are under {\ttfamily dist/app/} and your web root is also at {\ttfamily dist/app/}, you\textquotesingle{}d strip that prefix from the start of each local file\textquotesingle{}s path in order to get the correct relative \mbox{\hyperlink{namespace_u_r_l}{U\+RL}}.

{\itshape Default}\+: `'\textquotesingle{}\`{}

\paragraph*{strip\+Prefix\+Multi \mbox{[}Object\mbox{]}}

Maps mutliple strings to be stripped and replaced from the beginning of \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} paths at runtime. Use this option when you have multiple discrepancies between relative paths at build time and the same path at run time. If {\ttfamily strip\+Prefix} and {\ttfamily replace\+Prefix} are not equal to `'\textquotesingle{}\`{}, they are automatically added to this option. 
\begin{DoxyCode}
stripPrefixMulti: \{
  'www-root/public-precached/': 'public/',
  'www-root/public/': 'public/'
\}
\end{DoxyCode}


{\itshape Default}\+: {\ttfamily \{\}}

\paragraph*{template\+File\+Path \mbox{[}String\mbox{]}}

The path to the (\href{https://lodash.com/docs#template}{\tt lo-\/dash}) template used to generate {\ttfamily service-\/worker.\+js}. If you need to add additional functionality to the generated service worker code, it\textquotesingle{}s recommended that you use the \href{#importscripts-arraystring}{\tt {\ttfamily import\+Scripts}} option to include extra Java\+Script rather than using a different template. But if you do need to change the basic generated service worker code, please make a copy of the \href{https://github.com/googlechrome/sw-precache/blob/master/service-worker.tmpl}{\tt original template}, modify it locally, and use this option to point to your template file.

{\itshape Default}\+: {\ttfamily service-\/worker.\+tmpl} (in the directory that this module lives in)

\paragraph*{verbose \mbox{[}boolean\mbox{]}}

Determines whether there\textquotesingle{}s log output for each individual static/dynamic resource that\textquotesingle{}s precached. Even if this is set to false, there will be a final log entry indicating the total size of all precached resources.

{\itshape Default}\+: {\ttfamily false}

\subsection*{Wrappers and Starter Kits}

While it\textquotesingle{}s possible to use the {\ttfamily sw-\/precache} module\textquotesingle{}s A\+PI directly within any Java\+Script environment, several wrappers have been developed by members of the community tailored to specific build environments. They include\+:
\begin{DoxyItemize}
\item \href{https://www.npmjs.com/package/sw-precache-webpack-plugin}{\tt {\ttfamily sw-\/precache-\/webpack-\/plugin}}
\item \href{https://www.npmjs.com/package/sw-precache-brunch}{\tt {\ttfamily sw-\/precache-\/brunch}}
\item \href{https://www.npmjs.com/package/grunt-sw-precache}{\tt {\ttfamily grunt-\/sw-\/precache}}
\item \href{https://www.npmjs.com/package/exhibit-builder-sw-precache}{\tt {\ttfamily exhibit-\/builder-\/sw-\/precache}}
\end{DoxyItemize}

There are also several starter kits or scaffolding projects that incorporate {\ttfamily sw-\/precache} into their build process, giving you a full service worker out of the box. The include\+:

\subsubsection*{C\+L\+Is}


\begin{DoxyItemize}
\item \href{https://github.com/Polymer/polymer-cli}{\tt {\ttfamily polymer-\/cli}}
\item \href{https://github.com/jeffposnick/create-react-pwa}{\tt {\ttfamily create-\/react-\/pwa}}
\end{DoxyItemize}

\subsubsection*{Starter Kits}


\begin{DoxyItemize}
\item \href{https://github.com/bertho-zero/react-redux-universal-hot-example}{\tt {\ttfamily react-\/redux-\/universal-\/hot-\/example}}
\item \href{https://github.com/polymerelements/polymer-starter-kit}{\tt Polymer Starter Kit}
\item \href{https://github.com/google/web-starter-kit}{\tt Web Starter Kit}
\end{DoxyItemize}

\subsubsection*{Recipes for writing a custom wrapper}

While there are not always ready-\/to-\/use wrappers for specific environments, this list contains some recipes to integrate {\ttfamily sw-\/precache} in your workflow\+:


\begin{DoxyItemize}
\item \href{https://gist.github.com/TimvdLippe/4c39b99e3b0ffbcdd8814a31e2969ed1}{\tt Gradle wrapper for offline Java\+Doc}
\item \href{https://gist.github.com/natecox/b19c4e08408a5bf0d4cf4d74f1902260}{\tt Brunch starter for Phoenix Framework}
\end{DoxyItemize}

\subsection*{Acknowledgements}

Thanks to \href{https://github.com/sindresorhus}{\tt Sindre Sorhus} and \href{https://github.com/addyosmani}{\tt Addy Osmani} for their advice and code reviews. \href{https://github.com/jakearchibald}{\tt Jake Archibald} was kind enough to review the service worker logic.

\subsection*{Future of Service Worker tooling}

Both sw-\/precache and sw-\/toolbox are {\bfseries actively maintained} and we plan to continue supporting them. A large number of \href{https://medium.com/dev-channel/progressive-web-app-libraries-in-production-b52cad37d34#.16kxwhu92}{\tt production} Progressive Web Apps are successfully using them today and we are happy to review issues or P\+Rs related to either project.

In parallel, we are working on the next generation of Service Worker tooling over in \href{https://github.com/GoogleChrome/workbox}{\tt Workbox}. This new work is more modular and will enable a number of libraries with additional capabilities to be built. We will announce further plans around the roadmap for this work in the future.

\subsection*{License}

Copyright © 2017 Google, Inc.

Licensed under the \mbox{[}Apache License, Version 2.\+0\mbox{]}(L\+I\+C\+E\+N\+SE) (the \char`\"{}\+License\char`\"{}); you may not use this file except in compliance with the License. You may obtain a copy of the License at

\href{http://www.apache.org/licenses/LICENSE-2.0}{\tt http\+://www.\+apache.\+org/licenses/\+L\+I\+C\+E\+N\+S\+E-\/2.\+0}

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \char`\"{}\+A\+S I\+S\char`\"{} B\+A\+S\+IS, W\+I\+T\+H\+O\+UT W\+A\+R\+R\+A\+N\+T\+I\+ES OR C\+O\+N\+D\+I\+T\+I\+O\+NS OF A\+NY K\+I\+ND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 