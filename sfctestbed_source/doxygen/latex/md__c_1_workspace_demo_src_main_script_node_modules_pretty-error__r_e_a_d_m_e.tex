\href{https://david-dm.org/AriaMinaei/pretty-error}{\tt } \href{https://travis-ci.org/AriaMinaei/pretty-error}{\tt } \href{https://npmjs.org/package/pretty-error}{\tt }

A small tool to see node.\+js errors with less clutter\+:



... which is more readable compared to node\textquotesingle{}s unformatted errors\+:



\subsection*{Installation}

Install with npm\+: \begin{DoxyVerb}$ npm install pretty-error
\end{DoxyVerb}


\subsection*{Usage and Examples}

To see an error rendered with colors, you can do this\+:


\begin{DoxyCode}
var PrettyError = require('pretty-error');
var pe = new PrettyError();

var renderedError = pe.render(new Error('Some error message'));
console.log(renderedError);
\end{DoxyCode}


Of course, you can render caught exceptions too\+:


\begin{DoxyCode}
try \{
   doSomethingThatThrowsAnError();
\} catch (error) \{
   console.log(pe.render(error));
\}
\end{DoxyCode}


But if you want pretty-\/error to render all errors, there is a shortcut for it\+:


\begin{DoxyCode}
require('pretty-error').start();
\end{DoxyCode}


... which is essentially equal to\+:


\begin{DoxyCode}
var PrettyError = require('pretty-error');

// instantiate PrettyError, which can then be used to render error objects
var pe = new PrettyError();
pe.start();
\end{DoxyCode}


You can also preload pretty-\/error into your code using node\textquotesingle{}s \href{https://nodejs.org/api/cli.html#cli_r_require_module}{\tt {\ttfamily -\/-\/require}} argument\+:


\begin{DoxyCode}
$ node --require pretty-error/start your-module.js
\end{DoxyCode}


\subsection*{How it Works}

Pretty\+Error turns error objects into something similar to an html document, and then uses \href{https://github.com/AriaMinaei/renderkid}{\tt Render\+Kid} to render the document using simple html/css-\/like commands. This allows Pretty\+Error to be themed using simple css-\/like declarations.

\subsection*{Theming}

Pretty\+Error\textquotesingle{}s default theme is a bunch of simple css-\/like rules. \href{https://github.com/AriaMinaei/pretty-error/blob/master/src/defaultStyle.coffee}{\tt Here} is the source of the default theme.

Since the default theme is all css, you can customize it to fit your taste. Let\textquotesingle{}s do a minimal one\+:


\begin{DoxyCode}
// the start() shortcut returns an instance of PrettyError ...
pe = require('pretty-error').start();

// ... which we can then use to customize like this:
pe.appendStyle(\{
   // this is a simple selector to the element that says 'Error'
   'pretty-error > header > title > kind': \{
      // which we can hide:
      display: 'none'
   \},

   // the 'colon' after 'Error':
   'pretty-error > header > colon': \{
      // we hide that too:
      display: 'none'
   \},

   // our error message
   'pretty-error > header > message': \{
      // let's change its color:
      color: 'bright-white',

      // we can use black, red, green, yellow, blue, magenta, cyan, white,
      // grey, bright-red, bright-green, bright-yellow, bright-blue,
      // bright-magenta, bright-cyan, and bright-white

      // we can also change the background color:
      background: 'cyan',

      // it understands paddings too!
      padding: '0 1' // top/bottom left/right
   \},

   // each trace item ...
   'pretty-error > trace > item': \{
      // ... can have a margin ...
      marginLeft: 2,

      // ... and a bullet character!
      bullet: '"<grey>o</grey>"'

      // Notes on bullets:
      //
      // The string inside the quotation mark gets used as the character
      // to show for the bullet point.
      //
      // You can set its color/background color using tags.
      //
      // This example sets the background color to white, and the text color
      // to cyan, the character will be a hyphen with a space character
      // on each side:
      // example: '"<bg-white><cyan> - </cyan></bg-white>"'
      //
      // Note that we should use a margin of 3, since the bullet will be
      // 3 characters long.
   \},

   'pretty-error > trace > item > header > pointer > file': \{
      color: 'bright-cyan'
   \},

   'pretty-error > trace > item > header > pointer > colon': \{
      color: 'cyan'
   \},

   'pretty-error > trace > item > header > pointer > line': \{
      color: 'bright-cyan'
   \},

   'pretty-error > trace > item > header > what': \{
      color: 'bright-white'
   \},

   'pretty-error > trace > item > footer > addr': \{
      display: 'none'
   \}
\});
\end{DoxyCode}


This is how our minimal theme will look like\+: 

Read \href{https://github.com/AriaMinaei/renderkid}{\tt Render\+Kid}\textquotesingle{}s docs to learn about all the css rules that are supported.

\subsection*{Customization}

There are a few methods to help you customize the contents of your error logs.

Let\textquotesingle{}s instantiate first\+:


\begin{DoxyCode}
PrettyError = require('pretty-error');
pe = new PrettyError();

// or:
pe = require('pretty-error').start();
\end{DoxyCode}


\paragraph*{Shortening paths}

You might want to substitute long paths with shorter, more readable aliases\+:


\begin{DoxyCode}
pe.alias('E:/open-source/theatrejs/lib', '(Theare.js)');
\end{DoxyCode}


\paragraph*{Skipping packages}

You might want to skip trace lines that belong to specific packages (chai, when, socket.\+io)\+:


\begin{DoxyCode}
pe.skipPackage('chai', 'when', 'socket.io');
\end{DoxyCode}


\paragraph*{Skipping node files}


\begin{DoxyCode}
// this will skip node.js, path.js, event.js, etc.
pe.skipNodeFiles();
\end{DoxyCode}


\paragraph*{Skipping paths}


\begin{DoxyCode}
pe.skipPath('/home/dir/someFile.js');
\end{DoxyCode}


\paragraph*{Skipping by callback}

You can customize which trace lines get logged and which won\textquotesingle{}t\+: 
\begin{DoxyCode}
pe.skip(function(traceLine, lineNumber)\{
   // if we know which package this trace line comes from, and it isn't
   // our 'demo' package ...
   if (typeof traceLine.packageName !== 'undefined' && traceLine.packageName !== 'demo') \{
      // then skip this line
      return true;
   \}

   // You can console.log(traceLine) to see all of it's properties.
   // Don't expect all these properties to be present, and don't assume
   // that our traceLine is always an object.
\});
\end{DoxyCode}


\paragraph*{Modifying each trace line\textquotesingle{}s contents}


\begin{DoxyCode}
pe.filter(function(traceLine, lineNumber)\{
   // the 'what' clause is something like:
   // 'DynamicTimeline.module.exports.DynamicTimeline.\_verifyProp'
   if (typeof traceLine.what !== 'undefined')\{

      // we can shorten it with a regex:
      traceLine.what = traceLine.what.replace(
         /(.*\(\backslash\).module\(\backslash\).exports\(\backslash\).)(.*)/, '$2'
      );
   \}
\});
\end{DoxyCode}


\#\# Disabling colors 
\begin{DoxyCode}
pe.withoutColors(); // Errors will be rendered without coloring
\end{DoxyCode}


\subsection*{Integrating with frameworks}

Pretty\+Error is very simple to set up, so it should be easy to use within other frameworks.

\subsubsection*{Integrating with \href{https://github.com/visionmedia/express}{\tt express}}

Most frameworks such as express, catch errors automatically and provide a mechanism to handle those errors. Here is an example of how you can use Pretty\+Error to log unhandled errors in express\+:


\begin{DoxyCode}
// this is app.js

var express = require('express');
var PrettyError = require('pretty-error');

var app = express();

app.get('/', function(req, res) \{
   // this will throw an error:
   var a = b;
\});

var server = app.listen(3000, function()\{
   console.log('Server started \(\backslash\)n');
\});


// we can now instantiaite Prettyerror:
pe = new PrettyError();

// and use it for our app's error handler:
app.use(function(err, req, res, next)\{
   console.log(pe.render(err));
   next();
\});

// we can optionally configure prettyError to simplify the stack trace:

pe.skipNodeFiles(); // this will skip events.js and http.js and similar core node files
pe.skipPackage('express'); // this will skip all the trace lines about express` core and sub-modules
\end{DoxyCode}


\subsection*{Troubleshooting}

{\ttfamily Pretty\+Error.\+start()} modifies the stack traces of all errors thrown anywhere in your code, so it could potentially break packages that rely on node\textquotesingle{}s original stack traces. I\textquotesingle{}ve only encountered this problem once, and it was with Blue\+Bird when {\ttfamily Promise.\+long\+Stack\+Traces()} was on.

In order to avoid this problem, it\textquotesingle{}s better to not use {\ttfamily Pretty\+Error.\+start()} and instead, manually catch errors and render them with Pretty\+Error\+:


\begin{DoxyCode}
var PrettyError = require('pretty-error');
var pe = new PrettyError();

// To render exceptions thrown in non-promies code:
process.on('uncaughtException', function(error)\{
   console.log(pe.render(error));
\});

// To render unhandled rejections created in BlueBird:
process.on('unhandledRejection', function(reason)\{
   console.log("Unhandled rejection");
   console.log(pe.render(reason));
\});

// While PrettyError.start() works out of the box with when.js` unhandled rejections,
// now that wer'e manually rendering errors, we have to instead use npmjs.org/packages/pretty-monitor
// to handle when.js rejections.
\end{DoxyCode}


The only drawback with this approach is that exceptions thrown in the first tick are not prettified. To fix that, you can delay your application\textquotesingle{}s startup for one tick\+:


\begin{DoxyCode}
// (continued form above)

throw new Error(); // not prettified
process.nextTick(function()\{
   throw new Error(); // prettified
\});
\end{DoxyCode}


\subsection*{License}

M\+IT 