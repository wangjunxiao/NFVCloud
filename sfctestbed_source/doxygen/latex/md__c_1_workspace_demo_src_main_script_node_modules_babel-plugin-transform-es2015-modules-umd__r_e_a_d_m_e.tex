\begin{quote}
This plugin transforms E\+S2015 modules to \href{https://github.com/umdjs/umd}{\tt Universal Module Definition (U\+MD)}. \end{quote}


\subsection*{Example}

{\bfseries In}


\begin{DoxyCode}
export default 42;
\end{DoxyCode}


{\bfseries Out}


\begin{DoxyCode}
(function (global, factory) \{
  if (typeof define === "function" && define.amd) \{
    define(["exports"], factory);
  \} else if (typeof exports !== "undefined") \{
    factory(exports);
  \} else \{
    var mod = \{
      exports: \{\}
    \};
    factory(mod.exports);
    global.actual = mod.exports;
  \}
\})(this, function (exports) \{
  "use strict";

  Object.defineProperty(exports, "\_\_esModule", \{
    value: true
  \});

  exports.default = 42;
\});
\end{DoxyCode}


\subsection*{Installation}


\begin{DoxyCode}
npm install --save-dev babel-plugin-transform-es2015-modules-umd
\end{DoxyCode}


\subsection*{Usage}

\subsubsection*{Via {\ttfamily .babelrc} (Recommended)}

$\ast$$\ast$.babelrc$\ast$$\ast$


\begin{DoxyCode}
\{
  "plugins": ["transform-es2015-modules-umd"]
\}
\end{DoxyCode}


You can also override the names of particular libraries when this module is running in the browser. For example the {\ttfamily es6-\/promise} library exposes itself as {\ttfamily global.\+Promise} rather than {\ttfamily global.\+es6\+Promise}. This can be accommodated by\+:


\begin{DoxyCode}
\{
  "plugins": [
    ["transform-es2015-modules-umd", \{
      "globals": \{
        "es6-promise": "Promise"
      \}
    \}]
  ]
\}
\end{DoxyCode}


\paragraph*{Default semantics}

There are a few things to note about the default semantics.

{\itshape First}, this transform uses the \href{https://en.wikipedia.org/wiki/Basename}{\tt basename} of each import to generate the global names in the U\+MD output. This means that if you\textquotesingle{}re importing multiple modules with the same basename, like\+:


\begin{DoxyCode}
import fooBar1 from "foo-bar";
import fooBar2 from "./mylib/foo-bar";
\end{DoxyCode}


it will transpile into two references to the same browser global\+:


\begin{DoxyCode}
factory(global.fooBar, global.fooBar);
\end{DoxyCode}


If you set the plugin options to\+:


\begin{DoxyCode}
\{
  "globals": \{
    "foo-bar": "fooBAR",
    "./mylib/foo-bar": "mylib.fooBar"
  \}
\}
\end{DoxyCode}


it will still transpile both to one browser global\+:


\begin{DoxyCode}
factory(global.fooBAR, global.fooBAR);
\end{DoxyCode}


because again the transform is only using the basename of the import.

{\itshape Second}, the specified override will still be passed to the {\ttfamily to\+Identifier} function in \href{https://github.com/babel/babel/blob/master/packages/babel-types/src/converters.js}{\tt babel-\/types/src/converters}. This means that if you specify an override as a member expression like\+:


\begin{DoxyCode}
\{
  "globals": \{
    "fizzbuzz": "fizz.buzz"
  \}
\}
\end{DoxyCode}


this will {\itshape not} transpile to {\ttfamily factory(global.\+fizz.\+buzz)}. Instead, it will transpile to {\ttfamily factory(global.\+fizz\+Buzz)} based on the logic in {\ttfamily to\+Identifier}.

{\itshape Third}, you cannot override the exported global name.

\paragraph*{More flexible semantics with {\ttfamily exact\+Globals\+: true}}

All of these behaviors can limit the flexibility of the {\ttfamily globals} map. To remove these limitations, you can set the {\ttfamily exact\+Globals} option to {\ttfamily true}. Doing this instructs the plugin to\+:


\begin{DoxyEnumerate}
\item always use the full import string instead of the basename when generating the global names
\item skip passing {\ttfamily globals} overrides to the {\ttfamily to\+Identifier} function. Instead, they are used exactly as written, so you will get errors if you do not use valid identifiers or valid uncomputed (dot) member expressions.
\item allow the exported global name to be overridden via the {\ttfamily globals} map. Any override must again be a valid identifier or valid member expression.
\end{DoxyEnumerate}

Thus, if you set {\ttfamily exact\+Globals} to {\ttfamily true} and do not pass any overrides, the first example of\+:


\begin{DoxyCode}
import fooBar1 from "foo-bar";
import fooBar2 from "./mylib/foo-bar";
\end{DoxyCode}


will transpile to\+:


\begin{DoxyCode}
factory(global.fooBar, global.mylibFooBar);
\end{DoxyCode}


And if you set the plugin options to\+:


\begin{DoxyCode}
\{
  "globals": \{
    "foo-bar": "fooBAR",
    "./mylib/foo-bar": "mylib.fooBar"
  \},
  "exactGlobals": true
\}
\end{DoxyCode}


then it\textquotesingle{}ll transpile to\+:


\begin{DoxyCode}
factory(global.fooBAR, global.mylib.fooBar)
\end{DoxyCode}


Finally, with the plugin options set to\+:


\begin{DoxyCode}
\{
  "plugins": [
    "external-helpers",
    ["transform-es2015-modules-umd", \{
      "globals": \{
        "my/custom/module/name": "My.Custom.Module.Name"
      \},
      "exactGlobals": true
    \}]
  ],
  "moduleId": "my/custom/module/name"
\}
\end{DoxyCode}


it will transpile to\+:


\begin{DoxyCode}
factory(mod.exports);
global.My = global.My || \{\};
global.My.Custom = global.My.Custom || \{\};
global.My.Custom.Module = global.My.Custom.Module || \{\};
global.My.Custom.Module.Name = mod.exports;
\end{DoxyCode}


\subsubsection*{Via C\+LI}


\begin{DoxyCode}
babel --plugins transform-es2015-modules-umd script.js
\end{DoxyCode}


\subsubsection*{Via Node A\+PI}


\begin{DoxyCode}
require("babel-core").transform("code", \{
  plugins: ["transform-es2015-modules-umd"]
\});
\end{DoxyCode}
 