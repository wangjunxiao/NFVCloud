\begin{quote}
Compile E\+S2015 for...of to E\+S5 \end{quote}


\subsection*{Example}

{\bfseries In}


\begin{DoxyCode}
for (var i of foo) \{\}
\end{DoxyCode}


{\bfseries Out}


\begin{DoxyCode}
var \_iteratorNormalCompletion = true;
var \_didIteratorError = false;
var \_iteratorError = undefined;

try \{
  for (var \_iterator = foo[Symbol.iterator](), \_step; !(\_iteratorNormalCompletion = (\_step =
       \_iterator.next()).done); \_iteratorNormalCompletion = true) \{
    var i = \_step.value;
  \}
\} catch (err) \{
  \_didIteratorError = true;
  \_iteratorError = err;
\} finally \{
  try \{
    if (!\_iteratorNormalCompletion && \_iterator.return) \{
      \_iterator.return();
    \}
  \} finally \{
    if (\_didIteratorError) \{
      throw \_iteratorError;
    \}
  \}
\}
\end{DoxyCode}


\subsection*{Installation}


\begin{DoxyCode}
npm install --save-dev babel-plugin-transform-es2015-for-of
\end{DoxyCode}


\subsection*{Usage}

\subsubsection*{Via {\ttfamily .babelrc} (Recommended)}

$\ast$$\ast$.babelrc$\ast$$\ast$


\begin{DoxyCode}
// without options
\{
  "plugins": ["transform-es2015-for-of"]
\}

// with options
\{
  "plugins": [
    ["transform-es2015-for-of", \{
      "loose": true
    \}]
  ]
\}
\end{DoxyCode}


\subsubsection*{Via C\+LI}


\begin{DoxyCode}
babel --plugins transform-es2015-for-of script.js
\end{DoxyCode}


\subsubsection*{Via Node A\+PI}


\begin{DoxyCode}
require("babel-core").transform("code", \{
  plugins: ["transform-es2015-for-of"]
\});
\end{DoxyCode}


\subsection*{Options}

\subsubsection*{{\ttfamily loose}}

{\ttfamily boolean}, defaults to {\ttfamily false}

In loose mode, arrays are put in a fast path, thus heavily increasing performance. All other iterables will continue to work fine.

\paragraph*{Example}

{\bfseries In}


\begin{DoxyCode}
for (var i of foo) \{\}
\end{DoxyCode}


{\bfseries Out}


\begin{DoxyCode}
for (var \_iterator = foo, \_isArray = Array.isArray(\_iterator), \_i = 0, \_iterator = \_isArray ? \_iterator :
       \_iterator[Symbol.iterator]();;) \{
  var \_ref;

  if (\_isArray) \{
    if (\_i >= \_iterator.length) break;
    \_ref = \_iterator[\_i++];
  \} else \{
    \_i = \_iterator.next();
    if (\_i.done) break;
    \_ref = \_i.value;
  \}

  var i = \_ref;
\}
\end{DoxyCode}


\paragraph*{Abrupt completions}

In loose mode an iterator\textquotesingle{}s {\ttfamily return} method will not be called on abrupt completions caused by thrown errors.

Please see \href{https://github.com/google/traceur-compiler/issues/1773}{\tt google/traceur-\/compiler\#1773} and \href{https://github.com/babel/babel/issues/838}{\tt babel/babel\#838} for more information.

\subsubsection*{Optimization}

If a basic array is used, Babel will compile the for-\/of loop down to a regular for loop.

{\bfseries In}


\begin{DoxyCode}
for (let a of [1,2,3]) \{\}
\end{DoxyCode}


{\bfseries Out}


\begin{DoxyCode}
var \_arr = [1, 2, 3];
for (var \_i = 0; \_i < \_arr.length; \_i++) \{
  var a = \_arr[\_i];
\}
\end{DoxyCode}
 