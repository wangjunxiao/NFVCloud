This package implements, in Java\+Script, the algorithms to convert a given Java\+Script value according to a given \href{http://heycam.github.io/webidl/}{\tt Web I\+DL} \href{http://heycam.github.io/webidl/#idl-types}{\tt type}.

The goal is that you should be able to write code like


\begin{DoxyCode}
"use strict";
const conversions = require("webidl-conversions");

function doStuff(x, y) \{
    x = conversions["boolean"](x);
    y = conversions["unsigned long"](y);
    // actual algorithm code here
\}
\end{DoxyCode}


and your function {\ttfamily do\+Stuff} will behave the same as a Web I\+DL operation declared as


\begin{DoxyCode}
void doStuff(boolean x, unsigned long y);
\end{DoxyCode}


\subsection*{A\+PI}

This package\textquotesingle{}s main module\textquotesingle{}s default export is an object with a variety of methods, each corresponding to a different Web I\+DL type. Each method, when invoked on a Java\+Script value, will give back the new Java\+Script value that results after passing through the Web I\+DL conversion rules. (See below for more details on what that means.) Alternately, the method could throw an error, if the Web I\+DL algorithm is specified to do so\+: for example {\ttfamily conversions\mbox{[}\char`\"{}float\char`\"{}\mbox{]}(NaN)} \href{http://heycam.github.io/webidl/#es-float}{\tt will throw a {\ttfamily Type\+Error}}.

Each method also accepts a second, optional, parameter for miscellaneous options. For conversion methods that throw errors, a string option {\ttfamily \{ context \}} may be provided to provide more information in the error message. (For example, {\ttfamily conversions\mbox{[}\char`\"{}float\char`\"{}\mbox{]}(NaN, \{ context\+: \char`\"{}\+Argument 1 of Interface\textquotesingle{}s operation\char`\"{} \})} will throw an error with message {\ttfamily \char`\"{}\+Argument 1 of Interface\textquotesingle{}s operation is not a finite floating-\/point value.\char`\"{}}) Specific conversions may also accept other options, the details of which can be found below.

\subsection*{Conversions implemented}

Conversions for all of the basic types from the Web I\+DL specification are implemented\+:


\begin{DoxyItemize}
\item \href{https://heycam.github.io/webidl/#es-any}{\tt {\ttfamily any}}
\item \href{https://heycam.github.io/webidl/#es-void}{\tt {\ttfamily void}}
\item \href{https://heycam.github.io/webidl/#es-boolean}{\tt {\ttfamily boolean}}
\item \href{https://heycam.github.io/webidl/#es-integer-types}{\tt Integer types}, which can additionally be provided the boolean options {\ttfamily \{ clamp, enforce\+Range \}} as a second parameter
\item \href{https://heycam.github.io/webidl/#es-float}{\tt {\ttfamily float}}, \href{https://heycam.github.io/webidl/#es-unrestricted-float}{\tt {\ttfamily unrestricted float}}
\item \href{https://heycam.github.io/webidl/#es-double}{\tt {\ttfamily double}}, \href{https://heycam.github.io/webidl/#es-unrestricted-double}{\tt {\ttfamily unrestricted double}}
\item \href{https://heycam.github.io/webidl/#es-DOMString}{\tt {\ttfamily D\+O\+M\+String}}, which can additionally be provided the boolean option {\ttfamily \{ treat\+Null\+As\+Empty\+String \}} as a second parameter
\item \href{https://heycam.github.io/webidl/#es-ByteString}{\tt {\ttfamily Byte\+String}}, \href{https://heycam.github.io/webidl/#es-USVString}{\tt {\ttfamily U\+S\+V\+String}}
\item \href{https://heycam.github.io/webidl/#es-object}{\tt {\ttfamily object}}
\item \href{https://heycam.github.io/webidl/#es-Error}{\tt {\ttfamily Error}}
\item \href{https://heycam.github.io/webidl/#es-buffer-source-types}{\tt Buffer source types}
\end{DoxyItemize}

Additionally, for convenience, the following derived type definitions are implemented\+:


\begin{DoxyItemize}
\item \href{https://heycam.github.io/webidl/#ArrayBufferView}{\tt {\ttfamily Array\+Buffer\+View}}
\item \href{https://heycam.github.io/webidl/#BufferSource}{\tt {\ttfamily Buffer\+Source}}
\item \href{https://heycam.github.io/webidl/#DOMTimeStamp}{\tt {\ttfamily D\+O\+M\+Time\+Stamp}}
\item \href{https://heycam.github.io/webidl/#Function}{\tt {\ttfamily Function}}
\item \href{https://heycam.github.io/webidl/#VoidFunction}{\tt {\ttfamily Void\+Function}} (although it will not censor the return type)
\end{DoxyItemize}

Derived types, such as nullable types, promise types, sequences, records, etc. are not handled by this library. You may wish to investigate the \href{https://github.com/jsdom/webidl2js}{\tt webidl2js} project.

\subsubsection*{A note on the {\ttfamily long long} types}

The {\ttfamily long long} and {\ttfamily unsigned long long} Web I\+DL types can hold values that cannot be stored in Java\+Script numbers, so the conversion is imperfect. For example, converting the Java\+Script number {\ttfamily 18446744073709552000} to a Web I\+DL {\ttfamily long long} is supposed to produce the Web I\+DL value {\ttfamily -\/18446744073709551232}. Since we are representing our Web I\+DL values in Java\+Script, we can\textquotesingle{}t represent {\ttfamily -\/18446744073709551232}, so we instead the best we could do is {\ttfamily -\/18446744073709552000} as the output.

This library actually doesn\textquotesingle{}t even get that far. Producing those results would require doing accurate modular arithmetic on 64-\/bit intermediate values, but Java\+Script does not make this easy. We could pull in a big-\/integer library as a dependency, but in lieu of that, we for now have decided to just produce inaccurate results if you pass in numbers that are not strictly between {\ttfamily Number.\+M\+I\+N\+\_\+\+S\+A\+F\+E\+\_\+\+I\+N\+T\+E\+G\+ER} and {\ttfamily Number.\+M\+A\+X\+\_\+\+S\+A\+F\+E\+\_\+\+I\+N\+T\+E\+G\+ER}.

\subsection*{Background}

What\textquotesingle{}s actually going on here, conceptually, is pretty weird. Let\textquotesingle{}s try to explain.

Web I\+DL, as part of its madness-\/inducing design, has its own type system. When people write algorithms in web platform specs, they usually operate on Web I\+DL values, i.\+e. instances of Web I\+DL types. For example, if they were specifying the algorithm for our {\ttfamily do\+Stuff} operation above, they would treat {\ttfamily x} as a Web I\+DL value of \href{http://heycam.github.io/webidl/#idl-boolean}{\tt Web I\+DL type {\ttfamily boolean}}. Crucially, they would {\itshape not} treat {\ttfamily x} as a Java\+Script variable whose value is either the Java\+Script {\ttfamily true} or {\ttfamily false}. They\textquotesingle{}re instead working in a different type system altogether, with its own rules.

Separately from its type system, Web I\+DL defines a \href{http://heycam.github.io/webidl/#ecmascript-binding}{\tt \char`\"{}binding\char`\"{}} of the type system into Java\+Script. This contains rules like\+: when you pass a Java\+Script value to the Java\+Script method that manifests a given Web I\+DL operation, how does that get converted into a Web I\+DL value? For example, a Java\+Script {\ttfamily true} passed in the position of a Web I\+DL {\ttfamily boolean} argument becomes a Web I\+DL {\ttfamily true}. But, a Java\+Script {\ttfamily true} passed in the position of a \href{http://heycam.github.io/webidl/#idl-unsigned-long}{\tt Web I\+DL {\ttfamily unsigned long}} becomes a Web I\+DL {\ttfamily 1}. And so on.

Finally, we have the actual implementation code. This is usually C++, although these days \href{https://github.com/servo/servo}{\tt some smart people are using Rust}. The implementation, of course, has its own type system. So when they implement the Web I\+DL algorithms, they don\textquotesingle{}t actually use Web I\+DL values, since those aren\textquotesingle{}t \char`\"{}real\char`\"{} outside of specs. Instead, implementations apply the Web I\+DL binding rules in such a way as to convert incoming Java\+Script values into C++ values. For example, if code in the browser called {\ttfamily do\+Stuff(true, true)}, then the implementation code would eventually receive a C++ {\ttfamily bool} containing {\ttfamily true} and a C++ {\ttfamily uint32\+\_\+t} containing {\ttfamily 1}.

The upside of all this is that implementations can abstract all the conversion logic away, letting Web I\+DL handle it, and focus on implementing the relevant methods in C++ with values of the correct type already provided. That is payoff of Web I\+DL, in a nutshell.

And getting to that payoff is the goal of {\itshape this} project—but for Java\+Script implementations, instead of C++ ones. That is, this library is designed to make it easier for Java\+Script developers to write functions that behave like a given Web I\+DL operation. So conceptually, the conversion pipeline, which in its general form is Java\+Script values ↦ Web I\+DL values ↦ implementation-\/language values, in this case becomes Java\+Script values ↦ Web I\+DL values ↦ Java\+Script values. And that intermediate step is where all the logic is performed\+: a Java\+Script {\ttfamily true} becomes a Web I\+DL {\ttfamily 1} in an unsigned long context, which then becomes a Java\+Script {\ttfamily 1}.

\subsection*{Don\textquotesingle{}t use this}

Seriously, why would you ever use this? You really shouldn\textquotesingle{}t. Web I\+DL is … strange, and you shouldn\textquotesingle{}t be emulating its semantics. If you\textquotesingle{}re looking for a generic argument-\/processing library, you should find one with better rules than those from Web I\+DL. In general, your Java\+Script should not be trying to become more like Web I\+DL; if anything, we should fix Web I\+DL to make it more like Java\+Script.

The {\itshape only} people who should use this are those trying to create faithful implementations (or polyfills) of web platform interfaces defined in Web I\+DL. Its main consumer is the \href{https://github.com/tmpvar/jsdom}{\tt jsdom} project. 