\label{_eslint-plugin-flowtype}%
 \section*{eslint-\/plugin-\/flowtype}

\href{https://www.npmjs.org/package/eslint-plugin-flowtype}{\tt } \href{https://travis-ci.org/gajus/eslint-plugin-flowtype}{\tt } \href{https://github.com/gajus/canonical}{\tt }

\href{http://flowtype.org/}{\tt Flow type} linting rules for E\+S\+Lint.


\begin{DoxyItemize}
\item \href{#eslint-plugin-flowtype}{\tt eslint-\/plugin-\/flowtype}
\begin{DoxyItemize}
\item \href{#eslint-plugin-flowtype-installation}{\tt Installation}
\item \href{#eslint-plugin-flowtype-configuration}{\tt Configuration}
\begin{DoxyItemize}
\item \href{#eslint-plugin-flowtype-configuration-shareable-configurations}{\tt Shareable configurations}
\end{DoxyItemize}
\item \href{#eslint-plugin-flowtype-settings}{\tt Settings}
\begin{DoxyItemize}
\item \href{#eslint-plugin-flowtype-settings-onlyfileswithflowannotation}{\tt {\ttfamily only\+Files\+With\+Flow\+Annotation}}
\end{DoxyItemize}
\item \href{#eslint-plugin-flowtype-rules}{\tt Rules}
\begin{DoxyItemize}
\item \href{#eslint-plugin-flowtype-rules-boolean-style}{\tt {\ttfamily boolean-\/style}}
\item \href{#eslint-plugin-flowtype-rules-define-flow-type}{\tt {\ttfamily define-\/flow-\/type}}
\item \href{#eslint-plugin-flowtype-rules-delimiter-dangle}{\tt {\ttfamily delimiter-\/dangle}}
\item \href{#eslint-plugin-flowtype-rules-generic-spacing}{\tt {\ttfamily generic-\/spacing}}
\item \href{#eslint-plugin-flowtype-rules-no-dupe-keys}{\tt {\ttfamily no-\/dupe-\/keys}}
\item \href{#eslint-plugin-flowtype-rules-no-primitive-constructor-types}{\tt {\ttfamily no-\/primitive-\/constructor-\/types}}
\item \href{#eslint-plugin-flowtype-rules-no-types-missing-file-annotation}{\tt {\ttfamily no-\/types-\/missing-\/file-\/annotation}}
\item \href{#eslint-plugin-flowtype-rules-no-weak-types}{\tt {\ttfamily no-\/weak-\/types}}
\item \href{#eslint-plugin-flowtype-rules-object-type-delimiter}{\tt {\ttfamily object-\/type-\/delimiter}}
\item \href{#eslint-plugin-flowtype-rules-require-parameter-type}{\tt {\ttfamily require-\/parameter-\/type}}
\item \href{#eslint-plugin-flowtype-rules-require-return-type}{\tt {\ttfamily require-\/return-\/type}}
\item \href{#eslint-plugin-flowtype-rules-require-valid-file-annotation}{\tt {\ttfamily require-\/valid-\/file-\/annotation}}
\item \href{#eslint-plugin-flowtype-rules-require-variable-type}{\tt {\ttfamily require-\/variable-\/type}}
\item \href{#eslint-plugin-flowtype-rules-semi}{\tt {\ttfamily semi}}
\item \href{#eslint-plugin-flowtype-rules-sort-keys}{\tt {\ttfamily sort-\/keys}}
\item \href{#eslint-plugin-flowtype-rules-space-after-type-colon}{\tt {\ttfamily space-\/after-\/type-\/colon}}
\item \href{#eslint-plugin-flowtype-rules-space-before-generic-bracket}{\tt {\ttfamily space-\/before-\/generic-\/bracket}}
\item \href{#eslint-plugin-flowtype-rules-space-before-type-colon}{\tt {\ttfamily space-\/before-\/type-\/colon}}
\item \href{#eslint-plugin-flowtype-rules-type-id-match}{\tt {\ttfamily type-\/id-\/match}}
\item \href{#eslint-plugin-flowtype-rules-union-intersection-spacing}{\tt {\ttfamily union-\/intersection-\/spacing}}
\item \href{#eslint-plugin-flowtype-rules-use-flow-type}{\tt {\ttfamily use-\/flow-\/type}}
\item \href{#eslint-plugin-flowtype-rules-valid-syntax}{\tt {\ttfamily valid-\/syntax}}
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}

\label{_eslint-plugin-flowtype-installation}%
 \subsection*{Installation}


\begin{DoxyEnumerate}
\item Install \href{https://www.github.com/eslint/eslint}{\tt E\+S\+Lint}.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Install \href{https://github.com/babel/babel-eslint}{\tt {\ttfamily babel-\/eslint}} parser (E\+S\+Lint parser \href{https://github.com/eslint/eslint/issues/2157}{\tt does not support type annotations}).
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Install \href{https://github.com/gajus/eslint-plugin-flowtype}{\tt {\ttfamily eslint-\/plugin-\/flowtype}} plugin.
\end{DoxyEnumerate}


\begin{DoxyCode}
npm install eslint --save-dev
npm install babel-eslint --save-dev
npm install eslint-plugin-flowtype --save-dev
\end{DoxyCode}


\label{_eslint-plugin-flowtype-configuration}%
 \subsection*{Configuration}


\begin{DoxyEnumerate}
\item Set {\ttfamily parser} property to {\ttfamily babel-\/eslint}.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Add {\ttfamily plugins} section and specify {\ttfamily eslint-\/plugin-\/flowtype} as a plugin.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Enable rules.
\end{DoxyEnumerate}


\begin{DoxyCode}
\{
  "parser": "babel-eslint",
  "plugins": [
    "flowtype"
  ],
  "rules": \{
    "flowtype/boolean-style": [
      2,
      "boolean"
    ],
    "flowtype/define-flow-type": 1,
    "flowtype/delimiter-dangle": [
      2,
      "never"
    ],
    "flowtype/generic-spacing": [
      2,
      "never"
    ],
    "flowtype/no-primitive-constructor-types": 2,
    "flowtype/no-types-missing-file-annotation": 2,
    "flowtype/no-weak-types": 2,
    "flowtype/object-type-delimiter": [
      2,
      "comma"
    ],
    "flowtype/require-parameter-type": 2,
    "flowtype/require-return-type": [
      2,
      "always",
      \{
        "annotateUndefined": "never"
      \}
    ],
    "flowtype/require-valid-file-annotation": 2,
    "flowtype/semi": [
      2,
      "always"
    ],
    "flowtype/space-after-type-colon": [
      2,
      "always"
    ],
    "flowtype/space-before-generic-bracket": [
      2,
      "never"
    ],
    "flowtype/space-before-type-colon": [
      2,
      "never"
    ],
    "flowtype/type-id-match": [
      2,
      "^([A-Z][a-z0-9]+)+Type$"
    ],
    "flowtype/union-intersection-spacing": [
      2,
      "always"
    ],
    "flowtype/use-flow-type": 1,
    "flowtype/valid-syntax": 1
  \},
  "settings": \{
    "flowtype": \{
      "onlyFilesWithFlowAnnotation": false
    \}
  \}
\}
\end{DoxyCode}


\label{_eslint-plugin-flowtype-configuration-shareable-configurations}%
 \subsubsection*{Shareable configurations}

\label{_eslint-plugin-flowtype-configuration-shareable-configurations-recommended}%
 \paragraph*{Recommended}

This plugin exports a \href{./src/configs/recommended.json}{\tt recommended configuration} that enforces Flow type good practices.

To enable this configuration use the extends property in your {\ttfamily .eslintrc} config file\+:


\begin{DoxyCode}
\{
  "extends": [
    "plugin:flowtype/recommended"
  ],
  "plugins": [
    "flowtype"
  ]
\}
\end{DoxyCode}


See \href{http://eslint.org/docs/user-guide/configuring#extending-configuration-files}{\tt E\+S\+Lint documentation} for more information about extending configuration files.

\label{_eslint-plugin-flowtype-settings}%
 \subsection*{Settings}

\label{_eslint-plugin-flowtype-settings-onlyfileswithflowannotation}%
 \subsubsection*{{\ttfamily only\+Files\+With\+Flow\+Annotation}}

When {\ttfamily true}, only checks files with a \href{http://flowtype.org/docs/about-flow.html#gradual}{\tt {\ttfamily @flow} annotation} in the first comment.


\begin{DoxyCode}
\{
  "settings": \{
    "flowtype": \{
      "onlyFilesWithFlowAnnotation": true
    \}
  \}
\}
\end{DoxyCode}


\label{_eslint-plugin-flowtype-rules}%
 \subsection*{Rules}

\label{_eslint-plugin-flowtype-rules-boolean-style}%
 \subsubsection*{{\ttfamily boolean-\/style}}

{\itshape The {\ttfamily -\/-\/fix} option on the command line automatically fixes problems reported by this rule.}

Enforces a particular style for boolean type annotations. This rule takes one argument.

If it is `\textquotesingle{}boolean'{\ttfamily then a problem is raised when using}bool{\ttfamily instead of}boolean\`{}.

If it is `\textquotesingle{}bool'{\ttfamily then a problem is raised when using}boolean{\ttfamily instead of}bool\`{}.

The default value is `\textquotesingle{}boolean'\`{}.

The following patterns are considered problems\+:


\begin{DoxyCode}
type X = bool
// Message: Use "boolean", not "bool"

// Options: ["boolean"]
type X = bool
// Message: Use "boolean", not "bool"

// Options: ["bool"]
type X = boolean
// Message: Use "bool", not "boolean"
\end{DoxyCode}


The following patterns are not considered problems\+:


\begin{DoxyCode}
type X = boolean

// Options: ["boolean"]
type X = boolean

// Options: ["bool"]
type X = bool

// Options: ["boolean"]
type X = bool
\end{DoxyCode}


\label{_eslint-plugin-flowtype-rules-define-flow-type}%
 \subsubsection*{{\ttfamily define-\/flow-\/type}}

Marks Flow type identifiers as defined.

Used to suppress \href{http://eslint.org/docs/rules/no-undef}{\tt {\ttfamily no-\/undef}} reporting of type identifiers.

The following patterns are not considered problems\+:


\begin{DoxyCode}
var a: AType
// Additional rules: \{"no-undef":2\}

var a: AType; var b: AType
// Additional rules: \{"no-undef":2\}

var a; (a: AType)
// Additional rules: \{"no-undef":2\}

var a: AType<BType>
// Additional rules: \{"no-undef":2\}

type A = AType
// Additional rules: \{"no-undef":2\}

function f(a: AType) \{\}
// Additional rules: \{"no-undef":2\}

function f(a: AType.a) \{\}
// Additional rules: \{"no-undef":2\}

function f(a: AType.a.b) \{\}
// Additional rules: \{"no-undef":2\}

function f(a): AType \{\}; var a: AType
// Additional rules: \{"no-undef":2\}

function f(a): AType \{\}
// Additional rules: \{"no-undef":2\}

class C \{ a: AType \}
// Additional rules: \{"no-undef":2\}

class C \{ a: AType.a \}
// Additional rules: \{"no-undef":2\}

class C \{ a: AType.a.b \}
// Additional rules: \{"no-undef":2\}

class C implements AType \{\}
// Additional rules: \{"no-undef":2\}

interface AType \{\}
// Additional rules: \{"no-undef":2\}

(\{ a: (\{b() \{\}\}: AType) \})
// Additional rules: \{"no-undef":2\}

type X = \{Y<AType>(): BType\}
// Additional rules: \{"no-undef":2\}

interface AType<BType> \{\}
// Additional rules: \{"no-undef":2\}

var a: AType
// Additional rules: \{"no-undef":2,"no-use-before-define":[2,"nofunc"]\}

var a: AType; var b: AType
// Additional rules: \{"no-undef":2,"no-use-before-define":[2,"nofunc"]\}

var a; (a: AType)
// Additional rules: \{"no-undef":2,"no-use-before-define":[2,"nofunc"]\}

var a: AType<BType>
// Additional rules: \{"no-undef":2,"no-use-before-define":[2,"nofunc"]\}

type A = AType
// Additional rules: \{"no-undef":2,"no-use-before-define":[2,"nofunc"]\}

function f(a: AType) \{\}
// Additional rules: \{"no-undef":2,"no-use-before-define":[2,"nofunc"]\}

function f(a: AType.a) \{\}
// Additional rules: \{"no-undef":2,"no-use-before-define":[2,"nofunc"]\}

function f(a: AType.a.b) \{\}
// Additional rules: \{"no-undef":2,"no-use-before-define":[2,"nofunc"]\}

function f(a): AType \{\}; var a: AType
// Additional rules: \{"no-undef":2,"no-use-before-define":[2,"nofunc"]\}

function f(a): AType \{\}
// Additional rules: \{"no-undef":2,"no-use-before-define":[2,"nofunc"]\}

class C \{ a: AType \}
// Additional rules: \{"no-undef":2,"no-use-before-define":[2,"nofunc"]\}

class C \{ a: AType.a \}
// Additional rules: \{"no-undef":2,"no-use-before-define":[2,"nofunc"]\}

class C \{ a: AType.a.b \}
// Additional rules: \{"no-undef":2,"no-use-before-define":[2,"nofunc"]\}

class C implements AType \{\}
// Additional rules: \{"no-undef":2,"no-use-before-define":[2,"nofunc"]\}

interface AType \{\}
// Additional rules: \{"no-undef":2,"no-use-before-define":[2,"nofunc"]\}

(\{ a: (\{b() \{\}\}: AType) \})
// Additional rules: \{"no-undef":2,"no-use-before-define":[2,"nofunc"]\}

type X = \{Y<AType>(): BType\}
// Additional rules: \{"no-undef":2,"no-use-before-define":[2,"nofunc"]\}

interface AType<BType> \{\}
// Additional rules: \{"no-undef":2,"no-use-before-define":[2,"nofunc"]\}
\end{DoxyCode}


\label{_eslint-plugin-flowtype-rules-delimiter-dangle}%
 \subsubsection*{{\ttfamily delimiter-\/dangle}}

{\itshape The {\ttfamily -\/-\/fix} option on the command line automatically fixes problems reported by this rule.}

Enforces consistent use of trailing commas in Object and Tuple annotations.

This rule takes one argument which mirrors E\+S\+Lint\textquotesingle{}s default {\ttfamily comma-\/dangle} rule.

If it is `\textquotesingle{}never'\`{} then a problem is raised when there is a trailing comma.

If it is `\textquotesingle{}always'\`{} then a problem is raised when there is no trailing comma.

If it is `\textquotesingle{}always-\/multiline'\`{} then a problem is raised when there is no trailing comma on a multi-\/line definition, or there {\itshape is} a trailing comma on a single-\/line definition.

If it is `\textquotesingle{}only-\/multiline'\`{} then a problem is raised when there is a trailing comma on a single-\/line definition. It allows, but does not enforce, trailing commas on multi-\/line definitions.

The default value is `\textquotesingle{}never'\`{}.

The following patterns are considered problems\+:


\begin{DoxyCode}
type X = \{ foo: string, \}
// Message: Unexpected trailing delimiter

// Options: ["never"]
type X = \{ foo: string, \}
// Message: Unexpected trailing delimiter

// Options: ["never"]
type X = \{ foo: string; \}
// Message: Unexpected trailing delimiter

// Options: ["never"]
type X = \{
foo: string,
\}
// Message: Unexpected trailing delimiter

// Options: ["always"]
type X = \{ foo: string \}
// Message: Missing trailing delimiter

// Options: ["always"]
type X = \{
foo: string
\}
// Message: Missing trailing delimiter

// Options: ["always-multiline"]
type X = \{ foo: string, \}
// Message: Unexpected trailing delimiter

// Options: ["always-multiline"]
type X = \{
foo: string
\}
// Message: Missing trailing delimiter

// Options: ["only-multiline"]
type X = \{ foo: string; \}
// Message: Unexpected trailing delimiter

// Options: ["never"]
type X = \{ [key: string]: number, \}
// Message: Unexpected trailing delimiter

// Options: ["always"]
type X = \{ [key: string]: number \}
// Message: Missing trailing delimiter

// Options: ["always-multiline"]
type X = \{ [key: string]: number, \}
// Message: Unexpected trailing delimiter

// Options: ["always-multiline"]
type X = \{
[key: string]: number
\}
// Message: Missing trailing delimiter

// Options: ["only-multiline"]
type X = \{ [key: string]: number; \}
// Message: Unexpected trailing delimiter

// Options: ["never"]
type X = \{ [key: string]: number, foo: string, \}
// Message: Unexpected trailing delimiter

// Options: ["never"]
type X = \{
[key: string]: number,
foo: string,
\}
// Message: Unexpected trailing delimiter

// Options: ["never"]
type X = \{
[key: string]: number,
aReallyLongPropertyNameHere: string,
\}
// Message: Unexpected trailing delimiter

// Options: ["always"]
type X = \{ [key: string]: number, foo: string \}
// Message: Missing trailing delimiter

// Options: ["always"]
type X = \{
[key: string]: number;
foo: string
\}
// Message: Missing trailing delimiter

// Options: ["always-multiline"]
type X = \{ [key: string]: number, foo: string, \}
// Message: Unexpected trailing delimiter

// Options: ["always-multiline"]
type X = \{
[key: string]: number,
foo: string
\}
// Message: Missing trailing delimiter

// Options: ["only-multiline"]
type X = \{ [key: string]: number, foo: string, \}
// Message: Unexpected trailing delimiter

// Options: ["never"]
type X = \{ foo: string, [key: string]: number, \}
// Message: Unexpected trailing delimiter

// Options: ["never"]
type X = \{
foo: string,
[key: string]: number,
\}
// Message: Unexpected trailing delimiter

// Options: ["never"]
type X = \{
aReallyLongPropertyNameHere: string,
[key: string]: number,
\}
// Message: Unexpected trailing delimiter

// Options: ["always"]
type X = \{ foo: string, [key: string]: number \}
// Message: Missing trailing delimiter

// Options: ["always"]
type X = \{ foo: string; [key: string]: number \}
// Message: Missing trailing delimiter

// Options: ["always-multiline"]
type X = \{ foo: string, [key: string]: number; \}
// Message: Unexpected trailing delimiter

// Options: ["always-multiline"]
type X = \{
foo: string,
[key: string]: number
\}
// Message: Missing trailing delimiter

// Options: ["only-multiline"]
type X = \{ foo: string, [key: string]: number; \}
// Message: Unexpected trailing delimiter

type X = [string, number,]
// Message: Unexpected trailing delimiter

// Options: ["never"]
type X = [string, number,]
// Message: Unexpected trailing delimiter

// Options: ["never"]
type X = [
string,
number,
]
// Message: Unexpected trailing delimiter

// Options: ["always"]
type X = [string, number]
// Message: Missing trailing delimiter

// Options: ["always"]
type X = [
string,
number
]
// Message: Missing trailing delimiter

// Options: ["always-multiline"]
type X = [string, number,]
// Message: Unexpected trailing delimiter

// Options: ["always-multiline"]
type X = [
foo, string
]
// Message: Missing trailing delimiter

// Options: ["only-multiline"]
type X = [ number, string, ]
// Message: Unexpected trailing delimiter
\end{DoxyCode}


The following patterns are not considered problems\+:


\begin{DoxyCode}
type X = \{ foo: string \}

// Options: ["never"]
type X = \{ foo: string \}

// Options: ["always"]
type X = \{ foo: string, \}

// Options: ["always"]
type X = \{ foo: string; \}

// Options: ["never"]
type X = \{
foo: string
\}

// Options: ["always"]
type X = \{
foo: string,
\}

// Options: ["always-multiline"]
type X = \{ foo: string \}

// Options: ["always-multiline"]
type X = \{
foo: string,
\}

// Options: ["always-multiline"]
type X = \{
foo: string;
\}

// Options: ["only-multiline"]
type X = \{ foo: string \}

// Options: ["only-multiline"]
type X = \{
foo: string
\}

// Options: ["only-multiline"]
type X = \{
foo: string,
\}

// Options: ["only-multiline"]
type X = \{
foo: string;
\}

// Options: ["never"]
type X = \{\}

// Options: ["always"]
type X = \{\}

// Options: ["always-multiline"]
type X = \{\}

// Options: ["only-multiline"]
type X = \{\}

// Options: ["never"]
type X = \{ [key: string]: number \}

// Options: ["always"]
type X = \{ [key: string]: number, \}

// Options: ["always"]
type X = \{ [key: string]: number; \}

// Options: ["always-multiline"]
type X = \{ [key: string]: number \}

// Options: ["always-multiline"]
type X = \{
[key: string]: number,
\}

// Options: ["only-multiline"]
type X = \{
[key: string]: number,
\}

// Options: ["only-multiline"]
type X = \{
[key: string]: number
\}

// Options: ["only-multiline"]
type X = \{ [key: string]: number \}

// Options: ["never"]
type X = \{ [key: string]: number, foo: string \}

// Options: ["always"]
type X = \{ [key: string]: number, foo: string, \}

// Options: ["always"]
type X = \{ [key: string]: number; foo: string; \}

// Options: ["always-multiline"]
type X = \{ [key: string]: number, foo: string \}

// Options: ["always-multiline"]
type X = \{
[key: string]: number,
foo: string,
\}

// Options: ["only-multiline"]
type X = \{
[key: string]: number,
foo: string,
\}

// Options: ["only-multiline"]
type X = \{
[key: string]: number;
foo: string
\}

// Options: ["only-multiline"]
type X = \{ [key: string]: number, foo: string \}

// Options: ["never"]
type X = \{ foo: string, [key: string]: number \}

// Options: ["always"]
type X = \{ foo: string, [key: string]: number, \}

// Options: ["always"]
type X = \{ foo: string; [key: string]: number; \}

// Options: ["always-multiline"]
type X = \{ foo: string, [key: string]: number \}

// Options: ["always-multiline"]
type X = \{
foo: string,
[key: string]: number,
\}

// Options: ["only-multiline"]
type X = \{
foo: string,
[key: string]: number,
\}

// Options: ["only-multiline"]
type X = \{
foo: string;
[key: string]: number
\}

// Options: ["only-multiline"]
type X = \{ foo: string, [key: string]: number \}

type X = [string, number]

// Options: ["never"]
type X = [string, number]

// Options: ["never"]
type X = [
string,
number
]

// Options: ["always"]
type X = [string, number,]

// Options: ["always"]
type X = [
string,
number,
]

// Options: ["always-multiline"]
type X = [ foo, string ]

// Options: ["always-multiline"]
type X = [
foo, string,
]

// Options: ["only-multiline"]
type X = [ number, string ]

// Options: ["only-multiline"]
type X = [
number,
string
]

// Options: ["only-multiline"]
type X = [
number,
string,
]

// Options: ["never"]
type X = []

// Options: ["always"]
type X = []

// Options: ["always-multiline"]
type X = []

// Options: ["only-multiline"]
type X = []
\end{DoxyCode}


\label{_eslint-plugin-flowtype-rules-generic-spacing}%
 \subsubsection*{{\ttfamily generic-\/spacing}}

{\itshape The {\ttfamily -\/-\/fix} option on the command line automatically fixes problems reported by this rule.}

Enforces consistent spacing within generic type annotation parameters.

This rule takes one argument. If it is `\textquotesingle{}never'{\ttfamily then a problem is raised when there is a space surrounding the generic type parameters. If it is}\textquotesingle{}always\textquotesingle{}\`{} then a problem is raised when there is no space surrounding the generic type parameters.

The default value is `\textquotesingle{}never'\`{}.

The following patterns are considered problems\+:


\begin{DoxyCode}
type X = Promise< string>
// Message: There must be no space at start of "Promise" generic type annotation

// Options: ["never"]
type X = Promise<  string>
// Message: There must be no space at start of "Promise" generic type annotation

type X = FooBar<string >
// Message: There must be no space at end of "FooBar" generic type annotation

type X = Promise< string >
// Message: There must be no space at start of "Promise" generic type annotation
// Message: There must be no space at end of "Promise" generic type annotation

type X = Promise< (foo), bar, (((baz))) >
// Message: There must be no space at start of "Promise" generic type annotation
// Message: There must be no space at end of "Promise" generic type annotation

// Options: ["always"]
type X = Promise<string >
// Message: There must be a space at start of "Promise" generic type annotation

// Options: ["always"]
type X = FooBar< string>
// Message: There must be a space at end of "FooBar" generic type annotation

// Options: ["always"]
type X = Promise<string>
// Message: There must be a space at start of "Promise" generic type annotation
// Message: There must be a space at end of "Promise" generic type annotation

// Options: ["always"]
type X = Promise<(foo), bar, (((baz)))>
// Message: There must be a space at start of "Promise" generic type annotation
// Message: There must be a space at end of "Promise" generic type annotation

// Options: ["always"]
type X = FooBar<  string >
// Message: There must be one space at start of "FooBar" generic type annotation

// Options: ["always"]
type X = FooBar< string  >
// Message: There must be one space at end of "FooBar" generic type annotation

// Options: ["always"]
type X = Promise<  (foo), bar, (((baz)))  >
// Message: There must be one space at start of "Promise" generic type annotation
// Message: There must be one space at end of "Promise" generic type annotation
\end{DoxyCode}


The following patterns are not considered problems\+:


\begin{DoxyCode}
type X = Promise<string>

type X = Promise<(string)>

type X = Promise<(foo), bar, (((baz)))>

// Options: ["always"]
type X = Promise< string >

// Options: ["always"]
type X = Promise< (string) >

// Options: ["always"]
type X = Promise< (foo), bar, (((baz))) >
\end{DoxyCode}


\label{_eslint-plugin-flowtype-rules-no-dupe-keys}%
 \subsubsection*{{\ttfamily no-\/dupe-\/keys}}

Checks for duplicate properties in Object annotations.

This rule mirrors E\+S\+Lint\textquotesingle{}s \href{http://eslint.org/docs/rules/no-dupe-keys}{\tt no-\/dupe-\/keys} rule.


\begin{DoxyCode}
\{
    "rules": \{
        "flowtype/no-dupe-keys": 2
    \}
\}
\end{DoxyCode}


The following patterns are considered problems\+:


\begin{DoxyCode}
type f = \{ a: number, b: string, a: number \}
// Message: Duplicate property.

type f = \{ a: number, b: string, a: string \}
// Message: Duplicate property.

type f = \{ get(key: "a"): string, get(key: "a"): string \}
// Message: Duplicate property.

type f = \{ get(key: 1): string, get(key: 1): string \}
// Message: Duplicate property.

type f = \{ get(key: 1.1): string, get(key: 1.1): string \}
// Message: Duplicate property.

type f = \{ get(key: true): string, get(key: true): string \}
// Message: Duplicate property.

type f = \{ get(key: \{a: 1\}): string, get(key: \{a: 1\}):string \}
// Message: Duplicate property.

var a = "a"; type f = \{ get(key: a): string, get(key: a): string \}
// Message: Duplicate property.

var b = 1; type f = \{ get(key: b): string, get(key: b): string \}
// Message: Duplicate property.

var c = true; type f = \{ get(key: c): string, get(key: c): string \}
// Message: Duplicate property.

var d = \{\}; type f = \{ get(key: d): string, get(key: d): string \}
// Message: Duplicate property.

var e = []; type f = \{ get(key: e): string, get(key: e): string \}
// Message: Duplicate property.

var e = [1, "a"]; type f = \{ get(key: e): string, get(key: e): string \}
// Message: Duplicate property.

function fn() \{\}; type f = \{ get(key: fn): string, get(key: fn): string \}
// Message: Duplicate property.
\end{DoxyCode}


The following patterns are not considered problems\+:


\begin{DoxyCode}
type FooType = \{ a: number, b: string, c: number \}

type FooType = \{ a: number, b: string, a: number \}

type f = \{ get(key: "a"): string, get(key: "b"): string \}

type f = \{ get(key: 1): string, get(key: 2): string \}

type f = \{ get(key: 1.1): string, get(key: 1.2): string \}

type f = \{ get(key: true): string, get(key: false): string \}

type f = \{ get(key: ["a", 1]): string, get(key: ["a", 2]): string \}

type f = \{ get(key: ["a", ["b", 1]]): string, get(key: ["a", ["b", 2]]): string \}

type f = \{ a: number, b: string, c: number \}

type f = \{ get(key: "a"): string, get(key: "b"): string \}

type f = \{ get(key: "a"): string, get(key: "a", key2: "b"): string \}

type f = \{ get(key: "a"): string, get(key: 1): string \}

type f = \{ get(key: \{ a: 1 \}): string, get(key: \{ a: 2 \}): string\}

var a = \{\}; var b = \{\}; type f = \{ get(key: a): string, get(key: b): string \}

var a = 1; var b = 1; type f = \{ get(key: a): string, get(key: b): string \}
\end{DoxyCode}


\label{_eslint-plugin-flowtype-rules-no-primitive-constructor-types}%
 \subsubsection*{{\ttfamily no-\/primitive-\/constructor-\/types}}

Disallows use of primitive constructors as types, such as {\ttfamily Boolean}, {\ttfamily Number} and {\ttfamily String}. \href{https://flowtype.org/docs/builtins.html}{\tt See more}.


\begin{DoxyCode}
\{
    "rules": \{
        "flowtype/no-primitive-constructor-types": 2
    \}
\}
\end{DoxyCode}


The following patterns are considered problems\+:


\begin{DoxyCode}
type x = Number
// Message: Unexpected use of Number constructor type.

type x = String
// Message: Unexpected use of String constructor type.

type x = Boolean
// Message: Unexpected use of Boolean constructor type.

type x = \{ a: Number \}
// Message: Unexpected use of Number constructor type.

type x = \{ a: String \}
// Message: Unexpected use of String constructor type.

type x = \{ a: Boolean \}
// Message: Unexpected use of Boolean constructor type.

(x: Number) => \{\}
// Message: Unexpected use of Number constructor type.

(x: String) => \{\}
// Message: Unexpected use of String constructor type.

(x: Boolean) => \{\}
// Message: Unexpected use of Boolean constructor type.
\end{DoxyCode}


The following patterns are not considered problems\+:


\begin{DoxyCode}
type x = number

type x = string

type x = boolean

type x = \{ a: number \}

type x = \{ a: string \}

type x = \{ a: boolean \}

(x: number) => \{\}

(x: string) => \{\}

(x: boolean) => \{\}

type x = MyNumber

type x = MyString

type x = MyBoolean
\end{DoxyCode}


\label{_eslint-plugin-flowtype-rules-no-types-missing-file-annotation}%
 \subsubsection*{{\ttfamily no-\/types-\/missing-\/file-\/annotation}}

Disallows Flow type imports, exports, aliases, and annotations in files missing a valid Flow file declaration (or a  annotation).


\begin{DoxyCode}
\{
    "rules": \{
        "flowtype/no-types-missing-file-annotation": 2
    \}
\}
\end{DoxyCode}


The following patterns are considered problems\+:


\begin{DoxyCode}
const x: number = 42;
// Message: Type annotations require valid Flow declaration.

type FooType = number;
// Message: Type aliases require valid Flow declaration.

import type A from "a"
// Message: Type imports require valid Flow declaration.

import type \{A\} from "a"
// Message: Type imports require valid Flow declaration.

import \{type A\} from "a"
// Message: Type imports require valid Flow declaration.

export type \{A\} from "a"
// Message: Type exports require valid Flow declaration.

function t<T>(): T\{\}
// Message: Type annotations require valid Flow declaration.
\end{DoxyCode}


The following patterns are not considered problems\+:


\begin{DoxyCode}
// @flow
const x: number = 42;

/* @flow weak */
type FooType = number;

/* @noflow */
type FooType = number;

/* @noflow */
import type A from "a"

/* @noflow */
import \{type A\} from "a"

/* @noflow */
export type \{A\} from "a"
\end{DoxyCode}


\label{_eslint-plugin-flowtype-rules-no-weak-types}%
 \subsubsection*{{\ttfamily no-\/weak-\/types}}

Warns against weak type annotations {\itshape any}, {\itshape Object} and {\itshape Function}. These types can cause flow to silently skip over portions of your code, which would have otherwise caused type errors.

This rule optionally takes one argument, an object to configure which type warnings to enable. By default, all of the warnings are enabled. e.\+g. to disable the {\ttfamily any} warning (allowing it to exist in your code), while continuing to warn about {\ttfamily Object} and {\ttfamily Function}\+:


\begin{DoxyCode}
\{
    "rules": \{
        "flowtype/no-weak-types": [2, \{
            "any": false,
            "Object": true,
            "Function": true
        \}]
    \}
\}

// or, the following is equivalent as default is true:

\{
    "rules": \{
        "flowtype/no-weak-types": [2, \{
            "any": false
        \}]
    \}
\}
\end{DoxyCode}


The following patterns are considered problems\+:


\begin{DoxyCode}
function foo(thing): any \{\}
// Message: Unexpected use of weak type "any"

function foo(thing): Promise<any> \{\}
// Message: Unexpected use of weak type "any"

function foo(thing): Promise<Promise<any>> \{\}
// Message: Unexpected use of weak type "any"

function foo(thing): Object \{\}
// Message: Unexpected use of weak type "Object"

function foo(thing): Promise<Object> \{\}
// Message: Unexpected use of weak type "Object"

function foo(thing): Promise<Promise<Object>> \{\}
// Message: Unexpected use of weak type "Object"

function foo(thing): Function \{\}
// Message: Unexpected use of weak type "Function"

function foo(thing): Promise<Function> \{\}
// Message: Unexpected use of weak type "Function"

function foo(thing): Promise<Promise<Function>> \{\}
// Message: Unexpected use of weak type "Function"

(foo: any) => \{\}
// Message: Unexpected use of weak type "any"

(foo: Function) => \{\}
// Message: Unexpected use of weak type "Function"

(foo?: any) => \{\}
// Message: Unexpected use of weak type "any"

(foo?: Function) => \{\}
// Message: Unexpected use of weak type "Function"

(foo: \{ a: any \}) => \{\}
// Message: Unexpected use of weak type "any"

(foo: \{ a: Object \}) => \{\}
// Message: Unexpected use of weak type "Object"

(foo: any[]) => \{\}
// Message: Unexpected use of weak type "any"

type Foo = any
// Message: Unexpected use of weak type "any"

type Foo = Function
// Message: Unexpected use of weak type "Function"

type Foo = \{ a: any \}
// Message: Unexpected use of weak type "any"

type Foo = \{ a: Object \}
// Message: Unexpected use of weak type "Object"

type Foo = \{ (a: Object): string \}
// Message: Unexpected use of weak type "Object"

type Foo = \{ (a: string): Function \}
// Message: Unexpected use of weak type "Function"

function foo(thing: any) \{\}
// Message: Unexpected use of weak type "any"

function foo(thing: Object) \{\}
// Message: Unexpected use of weak type "Object"

var foo: Function
// Message: Unexpected use of weak type "Function"

var foo: Object
// Message: Unexpected use of weak type "Object"

class Foo \{ props: any \}
// Message: Unexpected use of weak type "any"

class Foo \{ props: Object \}
// Message: Unexpected use of weak type "Object"

var foo: any
// Message: Unexpected use of weak type "any"

// Options: [\{"Function":false\}]
type X = any; type Y = Function; type Z = Object
// Message: Unexpected use of weak type "any"
// Message: Unexpected use of weak type "Object"

// Options: [\{"Object":false,"any":false\}]
type X = any; type Y = Function; type Z = Object
// Message: Unexpected use of weak type "Function"
\end{DoxyCode}


The following patterns are not considered problems\+:


\begin{DoxyCode}
function foo(thing): string \{\}

function foo(thing): Promise<string> \{\}

function foo(thing): Promise<Promise<string>> \{\}

(foo?: string) => \{\}

(foo: ?string) => \{\}

(foo: \{ a: string \}) => \{\}

(foo: \{ a: ?string \}) => \{\}

(foo: string[]) => \{\}

type Foo = string

type Foo = \{ a: string \}

type Foo = \{ (a: string): string \}

function foo(thing: string) \{\}

var foo: string

class Foo \{ props: string \}

// Options: [\{"Object":false,"any":false\}]
type X = any; type Y = Object

// Options: [\{"Function":false\}]
type X = Function

function foo(thing): Function \{\}
\end{DoxyCode}


\label{_eslint-plugin-flowtype-rules-object-type-delimiter}%
 \subsubsection*{{\ttfamily object-\/type-\/delimiter}}

{\itshape The {\ttfamily -\/-\/fix} option on the command line automatically fixes problems reported by this rule.}

Enforces consistent separators between properties in Flow object types.

This rule takes one argument.

If it is `\textquotesingle{}comma'{\ttfamily then a problem is raised when using};\`{} as a separator.

If it is `\textquotesingle{}semicolon'{\ttfamily then a problem is raised when using},\`{} as a separator.

The default value is `\textquotesingle{}comma'\`{}.

{\itshape This rule is ported from {\ttfamily babel/flow-\/object-\/type}, however the default option was changed.}

The following patterns are considered problems\+:


\begin{DoxyCode}
// Options: ["semicolon"]
type Foo = \{ a: Foo, b: Bar \}
// Message: Prefer semicolons to commas in object and class types

// Options: ["comma"]
type Foo = \{ a: Foo; b: Bar \}
// Message: Prefer commas to semicolons in object and class types

// Options: ["semicolon"]
type Foo = \{ [a: string]: Foo, [b: string]: Bar \}
// Message: Prefer semicolons to commas in object and class types

// Options: ["comma"]
type Foo = \{ [a: string]: Foo; [b: string]: Bar \}
// Message: Prefer commas to semicolons in object and class types

// Options: ["semicolon"]
type Foo = \{ (): Foo, (): Bar \}
// Message: Prefer semicolons to commas in object and class types

// Options: ["comma"]
type Foo = \{ (): Foo; (): Bar \}
// Message: Prefer commas to semicolons in object and class types

// Options: ["semicolon"]
declare class Foo \{ a: Foo, \}
// Message: Prefer semicolons to commas in object and class types

// Options: ["comma"]
declare class Foo \{ a: Foo; \}
// Message: Prefer commas to semicolons in object and class types

// Options: ["semicolon"]
declare class Foo \{ [a: string]: Foo, \}
// Message: Prefer semicolons to commas in object and class types

// Options: ["comma"]
declare class Foo \{ a: Foo; \}
// Message: Prefer commas to semicolons in object and class types

// Options: ["semicolon"]
declare class Foo \{ (): Foo, \}
// Message: Prefer semicolons to commas in object and class types

// Options: ["comma"]
declare class Foo \{ (): Foo; \}
// Message: Prefer commas to semicolons in object and class types

// Options: ["semicolon"]
declare class Foo \{ static (): Foo, \}
// Message: Prefer semicolons to commas in object and class types

// Options: ["comma"]
declare class Foo \{ static (): Foo; \}
// Message: Prefer commas to semicolons in object and class types
\end{DoxyCode}


The following patterns are not considered problems\+:


\begin{DoxyCode}
// Options: ["semicolon"]
type Foo = \{ a: Foo; b: Bar \}

// Options: ["comma"]
type Foo = \{ a: Foo, b: Bar \}

// Options: ["semicolon"]
type Foo = \{ [a: string]: Foo; [b: string]: Bar \}

// Options: ["comma"]
type Foo = \{ [a: string]: Foo, [b: string]: Bar \}

// Options: ["semicolon"]
type Foo = \{ (): Foo; (): Bar \}

// Options: ["comma"]
type Foo = \{ (): Foo, (): Bar \}

type Foo = \{ a: Foo, b: Bar \}

type Foo = \{ [a: string]: Foo, [b: string]: Bar \}

type Foo = \{ (): Foo, (): Bar \}

// Options: ["semicolon"]
declare class Foo \{ a: Foo; \}

// Options: ["comma"]
declare class Foo \{ a: Foo, \}

// Options: ["semicolon"]
declare class Foo \{ [a: string]: Foo; \}

// Options: ["comma"]
declare class Foo \{ [a: string]: Foo, \}

// Options: ["semicolon"]
declare class Foo \{ (): Foo; \}

// Options: ["comma"]
declare class Foo \{ (): Foo, \}

// Options: ["semicolon"]
type Foo = \{ a: Foo, b: Bar \}
\end{DoxyCode}


\label{_eslint-plugin-flowtype-rules-require-parameter-type}%
 \subsubsection*{{\ttfamily require-\/parameter-\/type}}

Requires that all function parameters have type annotations.

\label{_eslint-plugin-flowtype-rules-require-parameter-type-options}%
 \paragraph*{Options}

You can skip all arrow functions by providing the {\ttfamily exclude\+Arrow\+Functions} option with {\ttfamily true}.

Alternatively, you can want to exclude only concise arrow functions (e.\+g. {\ttfamily x =$>$ x $\ast$ 2}). Provide {\ttfamily exclude\+Arrow\+Functions} with {\ttfamily expressions\+Only} for this.


\begin{DoxyCode}
\{
    "rules": \{
        "flowtype/require-parameter-type": [
            2,
            \{
              "excludeArrowFunctions": true
            \}
        ]
    \}
\}

\{
    "rules": \{
        "flowtype/require-parameter-type": [
            2,
            \{
              "excludeArrowFunctions": "expressionsOnly"
            \}
        ]
    \}
\}
\end{DoxyCode}


You can exclude parameters that match a certain regex by using {\ttfamily exclude\+Parameter\+Match}.


\begin{DoxyCode}
\{
    "rules": \{
        "flowtype/require-parameter-type": [
            2,
            \{
              "excludeParameterMatch": "^\_"
            \}
        ]
    \}
\}
\end{DoxyCode}


This excludes all parameters that start with an underscore ({\ttfamily \+\_\+}). The default pattern is {\ttfamily a$^\wedge$}, which doesn\textquotesingle{}t match anything, i.\+e., all parameters are checked.

The following patterns are considered problems\+:


\begin{DoxyCode}
(foo) => \{\}
// Message: Missing "foo" parameter type annotation.

function x(foo) \{\}
// Message: Missing "foo" parameter type annotation.

// Options: [\{"excludeArrowFunctions":true\}]
function x(foo) \{\}
// Message: Missing "foo" parameter type annotation.

(foo = 'FOO') => \{\}
// Message: Missing "foo" parameter type annotation.

(...foo) => \{\}
// Message: Missing "foo" parameter type annotation.

(\{foo\}) => \{\}
// Message: Missing "\{foo\}" parameter type annotation.

([foo]) => \{\}
// Message: Missing "[foo]" parameter type annotation.

(\{foo = 1\} = \{\}) => \{\}
// Message: Missing "\{foo = 1\}" parameter type annotation.

// @flow
(foo) => \{\}
// Message: Missing "foo" parameter type annotation.

// Options: [\{"excludeArrowFunctions":"expressionsOnly"\}]
(foo) => \{\}
// Message: Missing "foo" parameter type annotation.

// Options: [\{"excludeArrowFunctions":"expressionsOnly"\}]
function x(foo) \{\}
// Message: Missing "foo" parameter type annotation.

// Options: [\{"excludeParameterMatch":"^\_"\}]
(\_foo: number, bar) => \{\}
// Message: Missing "bar" parameter type annotation.

// Options: [\{"excludeParameterMatch":"^\_"\}]
(\_foo, bar) => \{\}
// Message: Missing "bar" parameter type annotation.
\end{DoxyCode}


The following patterns are not considered problems\+:


\begin{DoxyCode}
(foo: string) => \{\}

(foo: string = 'FOO') => \{\}

(...foo: string) => \{\}

(\{foo\}: \{foo: string\}) => \{\}

([foo]: Array) => \{\}

(foo) => \{\}

// Options: [\{"excludeArrowFunctions":true\}]
(foo) => \{\}

// Options: [\{"excludeArrowFunctions":"expressionsOnly"\}]
(foo) => 3

// Options: [\{"excludeParameterMatch":"^\_"\}]
(\_foo, bar: string) => \{\}

// Options: [\{"excludeParameterMatch":"^\_"\}]
(\_foo: number, bar: string) => \{\}

(foo) => \{\}
\end{DoxyCode}


\label{_eslint-plugin-flowtype-rules-require-return-type}%
 \subsubsection*{{\ttfamily require-\/return-\/type}}

Requires that functions have return type annotation.

\label{_eslint-plugin-flowtype-rules-require-return-type-options}%
 \paragraph*{Options}

You can skip all arrow functions by providing the {\ttfamily exclude\+Arrow\+Functions} option with {\ttfamily true}.

Alternatively, you can exclude a concise arrow function (e.\+g. {\ttfamily () =$>$ 2}). Provide {\ttfamily exclude\+Arrow\+Functions} with {\ttfamily expressions\+Only} for this.


\begin{DoxyCode}
\{
    "rules": \{
        "flowtype/require-return-type": [
            2,
            "always",
            \{
              "excludeArrowFunctions": true
            \}
        ]
    \}
\}

\{
    "rules": \{
        "flowtype/require-return-type": [
            2,
            "always",
            \{
              "excludeArrowFunctions": "expressionsOnly"
            \}
        ]
    \}
\}
\end{DoxyCode}


You can exclude or include specific tests with the {\ttfamily include\+Only\+Matching} and {\ttfamily exclude\+Matching} rules.


\begin{DoxyCode}
\{
    "rules": \{
        "flowtype/require-return-type": [
            2,
            "always",
            \{
              "includeOnlyMatching": [
                  "^F.*",
                  "Ba(r|z)"
              ]
            \}
        ]
    \}
\}

\{
    "rules": \{
        "flowtype/require-return-type": [
            2,
            "always",
            \{
              "excludeMatching": [
                  "^F.*",
                  "Ba(r|z)"
              ]
            \}
        ]
    \}
\}
\end{DoxyCode}


Both rules take an array that can contain either strings or valid Reg\+Exp statements.

The following patterns are considered problems\+:


\begin{DoxyCode}
(foo) => \{ return "foo"; \}
// Message: Missing return type annotation.

// Options: ["always"]
(foo) => \{ return "foo"; \}
// Message: Missing return type annotation.

// Options: ["always"]
(foo) => "foo"
// Message: Missing return type annotation.

(foo) => (\{\})
// Message: Missing return type annotation.

(foo): undefined => \{ return; \}
// Message: Must not annotate undefined return type.

(foo): void => \{ return; \}
// Message: Must not annotate undefined return type.

(foo): undefined => \{ return undefined; \}
// Message: Must not annotate undefined return type.

(foo): void => \{ return void 0; \}
// Message: Must not annotate undefined return type.

// Options: ["always",\{"annotateUndefined":"never"\}]
(foo): undefined => \{ return; \}
// Message: Must not annotate undefined return type.

// Options: ["always",\{"annotateUndefined":"never"\}]
(foo): void => \{ return; \}
// Message: Must not annotate undefined return type.

// Options: ["always",\{"annotateUndefined":"always"\}]
(foo) => \{ return; \}
// Message: Must annotate undefined return type.

// Options: ["always",\{"annotateUndefined":"never"\}]
(foo): undefined => \{ return undefined; \}
// Message: Must not annotate undefined return type.

// Options: ["always",\{"annotateUndefined":"always"\}]
(foo) => \{ return undefined; \}
// Message: Must annotate undefined return type.

// Options: ["always",\{"annotateUndefined":"always"\}]
(foo) => \{ return void 0; \}
// Message: Must annotate undefined return type.

// @flow
(foo) => \{ return 1; \}
// Message: Missing return type annotation.

// Options: ["always",\{"annotateUndefined":"always"\}]
// @flow
 (foo) => \{ return undefined; \}
// Message: Must annotate undefined return type.

// Options: ["always"]
async () => \{ return 2; \}
// Message: Missing return type annotation.

// Options: ["always",\{"annotateUndefined":"always"\}]
async () => \{\}
// Message: Missing return type annotation.

// Options: ["always",\{"annotateUndefined":"always"\}]
async function x() \{\}
// Message: Missing return type annotation.

// Options: ["always"]
async () => \{ return; \}
// Message: Missing return type annotation.

// Options: ["always"]
function* x() \{\}
// Message: Missing return type annotation.

// Options: ["always",\{"excludeArrowFunctions":"expressionsOnly"\}]
() => \{ return 3; \}
// Message: Missing return type annotation.

// Options: ["always",\{"excludeArrowFunctions":"expressionsOnly"\}]
async () => \{ return 4; \}
// Message: Missing return type annotation.

// Options: ["always",\{"includeOnlyMatching":["bar"]\}]
function foo() \{ return 42; \}
function bar() \{ return 42; \}
// Message: Missing return type annotation.

// Options: ["always",\{"includeOnlyMatching":["bar"]\}]
const foo = () => \{ return 42; \};
const bar = () => \{ return 42; \}
// Message: Missing return type annotation.
\end{DoxyCode}


The following patterns are not considered problems\+:


\begin{DoxyCode}
return;

(foo): string => \{\}

// Options: ["always"]
(foo): string => \{\}

(foo) => \{ return; \}

(foo): Object => ( \{\} )

(foo) => \{ return undefined; \}

(foo) => \{ return void 0; \}

// Options: ["always",\{"annotateUndefined":"always"\}]
(foo): undefined => \{ return; \}

// Options: ["always",\{"annotateUndefined":"always"\}]
(foo): void => \{ return; \}

// Options: ["always",\{"annotateUndefined":"never"\}]
(foo) => \{ return; \}

// Options: ["always",\{"annotateUndefined":"never"\}]
(foo) => \{ return undefined; \}

// Options: ["always",\{"annotateUndefined":"never"\}]
(foo) => \{ return void 0; \}

// Options: ["always",\{"annotateUndefined":"always"\}]
(foo): undefined => \{ return undefined; \}

// Options: ["always",\{"annotateUndefined":"always"\}]
(foo): void => \{ return void 0; \}

// Options: ["always"]
(foo) => \{ return 1; \}

// Options: ["always",\{"annotateUndefined":"always"\}]
(foo) => \{ return undefined; \}

// Options: ["always",\{"annotateUndefined":"always"\}]
async function doThing(): Promise<void> \{\}

// Options: ["always",\{"annotateUndefined":"always"\}]
function* doThing(): Generator<number, void, void> \{ yield 2; \}

async (foo): Promise<number> => \{ return 3; \}

// Options: ["always",\{"excludeArrowFunctions":true\}]
() => 3

// Options: ["always",\{"excludeArrowFunctions":true\}]
() => \{ return 4; \}

// Options: ["always",\{"excludeArrowFunctions":true\}]
() => undefined

// Options: ["always",\{"annotateUndefined":"always","excludeArrowFunctions":true\}]
() => undefined

// Options: ["always",\{"annotateUndefined":"always","excludeArrowFunctions":true\}]
() => \{ return undefined; \}

// Options: ["always",\{"excludeArrowFunctions":"expressionsOnly"\}]
() => 3

// Options: ["always",\{"excludeArrowFunctions":"expressionsOnly"\}]
async () => 3

// Options: ["always",\{"excludeMatching":["foo"]\}]
function foo() \{ return 42; \}

// Options: ["always",\{"includeOnlyMatching":["bar"]\}]
function foo() \{ return 42; \}

// Options: ["always",\{"excludeMatching":["bar"]\}]
function foo(): number \{ return 42; \}
function bar() \{ return 42; \}

// Options: ["always",\{"includeOnlyMatching":["foo","baz"]\}]
function foo(): number \{ return 42; \}
function bar() \{ return 42; \}

// Options: ["always",\{"excludeMatching":["^b.*","qux"]\}]
function foo(): number \{ return 42; \}
function bar() \{ return 42; \}

// Options: ["always",\{"includeOnlyMatching":["^f.*"]\}]
function foo(): number \{ return 42; \}
function bar() \{ return 42; \}
\end{DoxyCode}


\label{_eslint-plugin-flowtype-rules-require-valid-file-annotation}%
 \subsubsection*{{\ttfamily require-\/valid-\/file-\/annotation}}

This rule validates Flow file annotations.

This rule can optionally report missing or missed placed annotations, common typos (e.\+g. {\ttfamily // @floww}), and enforce a consistant annotation style.

\label{_eslint-plugin-flowtype-rules-require-valid-file-annotation-options}%
 \paragraph*{Options}

The rule has a string option\+:


\begin{DoxyItemize}
\item {\ttfamily \char`\"{}never\char`\"{}} (default)\+: Never report files that are missing an {\ttfamily @flow} annotation.
\item {\ttfamily \char`\"{}always\char`\"{}}\+: Always report files that are missing an {\ttfamily @flow} annotation
\end{DoxyItemize}

This rule has an object option\+:


\begin{DoxyItemize}
\item {\ttfamily \char`\"{}annotation\+Style\char`\"{}} -\/ Enforce a consistant file annotation style.
\begin{DoxyItemize}
\item {\ttfamily \char`\"{}none\char`\"{}} (default)\+: Either annotation style is accepted.
\item {\ttfamily \char`\"{}line\char`\"{}}\+: Require single line annotations (i.\+e. {\ttfamily // @flow}).
\item {\ttfamily \char`\"{}block\char`\"{}}\+: Require block annotations (i.\+e. {\ttfamily /$\ast$ @flow $\ast$/}).
\end{DoxyItemize}
\end{DoxyItemize}


\begin{DoxyCode}
\{
  "rules": \{
    "flowtype/require-valid-file-annotation": [
      2,
      "always"
    ]
  \}
\}

\{
  "rules": \{
    "flowtype/require-valid-file-annotation": [
      2,
      "always", \{
        "annotationStyle": "block"
      \}
    ]
  \}
\}
\end{DoxyCode}


The following patterns are considered problems\+:

\`{}\`{}\`{}js ;//  // Message\+: Flow file annotation not at the top of the file.

; //  // Message\+: Flow file annotation not at the top of the file.

//  // Message\+: Malformed Flow file annotation.

//  // Message\+: Malformed Flow file annotation.

//  // Message\+: Malformed Flow file annotation.

//  // Message\+: Misspelled or malformed Flow file annotation.

//  // Message\+: Misspelled or malformed Flow file annotation.

// Options\+: \mbox{[}\char`\"{}always\char`\"{}\mbox{]} a; // Message\+: Flow file annotation is missing.

// Options\+: \mbox{[}\char`\"{}always\char`\"{},\{\char`\"{}annotation\+Style\char`\"{}\+:\char`\"{}line\char`\"{}\}\mbox{]} /$\ast$  $\ast$/ // Message\+: Flow file annotation style must be {\ttfamily // @flow}

// Options\+: \mbox{[}\char`\"{}always\char`\"{},\{\char`\"{}annotation\+Style\char`\"{}\+:\char`\"{}block\char`\"{}\}\mbox{]} //  // Message\+: Flow file annotation style must be {\ttfamily /$\ast$ @flow $\ast$/}

// Options\+: \mbox{[}\char`\"{}always\char`\"{},\{\char`\"{}annotation\+Style\char`\"{}\+:\char`\"{}line\char`\"{}\}\mbox{]} /$\ast$  $\ast$/ // Message\+: Flow file annotation style must be {\ttfamily // @noflow}

// Options\+: \mbox{[}\char`\"{}always\char`\"{},\{\char`\"{}annotation\+Style\char`\"{}\+:\char`\"{}block\char`\"{}\}\mbox{]} //  // Message\+: Flow file annotation style must be {\ttfamily /$\ast$ @noflow $\ast$/} 
\begin{DoxyCode}
The following patterns are not considered problems:

```js
a;

// @flow
a;

//@flow
a;

//**@flow
a;

/* foo @flow bar */
a;



// @flow
a;

// @flow
// @FLow

// @noflow
a;

// Options: ["always"]
a;

// Options: ["always",\{"annotationStyle":"line"\}]
// @flow

// Options: ["always",\{"annotationStyle":"block"\}]
/* @flow */
\end{DoxyCode}


\label{_eslint-plugin-flowtype-rules-require-variable-type}%
 \subsubsection*{{\ttfamily require-\/variable-\/type}}

Requires that all variable declarators have type annotations.

\label{_eslint-plugin-flowtype-rules-require-variable-type-options}%
 \paragraph*{Options}

You can exclude variables that match a certain regex by using {\ttfamily exclude\+Variable\+Match}.

This excludes all parameters that start with an underscore ({\ttfamily \+\_\+}). The default pattern is {\ttfamily a$^\wedge$}, which doesn\textquotesingle{}t match anything, i.\+e., all parameters are checked.


\begin{DoxyCode}
\{
    "rules": \{
        "flowtype/require-variable-type": [
            2,
            \{
              "excludeVariableMatch": "^\_"
            \}
        ]
    \}
\}
\end{DoxyCode}


You can choose specific variable types ({\ttfamily var}, {\ttfamily let}, and {\ttfamily const}) to ignore using {\ttfamily exclude\+Variable\+Types}.

This excludes {\ttfamily var} and {\ttfamily let} declarations from needing type annotations, but forces {\ttfamily const} declarations to have it. By default, all declarations are checked.


\begin{DoxyCode}
\{
    "rules": \{
        "flowtype/require-variable-type": [
            2,
            \{
              "excludeVariableTypes": \{
                "var": true,
                "let": true,
                "const": false,
              \}
            \}
        ]
    \}
\}
\end{DoxyCode}


The following patterns are considered problems\+:


\begin{DoxyCode}
var foo = "bar"
// Message: Missing "foo" variable type annotation.

var foo : string = "bar", bar = 1
// Message: Missing "bar" variable type annotation.

// Options: [\{"excludeVariableMatch":"^\_"\}]
var \_foo = "bar", bar = 1
// Message: Missing "bar" variable type annotation.

// Options: [\{"excludeVariableTypes":\{"let":false,"var":true\}\}]
var foo = "bar", bar = 1; const oob : string = "oob"; let hey = "yah"
// Message: Missing "hey" variable type annotation.
\end{DoxyCode}


The following patterns are not considered problems\+:


\begin{DoxyCode}
var foo : string = "bar"

var foo : string = "bar", bar : number = 1

// Options: [\{"excludeVariableMatch":"^\_"\}]
var \_foo = "bar", bar : number = 1

// Options: [\{"excludeVariableTypes":\{"var":true\}\}]
var foo = "bar", bar = 1

// Options: [\{"excludeVariableTypes":\{"let":true,"var":true\}\}]
var foo = "bar", bar = 1; const oob : string = "oob"; let hey = "yah"
\end{DoxyCode}


\label{_eslint-plugin-flowtype-rules-semi}%
 \subsubsection*{{\ttfamily semi}}

{\itshape The {\ttfamily -\/-\/fix} option on the command line automatically fixes problems reported by this rule.}

Enforces consistent use of semicolons after type aliases.

This rule takes one argument. If it is `\textquotesingle{}never'{\ttfamily then a problem is raised when there is a semicolon after a type alias. If it is}\textquotesingle{}always\textquotesingle{}\`{} then a problem is raised when there is no semicolon after a type alias.

The default value is `\textquotesingle{}always'\`{}.

The following patterns are considered problems\+:


\begin{DoxyCode}
// Options: []
type FooType = \{\}
// Message: Missing semicolon.

// Options: ["always"]
type FooType = \{\}
// Message: Missing semicolon.

// Options: ["never"]
type FooType = \{\};
// Message: Extra semicolon.
\end{DoxyCode}


The following patterns are not considered problems\+:


\begin{DoxyCode}
type FooType = \{\};

// Options: ["always"]
type FooType = \{\};

// Options: ["always"]
type FooType = \{ a: number;
 b: string;
 \};

// Options: ["never"]
type FooType = \{ a: number;
 b: string;
 \}

// Options: ["never"]
type FooType = \{\}

type FooType = \{\}
\end{DoxyCode}


\label{_eslint-plugin-flowtype-rules-sort-keys}%
 \subsubsection*{{\ttfamily sort-\/keys}}

Enforces sorting of Object annotations.

This rule mirrors E\+Slint\textquotesingle{}s \href{http://eslint.org/docs/rules/sort-keys}{\tt sort-\/keys} rule.

\label{_eslint-plugin-flowtype-rules-sort-keys-options}%
 \paragraph*{Options}

The first option specifies sort order.


\begin{DoxyItemize}
\item {\ttfamily \char`\"{}asc\char`\"{}} (default) -\/ enforce ascending sort order.
\item {\ttfamily \char`\"{}desc\char`\"{}} -\/ enforce descending sort order.
\end{DoxyItemize}

The second option takes an object with two possible properties.


\begin{DoxyItemize}
\item {\ttfamily case\+Sensitive} -\/ if {\ttfamily true}, enforce case-\/sensitive sort order. Default is {\ttfamily true}.
\item {\ttfamily natural} -\/ if {\ttfamily true}, enforce \href{https://en.wikipedia.org/wiki/Natural_sort_order}{\tt natural sort order}. Default is {\ttfamily false}.
\end{DoxyItemize}


\begin{DoxyCode}
\{
  "rules": \{
    "flowtype/sort-keys": [
      2,
      "asc", \{
        "caseSensitive": true,
        "natural": false
      \}
    ]
  \}
\}
\end{DoxyCode}


The following patterns are considered problems\+:


\begin{DoxyCode}
type FooType = \{ a: number, c: number, b: string \}
// Message: Expected type annotations to be in ascending order. "b" should be before "c".

type FooType = \{ a: number, b: number, C: number \}
// Message: Expected type annotations to be in ascending order. "C" should be before "b".

type FooType = \{ 1: number, 2: number, 10: number \}
// Message: Expected type annotations to be in ascending order. "10" should be before "2".

// Options: ["desc"]
type FooType = \{ a: number, b: number \}
// Message: Expected type annotations to be in descending order. "b" should be before "a".

// Options: ["desc"]
type FooType = \{ C: number, b: number, a: string \}
// Message: Expected type annotations to be in descending order. "b" should be before "C".

// Options: ["desc"]
type FooType = \{ 10: number, 2: number, 1: number \}
// Message: Expected type annotations to be in descending order. "2" should be before "10".

// Options: ["asc",\{"caseSensitive":false\}]
type FooType = \{ a: number, c: number, C: number, b: string \}
// Message: Expected type annotations to be in insensitive ascending order. "b" should be before "C".

// Options: ["asc",\{"caseSensitive":false\}]
type FooType = \{ a: number, C: number, c: number, b: string \}
// Message: Expected type annotations to be in insensitive ascending order. "b" should be before "c".

// Options: ["asc",\{"natural":true\}]
type FooType = \{ 1: number, 10: number, 2: boolean \}
// Message: Expected type annotations to be in natural ascending order. "2" should be before "10".
\end{DoxyCode}


The following patterns are not considered problems\+:


\begin{DoxyCode}
type FooType = \{ a: number \}

type FooType = \{ a: number, b: number, c: (boolean | number) \}

type FooType = \{ C: number, a: string, b: foo \}

type FooType = \{ 1: number, 10: number, 2: boolean \}

// Options: ["desc"]
type FooType = \{ c: number, b: number, a: number \}

// Options: ["desc"]
type FooType = \{ b: string, a: \{\}, C: number \}

// Options: ["desc"]
type FooType = \{ 2: number, 10: number, 1: boolean \}

// Options: ["asc",\{"caseSensitive":false\}]
type FooType = \{ a: number, b: number, c: number, C: number \}

// Options: ["asc",\{"caseSensitive":false\}]
type FooType = \{ a: number, b: number, C: number, c: number \}

// Options: ["asc",\{"natural":true\}]
type FooType = \{ 1:number, 2: number, 10: number \}

type FooType = \{ b: number, a: number \}
\end{DoxyCode}


\label{_eslint-plugin-flowtype-rules-space-after-type-colon}%
 \subsubsection*{{\ttfamily space-\/after-\/type-\/colon}}

{\itshape The {\ttfamily -\/-\/fix} option on the command line automatically fixes problems reported by this rule.}

Enforces consistent spacing after the type annotation colon.

\label{_eslint-plugin-flowtype-rules-space-after-type-colon-options}%
 \paragraph*{Options}

This rule has a string argument.


\begin{DoxyItemize}
\item {\ttfamily \char`\"{}always\char`\"{}} (default)\+: Require a space after the type annotation colon (e.\+g. foo\+: Bar\+Type).
\item {\ttfamily \char`\"{}never\char`\"{}}\+: Require no spaces after the type annotation colon (e.\+g. foo\+:Bar\+Type).
\end{DoxyItemize}

This rule has an option object.


\begin{DoxyItemize}
\item {\ttfamily \char`\"{}allow\+Line\+Break\char`\"{}} -\/ Allow a line break to count as a space following the annotation colon.
\begin{DoxyItemize}
\item {\ttfamily \char`\"{}true\char`\"{}}\+: Enable
\item {\ttfamily \char`\"{}false\char`\"{}}\+: Disable
\end{DoxyItemize}
\end{DoxyItemize}

\{ \char`\"{}rules\char`\"{}\+: \{ \char`\"{}flowtype/space-\/after-\/type-\/colon\char`\"{}\+: \mbox{[} 2, \char`\"{}always\char`\"{}, \{ \char`\"{}allow\+Line\+Break\char`\"{}\+: false \} \mbox{]} \} \}

The following patterns are considered problems\+:


\begin{DoxyCode}
// Options: ["never"]
(foo: string) => \{\}
// Message: There must be no space after "foo" parameter type annotation colon.

// Options: ["always"]
(foo:  string) => \{\}
// Message: There must be 1 space after "foo" parameter type annotation colon.

// Options: ["always"]
(foo:(() => void)) => \{\}
// Message: There must be a space after "foo" parameter type annotation colon.

// Options: ["never"]
(foo: (() => void)) => \{\}
// Message: There must be no space after "foo" parameter type annotation colon.

// Options: ["always"]
(foo:  (() => void)) => \{\}
// Message: There must be 1 space after "foo" parameter type annotation colon.

(\{ lorem, ipsum, dolor \} :   SomeType) => \{\}
// Message: There must be 1 space after "\{ lorem, ipsum, dolor \}" parameter type annotation colon.

(foo:\{ a: string, b: number \}) => \{\}
// Message: There must be a space after "foo" parameter type annotation colon.

(\{ a, b \} :\{ a: string, b: number \}) => \{\}
// Message: There must be a space after "\{ a, b \}" parameter type annotation colon.

([ a, b ] :string[]) => \{\}
// Message: There must be a space after "[ a, b ]" parameter type annotation colon.

(i?:number) => \{\}
// Message: There must be a space after "i" parameter type annotation colon.

(i?:  number) => \{\}
// Message: There must be 1 space after "i" parameter type annotation colon.

// Options: ["never"]
(i?: number) => \{\}
// Message: There must be no space after "i" parameter type annotation colon.

(foo:
  \{ a: string, b: number \}) => \{\}
// Message: There must be 1 space after "foo" parameter type annotation colon.

// Options: ["always"]
():Object => \{\}
// Message: There must be a space after return type colon.

// Options: ["never"]
(): Object => \{\}
// Message: There must be no space after return type colon.

// Options: ["always"]
():  Object => \{\}
// Message: There must be 1 space after return type colon.

// Options: ["always"]
():(() => void) => \{\}
// Message: There must be a space after return type colon.

// Options: ["never"]
(): (() => void) => \{\}
// Message: There must be no space after return type colon.

// Options: ["always"]
():  (() => void) => \{\}
// Message: There must be 1 space after return type colon.

// Options: ["never"]
export default function (foo: string) \{\}
// Message: There must be no space after "foo" parameter type annotation colon.

// Options: ["never"]
function foo (foo: string) \{\}
// Message: There must be no space after "foo" parameter type annotation colon.

// Options: ["always"]
(foo:string) => \{\}
// Message: There must be a space after "foo" parameter type annotation colon.

function foo (foo:string) \{\}
// Message: There must be a space after "foo" parameter type annotation colon.

async function foo(\{ lorem, ipsum, dolor \}:SomeType) \{\}
// Message: There must be a space after "\{ lorem, ipsum, dolor \}" parameter type annotation colon.

function x(i?:number) \{\}
// Message: There must be a space after "i" parameter type annotation colon.

function x(i?:  number) \{\}
// Message: There must be 1 space after "i" parameter type annotation colon.

// Options: ["never"]
function x(i?: number) \{\}
// Message: There must be no space after "i" parameter type annotation colon.

function a():x \{\}
// Message: There must be a space after return type colon.

// Options: ["always"]
function a():  x \{\}
// Message: There must be 1 space after return type colon.

// Options: ["never"]
function a(): x \{\}
// Message: There must be no space after return type colon.

type X = (foo:number) => string
// Message: There must be a space after "foo" parameter type annotation colon.

// Options: ["never"]
type X = (foo: number) => string
// Message: There must be no space after "foo" parameter type annotation colon.

type X = (foo:  number) => string
// Message: There must be 1 space after "foo" parameter type annotation colon.

type X = (foo:?number) => string
// Message: There must be a space after "foo" parameter type annotation colon.

type X = (foo:(number)) => string
// Message: There must be a space after "foo" parameter type annotation colon.

type X = (foo:((number))) => string
// Message: There must be a space after "foo" parameter type annotation colon.

type X = (foo:  ((number))) => string
// Message: There must be 1 space after "foo" parameter type annotation colon.

// Options: ["never"]
type X = (foo: ((number))) => string
// Message: There must be no space after "foo" parameter type annotation colon.

type X = (foo:?(number)) => string
// Message: There must be a space after "foo" parameter type annotation colon.

type TArrayPredicate = (el: T, i?:number) => boolean
// Message: There must be a space after "i" parameter type annotation colon.

type TArrayPredicate = (el: T, i?:  number) => boolean
// Message: There must be 1 space after "i" parameter type annotation colon.

// Options: ["never"]
type TArrayPredicate = (el:T, i?: number) => boolean
// Message: There must be no space after "i" parameter type annotation colon.

class X \{ foo:string \}
// Message: There must be a space after "foo" class property type annotation colon.

// Options: ["never"]
class X \{ foo: string \}
// Message: There must be no space after "foo" class property type annotation colon.

class X \{ foo:?string \}
// Message: There must be a space after "foo" class property type annotation colon.

// Options: ["never"]
class X \{ foo: ?string \}
// Message: There must be no space after "foo" class property type annotation colon.

class X \{ static foo:number \}
// Message: There must be a space after "foo" class property type annotation colon.

// Options: ["never"]
class X \{ static foo: number \}
// Message: There must be no space after "foo" class property type annotation colon.

class X \{ static foo :number \}
// Message: There must be a space after "foo" class property type annotation colon.

// Options: ["never"]
class X \{ static foo : number \}
// Message: There must be no space after "foo" class property type annotation colon.

declare class X \{ static foo:number \}
// Message: There must be a space after "foo" type annotation colon.

// Options: ["never"]
declare class X \{ static foo: number \}
// Message: There must be no space after "foo" type annotation colon.

declare class X \{ static foo :number \}
// Message: There must be a space after "foo" type annotation colon.

// Options: ["never"]
declare class X \{ static foo : number \}
// Message: There must be no space after "foo" type annotation colon.

class X \{ +foo:string \}
// Message: There must be a space after "foo" class property type annotation colon.

class X \{ +foo:  string \}
// Message: There must be 1 space after "foo" class property type annotation colon.

// Options: ["never"]
class X \{ +foo: string \}
// Message: There must be no space after "foo" class property type annotation colon.

class X \{ static +foo:string \}
// Message: There must be a space after "foo" class property type annotation colon.

class X \{ static +foo:  string \}
// Message: There must be 1 space after "foo" class property type annotation colon.

// Options: ["never"]
class X \{ static +foo: string \}
// Message: There must be no space after "foo" class property type annotation colon.

type X = \{ foo:string \}
// Message: There must be a space after "foo" type annotation colon.

// Options: ["always"]
type X = \{ foo:string \}
// Message: There must be a space after "foo" type annotation colon.

// Options: ["never"]
type X = \{ foo: string \}
// Message: There must be no space after "foo" type annotation colon.

type X = \{ foo:  string \}
// Message: There must be 1 space after "foo" type annotation colon.

type X = \{ foo?:string \}
// Message: There must be a space after "foo" type annotation colon.

// Options: ["never"]
type X = \{ foo?: string \}
// Message: There must be no space after "foo" type annotation colon.

type X = \{ foo?:?string \}
// Message: There must be a space after "foo" type annotation colon.

type X = \{ foo?:  ?string \}
// Message: There must be 1 space after "foo" type annotation colon.

type Foo = \{ barType:(string | () => void) \}
// Message: There must be a space after "barType" type annotation colon.

type Foo = \{ barType:(((string | () => void))) \}
// Message: There must be a space after "barType" type annotation colon.

// Options: ["never"]
type Foo = \{ barType: (string | () => void) \}
// Message: There must be no space after "barType" type annotation colon.

type Foo = \{ barType:  (string | () => void) \}
// Message: There must be 1 space after "barType" type annotation colon.

type Foo = \{ barType:  ((string | () => void)) \}
// Message: There must be 1 space after "barType" type annotation colon.

type X = \{ get:() => A; \}
// Message: There must be a space after "get" type annotation colon.

type X = \{ get:<X>() => A; \}
// Message: There must be a space after "get" type annotation colon.

// Options: ["never"]
type X = \{ get: () => A; \}
// Message: There must be no space after "get" type annotation colon.

// Options: ["never"]
type X = \{ get: <X>() => A; \}
// Message: There must be no space after "get" type annotation colon.

type X = \{ get:  () => A; \}
// Message: There must be 1 space after "get" type annotation colon.

type X = \{ get:  <X>() => A; \}
// Message: There must be 1 space after "get" type annotation colon.

type X = \{ +foo:string \}
// Message: There must be a space after "foo" type annotation colon.

type X = \{ +foo:  string \}
// Message: There must be 1 space after "foo" type annotation colon.

// Options: ["never"]
type X = \{ +foo: string \}
// Message: There must be no space after "foo" type annotation colon.

type X = \{ +foo?:string \}
// Message: There must be a space after "foo" type annotation colon.

type X = \{ +foo?:  string \}
// Message: There must be 1 space after "foo" type annotation colon.

// Options: ["never"]
type X = \{ +foo?: string \}
// Message: There must be no space after "foo" type annotation colon.

// Options: ["always"]
type X = \{ [a:b]: c \}
// Message: There must be a space after type annotation colon.

// Options: ["never"]
type X = \{ [a: b]:c \}
// Message: There must be no space after type annotation colon.

// Options: ["always"]
type X = \{ [a:    b]: c \}
// Message: There must be 1 space after type annotation colon.

// Options: ["always"]
type X = \{ +[a:b]: c \}
// Message: There must be a space after type annotation colon.

// Options: ["never"]
type X = \{ +[a: b]:c \}
// Message: There must be no space after type annotation colon.

// Options: ["always"]
type X = \{ +[a:    b]: c \}
// Message: There must be 1 space after type annotation colon.

// Options: ["always"]
type X = \{ [a: b]:c \}
// Message: There must be a space after type annotation colon.

// Options: ["never"]
type X = \{ [a:b]: c \}
// Message: There must be no space after type annotation colon.

// Options: ["always"]
type X = \{ [a: b]:    c \}
// Message: There must be 1 space after type annotation colon.

// Options: ["always"]
type X = \{ [a:b]:c \}
// Message: There must be a space after type annotation colon.
// Message: There must be a space after type annotation colon.

// Options: ["never"]
type X = \{ [a: b]: c \}
// Message: There must be no space after type annotation colon.
// Message: There must be no space after type annotation colon.

// Options: ["always"]
type X = \{ [a:  b]:  c \}
// Message: There must be 1 space after type annotation colon.
// Message: There must be 1 space after type annotation colon.

// Options: ["always"]
type X = \{ [a:(b)]:(c) \}
// Message: There must be a space after type annotation colon.
// Message: There must be a space after type annotation colon.

// Options: ["never"]
type X = \{ [a: (b)]: (c) \}
// Message: There must be no space after type annotation colon.
// Message: There must be no space after type annotation colon.

// Options: ["never"]
const x = (\{\}: \{\})
// Message: There must be no space after type cast colon.

// Options: ["always"]
const x = (\{\}:\{\})
// Message: There must be a space after type cast colon.

// Options: ["always"]
const x = (\{\}:  \{\})
// Message: There must be 1 space after type cast colon.

// Options: ["never"]
((x): (string))
// Message: There must be no space after type cast colon.

// Options: ["always"]
((x):(string))
// Message: There must be a space after type cast colon.

// Options: ["always"]
((x):  (string))
// Message: There must be 1 space after type cast colon.
\end{DoxyCode}


The following patterns are not considered problems\+:


\begin{DoxyCode}
(foo) => \{\}

(foo: string) => \{\}

(foo: (string|number)) => \{\}

// Options: ["never"]
(foo:string) => \{\}

// Options: ["always"]
(foo: string) => \{\}

// Options: ["never"]
(foo:(() => void)) => \{\}

// Options: ["always"]
(foo: (() => void)) => \{\}

(\{ lorem, ipsum, dolor \}: SomeType) => \{\}

(foo: \{ a: string, b: number \}) => \{\}

(\{ a, b \}: ?\{ a: string, b: number \}) => \{\}

([ a, b ]: string[]) => \{\}

(i?: number) => \{\}

// Options: ["never"]
(i?:number) => \{\}

// Options: ["always",\{"allowLineBreak":true\}]
(foo:
  \{ a: string, b: number \}) => \{\}

// Options: ["always",\{"allowLineBreak":true\}]
(foo:
  \{ a: string, b: number \}) => \{\}

// Options: ["never"]
():Object => \{\}

// Options: ["always"]
(): Object => \{\}

// Options: ["never"]
():(number | string) => \{\}

// Options: ["always"]
(): (number | string) => \{\}

// Options: ["never"]
():number|string => \{\}

// Options: ["always"]
(): number|string => \{\}

// Options: ["never"]
():(() => void) => \{\}

// Options: ["always"]
(): (() => void) => \{\}

// Options: ["never"]
():( () => void ) => \{\}

// Options: ["always"]
(): ( () => void ) => \{\}

(): \{ a: number, b: string \} => \{\}

// Options: ["never"]
() :\{ a:number, b:string \} => \{\}

function x(foo: string) \{\}

class Foo \{ constructor(foo: string) \{\} \}

// Options: ["never"]
function x(foo:string) \{\}

// Options: ["never"]
class Foo \{ constructor(foo:string) \{\} \}

async function foo(\{ lorem, ipsum, dolor \}: SomeType) \{\}

function x(\{ a, b \}: \{ a: string, b: number \}) \{\}

function x(i?: number) \{\}

// Options: ["never"]
function x(i?:number) \{\}

function a(): x \{\}

// Options: ["never"]
function a():x \{\}

function a(): (number | string) \{\}

// Options: ["never"]
function a() :(number | string) \{\}

type X = (foo: number) => string;

type X = (foo : number) => string;

type X = (foo: ?number) => string;

type X = (foo? : ?number) => string;

type X = (foo: ?\{ x: number \}) => string;

// Options: ["never"]
type X = (foo:number) => string;

// Options: ["never"]
type X = (foo:?\{ x:number \}) => string;

type X = (foo: (number)) => string

type X = (foo: ((number))) => string

// Options: ["never"]
type X = (foo:((number))) => string

type X = ?(foo: ((number))) => string

// Options: ["never"]
type X = ?(foo:((number))) => string

type TArrayPredicate = (el: T, i?: number) => boolean

// Options: ["never"]
type TArrayPredicate = (el:T, i?:number) => boolean

type X = (number) => string;

type X = (?number) => string;

type X = number => string;

type X = ?number => string;

type X = (\{ foo: bar \}) => string;

// Options: ["always"]
type X = (number) => string;

// Options: ["always"]
type X = (?number) => string;

// Options: ["always"]
type X = number => string;

// Options: ["always"]
type X = ?number => string;

// Options: ["always"]
type X = (\{ foo: bar \}) => string;

class Foo \{ bar \}

class Foo \{ bar = 3 \}

class Foo \{ bar: string \}

class Foo \{ bar: ?string \}

// Options: ["never"]
class Foo \{ bar:string \}

// Options: ["never"]
class Foo \{ bar:?string \}

class X \{ static foo : number \}

// Options: ["never"]
class X \{ static foo :number \}

declare class X \{ static foo : number \}

// Options: ["never"]
declare class X \{ static foo :number \}

class X \{ +foo: string \}

class X \{ static +foo: string \}

// Options: ["never"]
class X \{ +foo:string \}

// Options: ["never"]
class X \{ static +foo:string \}

type X = \{ foo: string \}

// Options: ["never"]
type X = \{ foo:string \}

type X = \{ foo?: string \}

type X = \{ foo?: ?string \}

// Options: ["never"]
type X = \{ foo?:?string \}

type Foo = \{ barType: (string | () => void) \}

type Foo = \{ barType: ((string | () => void)) \}

// Options: ["never"]
type Foo = \{ barType:(string | () => void) \}

// Options: ["never"]
type Foo = \{ barType:((string | () => void)) \}

type X = \{ get(): A; \}

type X = \{ get<X>(): A; \}

// Options: ["never"]
type X = \{ get(): A; \}

// Options: ["never"]
type X = \{ get<X>(): A; \}

type X = \{ get: () => A; \}

type X = \{ get: <X>() => A; \}

// Options: ["never"]
type X = \{ get:() => A; \}

// Options: ["never"]
type X = \{ get:<X>() => A; \}

type X = \{ +foo: string \}

type X = \{ +foo?: string \}

// Options: ["never"]
type X = \{ +foo:string \}

// Options: ["never"]
type X = \{ +foo?:string \}

// Options: ["always"]
type X = \{ [a: b]: c \}

// Options: ["never"]
type X = \{ [a:b]:c \}

// Options: ["always"]
type X = \{ +[a: b]: c \}

// Options: ["never"]
type X = \{ +[a:b]:c \}

// Options: ["always"]
type X = \{ [string]: c \}

// Options: ["never"]
type X = \{ [string]:c \}

// Options: ["never"]
const x = (\{\}:\{\})

// Options: ["always"]
const x = (\{\}: \{\})

// Options: ["never"]
((x):(string))

// Options: ["always"]
((x): (string))
\end{DoxyCode}


\label{_eslint-plugin-flowtype-rules-space-before-generic-bracket}%
 \subsubsection*{{\ttfamily space-\/before-\/generic-\/bracket}}

{\itshape The {\ttfamily -\/-\/fix} option on the command line automatically fixes problems reported by this rule.}

Enforces consistent spacing before the opening {\ttfamily $<$} of generic type annotation parameters.

This rule takes one argument. If it is `\textquotesingle{}never'{\ttfamily then a problem is raised when there is a space before the}$<${\ttfamily . If it is}\textquotesingle{}always\textquotesingle{}{\ttfamily then a problem is raised when there is no space before the}$<$\`{}.

The default value is `\textquotesingle{}never'\`{}.

The following patterns are considered problems\+:


\begin{DoxyCode}
type X = Promise <string>
// Message: There must be no space before "Promise" generic type annotation bracket

// Options: ["never"]
type X = Promise <string>
// Message: There must be no space before "Promise" generic type annotation bracket

type X = Promise  <string>
// Message: There must be no space before "Promise" generic type annotation bracket

// Options: ["always"]
type X = Promise<string>
// Message: There must be a space before "Promise" generic type annotation bracket

// Options: ["always"]
type X = Promise  <string>
// Message: There must be one space before "Promise" generic type annotation bracket
\end{DoxyCode}


The following patterns are not considered problems\+:


\begin{DoxyCode}
type X = Promise<string>

// Options: ["always"]
type X = Promise <string>
\end{DoxyCode}


\label{_eslint-plugin-flowtype-rules-space-before-type-colon}%
 \subsubsection*{{\ttfamily space-\/before-\/type-\/colon}}

{\itshape The {\ttfamily -\/-\/fix} option on the command line automatically fixes problems reported by this rule.}

Enforces consistent spacing before the type annotation colon.

This rule takes one argument. If it is `\textquotesingle{}always'{\ttfamily then a problem is raised when there is no space before the type annotation colon. If it is}\textquotesingle{}never\textquotesingle{}{\ttfamily then a problem is raised when there is a space before the type annotation colon. The default value is}\textquotesingle{}never\textquotesingle{}\`{}.

The following patterns are considered problems\+:


\begin{DoxyCode}
// Options: ["never"]
(foo : string) => \{\}
// Message: There must be no space before "foo" parameter type annotation colon.

// Options: ["never"]
(foo ? : string) => \{\}
// Message: There must be no space before "foo" parameter type annotation colon.

// Options: ["always"]
(foo: string) => \{\}
// Message: There must be a space before "foo" parameter type annotation colon.

// Options: ["always"]
(foo  : string) => \{\}
// Message: There must be 1 space before "foo" parameter type annotation colon.

// Options: ["always"]
(foo?: string) => \{\}
// Message: There must be a space before "foo" parameter type annotation colon.

// Options: ["always"]
(foo ?  : string) => \{\}
// Message: There must be 1 space before "foo" parameter type annotation colon.

// Options: ["always"]
(foo  ?: string) => \{\}
// Message: There must be a space before "foo" parameter type annotation colon.

(\{ lorem, ipsum, dolor \} : SomeType) => \{\}
// Message: There must be no space before "\{ lorem, ipsum, dolor \}" parameter type annotation colon.

(foo : \{ a: string, b: number \}) => \{\}
// Message: There must be no space before "foo" parameter type annotation colon.

(\{ a, b \} : \{ a: string, b: number \}) => \{\}
// Message: There must be no space before "\{ a, b \}" parameter type annotation colon.

([ a, b ] : string[]) => \{\}
// Message: There must be no space before "[ a, b ]" parameter type annotation colon.

() : x => \{\}
// Message: There must be no space before return type colon.

// Options: ["always"]
(): x => \{\}
// Message: There must be a space before return type colon.

// Options: ["always"]
()  : x => \{\}
// Message: There must be 1 space before return type colon.

function x(foo : string) \{\}
// Message: There must be no space before "foo" parameter type annotation colon.

// Options: ["always"]
function x(foo: string) \{\}
// Message: There must be a space before "foo" parameter type annotation colon.

var x = function (foo : string) \{\}
// Message: There must be no space before "foo" parameter type annotation colon.

// Options: ["always"]
var x = function (foo: string) \{\}
// Message: There must be a space before "foo" parameter type annotation colon.

class Foo \{ constructor(foo : string ) \{\} \}
// Message: There must be no space before "foo" parameter type annotation colon.

// Options: ["always"]
class Foo \{ constructor(foo: string ) \{\} \}
// Message: There must be a space before "foo" parameter type annotation colon.

async function foo(\{ lorem, ipsum, dolor \} : SomeType) \{\}
// Message: There must be no space before "\{ lorem, ipsum, dolor \}" parameter type annotation colon.

function a() : x \{\}
// Message: There must be no space before return type colon.

// Options: ["always"]
function a(): x \{\}
// Message: There must be a space before return type colon.

// Options: ["always"]
function a()  : x \{\}
// Message: There must be 1 space before return type colon.

type X = (foo :string) => string;
// Message: There must be no space before "foo" parameter type annotation colon.

// Options: ["always"]
type X = (foo:string) => string;
// Message: There must be a space before "foo" parameter type annotation colon.

// Options: ["always"]
type X = (foo  :string) => string;
// Message: There must be 1 space before "foo" parameter type annotation colon.

type X = (foo? :string) => string;
// Message: There must be no space before "foo" parameter type annotation colon.

type X = (foo?     :string) => string;
// Message: There must be no space before "foo" parameter type annotation colon.

// Options: ["always"]
type X = (foo?:string) => string;
// Message: There must be a space before "foo" parameter type annotation colon.

type X = (foo? :?string) => string;
// Message: There must be no space before "foo" parameter type annotation colon.

class X \{ foo :string \}
// Message: There must be no space before "foo" class property type annotation colon.

// Options: ["always"]
class X \{ foo: string \}
// Message: There must be a space before "foo" class property type annotation colon.

class X \{ foo :?string \}
// Message: There must be no space before "foo" class property type annotation colon.

// Options: ["always"]
class X \{ foo: ?string \}
// Message: There must be a space before "foo" class property type annotation colon.

class X \{ static foo : number \}
// Message: There must be no space before "foo" class property type annotation colon.

class X \{ static foo :number \}
// Message: There must be no space before "foo" class property type annotation colon.

// Options: ["always"]
class X \{ static foo: number \}
// Message: There must be a space before "foo" class property type annotation colon.

// Options: ["always"]
class X \{ static foo:number \}
// Message: There must be a space before "foo" class property type annotation colon.

declare class Foo \{ static bar :number; \}
// Message: There must be no space before "bar" type annotation colon.

declare class Foo \{ static bar : number; \}
// Message: There must be no space before "bar" type annotation colon.

// Options: ["always"]
declare class Foo \{ static bar:number; \}
// Message: There must be a space before "bar" type annotation colon.

// Options: ["always"]
declare class Foo \{ static bar: number; \}
// Message: There must be a space before "bar" type annotation colon.

// Options: ["always"]
class X \{ +foo: string \}
// Message: There must be a space before "foo" class property type annotation colon.

// Options: ["always"]
class X \{ +foo  : string \}
// Message: There must be 1 space before "foo" class property type annotation colon.

// Options: ["never"]
class X \{ +foo : string \}
// Message: There must be no space before "foo" class property type annotation colon.

// Options: ["always"]
class X \{ static +foo: string \}
// Message: There must be a space before "foo" class property type annotation colon.

// Options: ["always"]
class X \{ static +foo  : string \}
// Message: There must be 1 space before "foo" class property type annotation colon.

// Options: ["never"]
class X \{ static +foo : string \}
// Message: There must be no space before "foo" class property type annotation colon.

type X = \{ foo : string \}
// Message: There must be no space before "foo" type annotation colon.

// Options: ["never"]
type X = \{ foo : string \}
// Message: There must be no space before "foo" type annotation colon.

// Options: ["always"]
type X = \{ foo: string \}
// Message: There must be a space before "foo" type annotation colon.

// Options: ["always"]
type X = \{ foo  : string \}
// Message: There must be 1 space before "foo" type annotation colon.

type X = \{ foo? : string \}
// Message: There must be no space before "foo" type annotation colon.

// Options: ["always"]
type X = \{ foo?: string \}
// Message: There must be a space before "foo" type annotation colon.

// Options: ["always"]
type X = \{ foo?  : string \}
// Message: There must be 1 space before "foo" type annotation colon.

// Options: ["always"]
type X = \{ foo   ?: string \}
// Message: There must be a space before "foo" type annotation colon.

// Options: ["always"]
type X = \{ +foo: string \}
// Message: There must be a space before "foo" type annotation colon.

// Options: ["always"]
type X = \{ +foo  : string \}
// Message: There must be 1 space before "foo" type annotation colon.

// Options: ["never"]
type X = \{ +foo : string \}
// Message: There must be no space before "foo" type annotation colon.

// Options: ["always"]
type X = \{ +foo?: string \}
// Message: There must be a space before "foo" type annotation colon.

// Options: ["always"]
type X = \{ +foo?  : string \}
// Message: There must be 1 space before "foo" type annotation colon.

// Options: ["never"]
type X = \{ +foo? : string \}
// Message: There must be no space before "foo" type annotation colon.

// Options: ["always"]
type X = \{ [a: b] : c \}
// Message: There must be a space before type annotation colon.

// Options: ["never"]
type X = \{ [a : b]: c \}
// Message: There must be no space before type annotation colon.

// Options: ["always"]
type X = \{ [a  : b] : c \}
// Message: There must be 1 space before type annotation colon.

// Options: ["always"]
type X = \{ +[a:b] : c \}
// Message: There must be a space before type annotation colon.

// Options: ["never"]
type X = \{ +[a : b]: c \}
// Message: There must be no space before type annotation colon.

// Options: ["always"]
type X = \{ +[a  : b] : c \}
// Message: There must be 1 space before type annotation colon.

// Options: ["always"]
type X = \{ [a : b]: c \}
// Message: There must be a space before type annotation colon.

// Options: ["never"]
type X = \{ [a: b] : c \}
// Message: There must be no space before type annotation colon.

// Options: ["always"]
type X = \{ [a : b]  : c \}
// Message: There must be 1 space before type annotation colon.

// Options: ["always"]
type X = \{ [a:b]:c \}
// Message: There must be a space before type annotation colon.
// Message: There must be a space before type annotation colon.

// Options: ["never"]
type X = \{ [a : b] : c \}
// Message: There must be no space before type annotation colon.
// Message: There must be no space before type annotation colon.

// Options: ["always"]
type X = \{ [a  : b]  : c \}
// Message: There must be 1 space before type annotation colon.
// Message: There must be 1 space before type annotation colon.

// Options: ["always"]
type X = \{ [a:(b)]:(c) \}
// Message: There must be a space before type annotation colon.
// Message: There must be a space before type annotation colon.

// Options: ["never"]
type X = \{ [a : (b)] : (c) \}
// Message: There must be no space before type annotation colon.
// Message: There must be no space before type annotation colon.

// Options: ["never"]
const x = (\{\} :\{\})
// Message: There must be no space before type cast colon.

// Options: ["always"]
const x = (\{\}:\{\})
// Message: There must be a space before type cast colon.

// Options: ["always"]
const x = (\{\}  :\{\})
// Message: There must be 1 space before type cast colon.

// Options: ["never"]
((x) : string)
// Message: There must be no space before type cast colon.

// Options: ["always"]
((x): string)
// Message: There must be a space before type cast colon.

// Options: ["always"]
((x)  : string)
// Message: There must be 1 space before type cast colon.
\end{DoxyCode}


The following patterns are not considered problems\+:


\begin{DoxyCode}
(foo) => \{\}

(foo: string) => \{\}

(foo?: string) => \{\}

(foo ?: string) => \{\}

// Options: ["never"]
(foo: string) => \{\}

// Options: ["always"]
(foo : string) => \{\}

// Options: ["always"]
(foo? : string) => \{\}

// Options: ["always"]
(foo ? : string) => \{\}

// Options: ["always"]
(foo  ? : string) => \{\}

(\{ lorem, ipsum, dolor \}: SomeType) => \{\}

(foo: \{ a: string, b: number \}) => \{\}

(\{ a, b \}: ?\{ a: string, b: number \}) => \{\}

(): \{ a: number, b: string \} => \{\}

// Options: ["always"]
() : \{ a : number, b : string \} => \{\}

([ a, b ]: string[]) => \{\}

(): x => \{\}

// Options: ["always"]
() : x => \{\}

(): (number | string) => \{\}

// Options: ["always"]
() : (number | string) => \{\}

function x(foo: string) \{\}

// Options: ["always"]
function x(foo : string) \{\}

var x = function (foo: string) \{\}

// Options: ["always"]
var x = function (foo : string) \{\}

class X \{ foo(\{ bar \}: Props = this.props) \{\} \}

class Foo \{ constructor(foo: string ) \{\} \}

// Options: ["always"]
class Foo \{ constructor(foo : string ) \{\} \}

async function foo(\{ lorem, ipsum, dolor \}: SomeType) \{\}

function x(\{ a, b \}: \{ a: string, b: number \}) \{\}

function a(): x \{\}

// Options: ["always"]
function a() : x \{\}

function a(): (number | string) \{\}

// Options: ["always"]
function a() : (number | string) \{\}

type X = (foo:string) => number;

type X = (foo: string) => number;

type X = (foo: ?string) => number;

type X = (foo?: string) => number;

type X = (foo?: ?string) => number;

type X = (foo   ?: string) => number;

// Options: ["always"]
type X = (foo? : string) => number

// Options: ["always"]
type X = (foo? : ?string) => number

type X = (number) => string;

type X = (?number) => string;

type X = number => string;

type X = ?number => string;

type X = (\{ foo: bar \}) => string;

// Options: ["always"]
type X = (number) => string;

// Options: ["always"]
type X = (?number) => string;

// Options: ["always"]
type X = number => string;

// Options: ["always"]
type X = ?number => string;

// Options: ["always"]
type X = (\{ foo : bar \}) => string;

class Foo \{ bar \}

class Foo \{ bar = 3 \}

class Foo \{ bar: string \}

class Foo \{ bar: ?string \}

class Foo \{ bar:?string \}

// Options: ["always"]
class Foo \{ bar : string \}

class X \{ static foo:number \}

class X \{ static foo: number \}

// Options: ["always"]
class X \{ static foo :number \}

// Options: ["always"]
class X \{ static foo : number \}

declare class Foo \{ static bar:number; \}

// Options: ["always"]
declare class Foo \{ static bar :number; \}

declare class Foo \{ static bar: number; \}

// Options: ["always"]
declare class Foo \{ static bar : number; \}

class X \{ +foo: string \}

class X \{ static +foo: string \}

// Options: ["always"]
class X \{ +foo : string \}

// Options: ["always"]
class X \{ static +foo : string \}

type X = \{ foo: string \}

// Options: ["always"]
type X = \{ foo : string \}

type X = \{ foo?: string \}

type X = \{ foo   ?: string \}

// Options: ["always"]
type X = \{ foo? : string \}

type X = \{ +foo: string \}

type X = \{ +foo?: string \}

// Options: ["always"]
type X = \{ +foo : string \}

// Options: ["always"]
type X = \{ +foo? : string \}

// Options: ["always"]
type X = \{ [a : b] : c \}

// Options: ["never"]
type X = \{ [a:b]:c \}

// Options: ["always"]
type X = \{ [string] : c \}

// Options: ["never"]
type X = \{ [string]:c \}

// Options: ["always"]
type X = \{ +[a : b] : c \}

// Options: ["never"]
type X = \{ +[a:b]:c \}

// Options: ["always"]
type X = \{ [a : (b)] : (c) \}

// Options: ["never"]
type X = \{ [a:(b)]:(c) \}

// Options: ["never"]
const x = (\{\}:\{\})

// Options: ["always"]
const x = (\{\} :\{\})

// Options: ["never"]
((x): string)

// Options: ["always"]
((x) : string)
\end{DoxyCode}


\label{_eslint-plugin-flowtype-rules-type-id-match}%
 \subsubsection*{{\ttfamily type-\/id-\/match}}

Enforces a consistent naming pattern for type aliases.

\label{_eslint-plugin-flowtype-rules-type-id-match-options}%
 \paragraph*{Options}

This rule needs a text Reg\+Exp to operate with Its signature is as follows\+:


\begin{DoxyCode}
\{
    "rules": \{
        "flowtype/type-id-match": [
            2,
            "^([A-Z][a-z0-9]*)+Type$"
        ]
    \}
\}
\end{DoxyCode}


`'$^\wedge$(\mbox{[}A-\/Z\mbox{]}\mbox{[}a-\/z0-\/9\mbox{]}$\ast$)+\+Type\$\textquotesingle{}\`{} is the default pattern.

The following patterns are considered problems\+:


\begin{DoxyCode}
type foo = \{\};
// Message: Type identifier 'foo' does not match pattern '/^([A-Z][a-z0-9]*)+Type$/'.

// Options: ["^foo$"]
type FooType = \{\};
// Message: Type identifier 'FooType' does not match pattern '/^foo$/'.
\end{DoxyCode}


The following patterns are not considered problems\+:


\begin{DoxyCode}
type FooType = \{\};

// Options: ["^foo$"]
type foo = \{\};

type foo = \{\};
\end{DoxyCode}


\label{_eslint-plugin-flowtype-rules-union-intersection-spacing}%
 \subsubsection*{{\ttfamily union-\/intersection-\/spacing}}

{\itshape The {\ttfamily -\/-\/fix} option on the command line automatically fixes problems reported by this rule.}

Enforces consistent spacing around union and intersection type separators ({\ttfamily $\vert$} and {\ttfamily \&}).

This rule takes one argument. If it is `\textquotesingle{}always'{\ttfamily then a problem is raised when there is no space around the separator. If it is}\textquotesingle{}never\textquotesingle{}\`{} then a problem is raised when there is a space around the separator.

The default value is `\textquotesingle{}always'\`{}.

The following patterns are considered problems\+:


\begin{DoxyCode}
type X = string| number;
// Message: There must be a space before union type annotation separator

// Options: ["always"]
type X = string| number;
// Message: There must be a space before union type annotation separator

type X = string |number;
// Message: There must be a space after union type annotation separator

type X = string|number;
// Message: There must be a space before union type annotation separator
// Message: There must be a space after union type annotation separator

type X = \{x: string\}|\{y: number\};
// Message: There must be a space before union type annotation separator
// Message: There must be a space after union type annotation separator

type X = string | number |boolean;
// Message: There must be a space after union type annotation separator

type X = string|number|boolean;
// Message: There must be a space before union type annotation separator
// Message: There must be a space after union type annotation separator
// Message: There must be a space before union type annotation separator
// Message: There must be a space after union type annotation separator

type X = (string)| number;
// Message: There must be a space before union type annotation separator

type X = ((string))|(number | foo);
// Message: There must be a space before union type annotation separator
// Message: There must be a space after union type annotation separator

// Options: ["never"]
type X = string |number;
// Message: There must be no space before union type annotation separator

// Options: ["never"]
type X = string| number;
// Message: There must be no space after union type annotation separator

type X = string& number;
// Message: There must be a space before intersection type annotation separator

// Options: ["always"]
type X = string& number;
// Message: There must be a space before intersection type annotation separator

type X = string &number;
// Message: There must be a space after intersection type annotation separator

type X = \{x: string\}&\{y: number\};
// Message: There must be a space before intersection type annotation separator
// Message: There must be a space after intersection type annotation separator

type X = string&number;
// Message: There must be a space before intersection type annotation separator
// Message: There must be a space after intersection type annotation separator

type X = string & number &boolean;
// Message: There must be a space after intersection type annotation separator

type X = string&number&boolean;
// Message: There must be a space before intersection type annotation separator
// Message: There must be a space after intersection type annotation separator
// Message: There must be a space before intersection type annotation separator
// Message: There must be a space after intersection type annotation separator

type X = (string)& number;
// Message: There must be a space before intersection type annotation separator

type X = ((string))&(number & foo);
// Message: There must be a space before intersection type annotation separator
// Message: There must be a space after intersection type annotation separator

// Options: ["never"]
type X = string &number;
// Message: There must be no space before intersection type annotation separator

// Options: ["never"]
type X = string& number;
// Message: There must be no space after intersection type annotation separator
\end{DoxyCode}


The following patterns are not considered problems\+:


\begin{DoxyCode}
type X = string | number;

type X = string | number | boolean;

type X = (string) | number;

type X = ((string)) | (number | foo);

// Options: ["never"]
type X = string|number

type X =
| string
| number

function x() \{
type X =
| string
| number
\}

type X = string| number;

type X = string & number;

type X = string & number & boolean;

type X = (string) & number;

type X = ((string)) & (number & foo);

// Options: ["never"]
type X = string&number

type X =
& string
& number

function x() \{
type X =
& string
& number
\}

type X = string& number;
\end{DoxyCode}


\label{_eslint-plugin-flowtype-rules-use-flow-type}%
 \subsubsection*{{\ttfamily use-\/flow-\/type}}

Marks Flow \href{https://flowtype.org/docs/type-aliases.html}{\tt type alias} declarations as used.

Used to suppress \href{http://eslint.org/docs/rules/no-unused-vars}{\tt {\ttfamily no-\/unused-\/vars}} errors that are triggered by type aliases.

The following patterns are not considered problems\+:


\begin{DoxyCode}
declare class A \{\}
// Additional rules: \{"no-unused-vars":1\}

declare function A(): Y
// Additional rules: \{"no-unused-vars":1\}

declare module A \{\}
// Additional rules: \{"no-unused-vars":1\}

declare module A \{ declare var a: Y \}
// Additional rules: \{"no-unused-vars":1\}

declare var A: Y
// Additional rules: \{"no-unused-vars":1\}

import type A from "a"; (function<T: A>(): T \{\})
// Additional rules: \{"no-unused-vars":1\}

(function<T: A>(): T \{\}); import type A from "a"
// Additional rules: \{"no-unused-vars":1\}

import type \{A\} from "a"; (function<T: A>(): T \{\})
// Additional rules: \{"no-unused-vars":1\}

(function<T: A>(): T \{\}); import type \{A\} from "a"
// Additional rules: \{"no-unused-vars":1\}

(function<T: A>(): T \{\}); import type \{a as A\} from "a"
// Additional rules: \{"no-unused-vars":1\}

type A = \{\}; function x<Y: A>(i: Y) \{ i \}; x()
// Additional rules: \{"no-unused-vars":1\}

function x<Y: A>(i: Y) \{ i \}; type A = \{\}; x()
// Additional rules: \{"no-unused-vars":1\}

type A = \{\}; function x<Y: A.B.C>(i: Y) \{ i \}; x()
// Additional rules: \{"no-unused-vars":1\}

function x<Y: A.B.C>(i: Y) \{ i \}; type A = \{\}; x()
// Additional rules: \{"no-unused-vars":1\}
\end{DoxyCode}


\label{_eslint-plugin-flowtype-rules-valid-syntax}%
 \subsubsection*{{\ttfamily valid-\/syntax}}

{\bfseries Deprecated} Babylon (the Babel parser) v6.\+10.\+0 fixes parsing of the invalid syntax this plugin warned against.

Checks for simple Flow syntax errors. 