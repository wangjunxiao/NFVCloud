\href{https://www.npmjs.com/package/csso}{\tt } \href{https://travis-ci.org/css/csso}{\tt } \href{https://coveralls.io/github/css/csso?branch=master}{\tt } \href{https://www.npmjs.com/package/csso}{\tt } \href{https://twitter.com/cssoptimizer}{\tt }

C\+S\+SO (C\+SS Optimizer) is a C\+SS minifier. It performs three sort of transformations\+: cleaning (removing redundant), compression (replacement for shorter form) and restructuring (merge of declarations, rulesets and so on). As a result your C\+SS becomes much smaller.

\href{https://www.yandex.com/}{\tt } \href{https://www.avito.ru/}{\tt }

\subsection*{Usage}


\begin{DoxyCode}
npm install -g csso
\end{DoxyCode}


Or try out C\+S\+SO \href{http://css.github.io/csso/csso.html}{\tt right in your browser} (web interface).

\subsubsection*{Runners}


\begin{DoxyItemize}
\item Gulp\+: \href{https://github.com/ben-eb/gulp-csso}{\tt gulp-\/csso}
\item Grunt\+: \href{https://github.com/t32k/grunt-csso}{\tt grunt-\/csso}
\item Broccoli\+: \href{https://github.com/sindresorhus/broccoli-csso}{\tt broccoli-\/csso}
\item Post\+C\+SS\+: \href{https://github.com/lahmatiy/postcss-csso}{\tt postcss-\/csso}
\item Webpack\+: \href{https://github.com/sandark7/csso-loader}{\tt csso-\/loader}
\end{DoxyItemize}

\subsubsection*{Command line}


\begin{DoxyCode}
csso [input] [output] [options]

Options:

      --comments <value>    Comments to keep: exclamation (default), first-exclamation or none
      --debug [level]       Output intermediate state of CSS during compression
  -h, --help                Output usage information
  -i, --input <filename>    Input file
      --input-map <source>  Input source map: none, auto (default) or <filename>
  -m, --map <destination>   Generate source map: none (default), inline, file or <filename>
  -o, --output <filename>   Output file (result outputs to stdout if not set)
      --restructure-off     Turns structure minimization off
      --stat                Output statistics in stderr
  -u, --usage <filenane>    Usage data file
  -v, --version             Output version
\end{DoxyCode}


Some examples\+:


\begin{DoxyCode}
> csso in.css
...output result in stdout...

> csso in.css --output out.css

> echo '.test \{ color: #ff0000; \}' | csso
.test\{color:red\}

> cat source1.css source2.css | csso | gzip -9 -c > production.css.gz
\end{DoxyCode}


\subsubsection*{Source maps}

Source map doesn\textquotesingle{}t generate by default. To generate map use {\ttfamily -\/-\/map} C\+LI option, that can be\+:


\begin{DoxyItemize}
\item {\ttfamily none} (default) – don\textquotesingle{}t generate source map
\item {\ttfamily inline} – add source map into result C\+SS (via {\ttfamily /$\ast$\# source\+Mapping\+U\+RL=application/json;base64,... $\ast$/})
\item {\ttfamily file} – write source map into file with same name as output file, but with {\ttfamily .map} extension (in this case {\ttfamily -\/-\/output} option is required)
\item any other values treat as filename for generated source map
\end{DoxyItemize}

Examples\+:


\begin{DoxyCode}
> csso my.css --map inline
> csso my.css --output my.min.css --map file
> csso my.css --output my.min.css --map maps/my.min.map
\end{DoxyCode}


Use {\ttfamily -\/-\/input-\/map} option to specify input source map if needed. Possible values for option\+:


\begin{DoxyItemize}
\item {\ttfamily auto} (default) -\/ attempt to fetch input source map by follow steps\+:
\begin{DoxyItemize}
\item try to fetch inline map from input
\item try to fetch source map filename from input and read its content
\item (when {\ttfamily -\/-\/input} is specified) check file with same name as input file but with {\ttfamily .map} extension exists and read its content
\end{DoxyItemize}
\item {\ttfamily none} -\/ don\textquotesingle{}t use input source map; actually it\textquotesingle{}s using to disable {\ttfamily auto}-\/fetching
\item any other values treat as filename for input source map
\end{DoxyItemize}

Generally you shouldn\textquotesingle{}t care about input source map since defaults behaviour ({\ttfamily auto}) covers most use cases.

\begin{quote}
N\+O\+TE\+: Input source map is using only if output source map is generating. \end{quote}


\subsubsection*{Usage data}

{\ttfamily C\+S\+SO} can use data about how {\ttfamily C\+SS} is using for better compression. File with this data ({\ttfamily J\+S\+ON} format) can be set using {\ttfamily -\/-\/usage} option. Usage data may contain follow sections\+:


\begin{DoxyItemize}
\item {\ttfamily tags} – white list of tags
\item {\ttfamily ids} – white list of ids
\item {\ttfamily classes} – white list of classes
\item {\ttfamily scopes} – groups of classes which never used with classes from other groups on single element
\end{DoxyItemize}

All sections are optional. Value of {\ttfamily tags}, {\ttfamily ids} and {\ttfamily classes} should be array of strings, value of {\ttfamily scopes} should be an array of arrays of strings. Other values are ignoring.

\paragraph*{Selector filtering}

{\ttfamily tags}, {\ttfamily ids} and {\ttfamily classes} are using on clean stage to filter selectors that contains something that not in list. Selectors are filtering only by those kind of simple selector which white list is specified. For example, if only {\ttfamily tags} list is specified then type selectors are checking, and if selector hasn\textquotesingle{}t any type selector (or even any type selector) it isn\textquotesingle{}t filter.

\begin{quote}
{\ttfamily ids} and {\ttfamily classes} names are case sensitive, {\ttfamily tags} – is not. \end{quote}


Input C\+SS\+:


\begin{DoxyCode}
* \{ color: green; \}
ul, ol, li \{ color: blue; \}
UL.foo, span.bar \{ color: red; \}
\end{DoxyCode}


Usage data\+:


\begin{DoxyCode}
\{
    "tags": ["ul", "LI"]
\}
\end{DoxyCode}


Result C\+SS\+:


\begin{DoxyCode}
*\{color:green\}ul,li\{color:blue\}ul.foo\{color:red\}
\end{DoxyCode}


\paragraph*{Scopes}

Scopes is designed for C\+SS scope isolation solutions such as \href{https://github.com/css-modules/css-modules}{\tt css-\/modules}. Scopes are similar to namespaces and defines lists of class names that exclusively used on some markup. This information allows the optimizer to move rulesets more agressive. Since it assumes selectors from different scopes can\textquotesingle{}t to be matched on the same element. That leads to better ruleset merging.

Suppose we have a file\+:


\begin{DoxyCode}
.module1-foo \{ color: red; \}
.module1-bar \{ font-size: 1.5em; background: yellow; \}

.module2-baz \{ color: red; \}
.module2-qux \{ font-size: 1.5em; background: yellow; width: 50px; \}
\end{DoxyCode}


It can be assumed that first two rules never used with second two on the same markup. But we can\textquotesingle{}t know that for sure without markup. The optimizer doesn\textquotesingle{}t know it eather and will perform safe transformations only. The result will be the same as input but with no spaces and some semicolons\+:


\begin{DoxyCode}

      .module1-foo\{color:red\}.module1-bar\{font-size:1.5em;background:#ff0\}.module2-baz\{color:red\}.module2-qux\{font-size:1.5em;background:#ff0;width:50px\}
\end{DoxyCode}


But with usage data {\ttfamily C\+S\+SO} can get better output. If follow usage data is provided\+:


\begin{DoxyCode}
\{
    "scopes": [
        ["module1-foo", "module1-bar"],
        ["module2-baz", "module2-qux"]
    ]
\}
\end{DoxyCode}


New result (29 bytes extra saving)\+:


\begin{DoxyCode}

      .module1-foo,.module2-baz\{color:red\}.module1-bar,.module2-qux\{font-size:1.5em;background:#ff0\}.module2-qux\{width:50px\}
\end{DoxyCode}


If class name doesn\textquotesingle{}t specified in {\ttfamily scopes} it belongs to default \char`\"{}scope\char`\"{}. {\ttfamily scopes} doesn\textquotesingle{}t affect {\ttfamily classes}. If class name presents in {\ttfamily scopes} but missed in {\ttfamily classes} (both sections specified) it will be filtered.

Note that class name can\textquotesingle{}t be specified in several scopes. Also selector can\textquotesingle{}t has classes from different scopes. In both cases an exception throws.

Currently the optimizer doesn\textquotesingle{}t care about out-\/of-\/bounds selectors order changing safety (i.\+e. selectors that may be matched to elements with no class name of scope, e.\+g. {\ttfamily .scope div} or {\ttfamily .scope $\sim$ \+:last-\/child}) since assumes scoped C\+SS modules doesn\textquotesingle{}t relay on it\textquotesingle{}s order. It may be fix in future if to be an issue.

\subsubsection*{A\+PI}


\begin{DoxyCode}
var csso = require('csso');

var compressedCss = csso.minify('.test \{ color: #ff0000; \}').css;

console.log(compressedCss);
// .test\{color:red\}
\end{DoxyCode}


You may minify C\+SS by yourself step by step\+:


\begin{DoxyCode}
var ast = csso.parse('.test \{ color: #ff0000; \}');
var compressResult = csso.compress(ast);
var compressedCss = csso.translate(compressResult.ast);

console.log(compressedCss);
// .test\{color:red\}
\end{DoxyCode}


Working with source maps\+:


\begin{DoxyCode}
var css = fs.readFileSync('path/to/my.css', 'utf8');
var result = csso.minify(css, \{
  filename: 'path/to/my.css', // will be added to source map as reference to source file
  sourceMap: true             // generate source map
\});

console.log(result);
// \{ css: '...minified...', map: SourceMapGenerator \{\} \}

console.log(result.map.toString());
// '\{ .. source map content .. \}'
\end{DoxyCode}


\paragraph*{minify(source\mbox{[}, options\mbox{]})}

Minify {\ttfamily source} C\+SS passed as {\ttfamily String}.

Options\+:


\begin{DoxyItemize}
\item source\+Map {\ttfamily Boolean} -\/ generate source map if {\ttfamily true}
\item filename {\ttfamily String} -\/ filename of input, uses for source map
\item debug {\ttfamily Boolean} -\/ output debug information to {\ttfamily stderr}
\item before\+Compress {\ttfamily function$\vert$array$<$function$>$} -\/ called right after parse is run. Callbacks arguments are {\ttfamily ast, options}.
\item after\+Compress {\ttfamily function$\vert$array$<$function$>$} -\/ called right after compress is run. Callbacks arguments are {\ttfamily compress\+Result, options}.
\item other options are the same as for {\ttfamily compress()}
\end{DoxyItemize}

Returns an object with properties\+:


\begin{DoxyItemize}
\item css {\ttfamily String} – resulting C\+SS
\item map {\ttfamily Object} – instance of {\ttfamily Source\+Map\+Generator} or {\ttfamily null}
\end{DoxyItemize}


\begin{DoxyCode}
var result = csso.minify('.test \{ color: #ff0000; \}', \{
    restructure: false,   // don't change CSS structure, i.e. don't merge declarations, rulesets etc
    debug: true           // show additional debug information:
                          // true or number from 1 to 3 (greater number - more details)
\});

console.log(result.css);
// > .test\{color:red\}
\end{DoxyCode}


\paragraph*{minify\+Block(source\mbox{[}, options\mbox{]})}

The same as {\ttfamily minify()} but for style block. Usualy it\textquotesingle{}s a {\ttfamily style} attribute content.


\begin{DoxyCode}
var result = csso.minifyBlock('color: rgba(255, 0, 0, 1); color: #ff0000').css;

console.log(result.css);
// > color:red
\end{DoxyCode}


\paragraph*{parse(source\mbox{[}, options\mbox{]})}

Parse C\+SS to A\+ST.

\begin{quote}
N\+O\+TE\+: Currenly parser omit redundant separators, spaces and comments (except exclamation comments, i.\+e. {\ttfamily /$\ast$! comment $\ast$/}) on A\+ST build, since those things are removing by compressor anyway. \end{quote}


Options\+:


\begin{DoxyItemize}
\item context {\ttfamily String} – parsing context, useful when some part of C\+SS is parsing (see below)
\item positions {\ttfamily Boolean} – should A\+ST contains node position or not, store data in {\ttfamily info} property of nodes ({\ttfamily false} by default)
\item filename {\ttfamily String} – filename of source that adds to info when {\ttfamily positions} is true, uses for source map generation ({\ttfamily $<$unknown$>$} by default)
\item line {\ttfamily Number} – initial line number, useful when parse fragment of C\+SS to compute correct positions
\item column {\ttfamily Number} – initial column number, useful when parse fragment of C\+SS to compute correct positions
\end{DoxyItemize}

Contexts\+:


\begin{DoxyItemize}
\item {\ttfamily stylesheet} (default) – regular stylesheet, should be suitable in most cases
\item {\ttfamily atrule} – at-\/rule (e.\+g. {\ttfamily @media screen, print \{ ... \}})
\item {\ttfamily atrule\+Expression} – at-\/rule expression ({\ttfamily screen, print} for example above)
\item {\ttfamily ruleset} – rule (e.\+g. {\ttfamily .foo, .bar\+:hover \{ color\+: red; border\+: 1px solid black; \}})
\item {\ttfamily selector} – selector group ({\ttfamily .foo, .bar\+:hover} for ruleset example)
\item {\ttfamily simple\+Selector} – selector ({\ttfamily .foo} or {\ttfamily .bar\+:hover} for ruleset example)
\item {\ttfamily block} – block content w/o curly braces ({\ttfamily color\+: red; border\+: 1px solid black;} for ruleset example)
\item {\ttfamily declaration} – declaration ({\ttfamily color\+: red} or {\ttfamily border\+: 1px solid black} for ruleset example)
\item {\ttfamily value} – declaration value ({\ttfamily red} or {\ttfamily 1px solid black} for ruleset example)
\end{DoxyItemize}


\begin{DoxyCode}
// simple parsing with no options
var ast = csso.parse('.example \{ color: red \}');

// parse with options
var ast = csso.parse('.foo.bar', \{
    context: 'simpleSelector',
    positions: true
\});
\end{DoxyCode}


\paragraph*{compress(ast\mbox{[}, options\mbox{]})}

Does the main task – compress A\+ST.

\begin{quote}
N\+O\+TE\+: {\ttfamily compress} performs A\+ST compression by transforming input A\+ST by default (since A\+ST cloning is expensive and needed in rare cases). Use {\ttfamily clone} option with truthy value in case you want to keep input A\+ST untouched. \end{quote}


Options\+:


\begin{DoxyItemize}
\item restructure {\ttfamily Boolean} – do the structure optimisations or not ({\ttfamily true} by default)
\item clone {\ttfamily Boolean} -\/ transform a copy of input A\+ST if {\ttfamily true}, useful in case of A\+ST reuse ({\ttfamily false} by default)
\item comments {\ttfamily String} or {\ttfamily Boolean} – specify what comments to left
\begin{DoxyItemize}
\item `\textquotesingle{}exclamation'{\ttfamily or}true$<$tt$>$(default) – left all exclamation comments (i.\+e./$\ast$! .. $\ast$/{\ttfamily ) -\/}\textquotesingle{}first-\/exclamation\textquotesingle{}{\ttfamily – remove every comments except first one -\/}false{\ttfamily – remove every comments}
\end{DoxyItemize}
\item {\ttfamily usage}Object{\ttfamily -\/ usage data for advanced optimisations (see \mbox{[}Usage data\mbox{]}(\#usage-\/data) for details)}
\item {\ttfamily logger}Function\`{} -\/ function to track every step of transformations
\end{DoxyItemize}

\paragraph*{clone(ast)}

Make an A\+ST node deep copy.


\begin{DoxyCode}
var orig = csso.parse('.test \{ color: red \}');
var copy = csso.clone(orig);

csso.walk(copy, function(node) \{
    if (node.type === 'Class') \{
        node.name = 'replaced';
    \}
\});

console.log(csso.translate(orig));
// .test\{color:red\}
console.log(csso.translate(copy));
// .replaced\{color:red\}
\end{DoxyCode}


\paragraph*{translate(ast)}

Converts A\+ST to string.


\begin{DoxyCode}
var ast = csso.parse('.test \{ color: red \}');
console.log(csso.translate(ast));
// > .test\{color:red\}
\end{DoxyCode}


\paragraph*{translate\+With\+Source\+Map(ast)}

The same as {\ttfamily translate()} but also generates source map (nodes should contain positions in {\ttfamily info} property).


\begin{DoxyCode}
var ast = csso.parse('.test \{ color: red \}', \{
    filename: 'my.css',
    positions: true
\});
console.log(csso.translateWithSourceMap(ast));
// \{ css: '.test\{color:red\}', map: SourceMapGenerator \{\} \}
\end{DoxyCode}


\paragraph*{walk(ast, handler)}

Visit all nodes of A\+ST and call handler for each one. {\ttfamily handler} receives three arguments\+:


\begin{DoxyItemize}
\item node – current A\+ST node
\item item – node wrapper when node is a list member; this wrapper contains references to {\ttfamily prev} and {\ttfamily next} nodes in list
\item list – reference to list when node is a list member; it\textquotesingle{}s useful for operations on list like {\ttfamily remove()} or {\ttfamily insert()}
\end{DoxyItemize}

Context for handler an object, that contains references to some parent nodes\+:


\begin{DoxyItemize}
\item root – refers to {\ttfamily ast} or root node
\item stylesheet – refers to closest {\ttfamily Style\+Sheet} node, it may be a top-\/level or at-\/rule block stylesheet
\item atrule\+Expression – refers to {\ttfamily Atrule\+Expression} node if current node inside at-\/rule expression
\item ruleset – refers to {\ttfamily Ruleset} node if current node inside a ruleset
\item selector – refers to {\ttfamily Selector} node if current node inside a selector
\item declaration – refers to {\ttfamily Declaration} node if current node inside a declaration
\item function – refers to closest {\ttfamily Function} or {\ttfamily Functional\+Pseudo} node if current node inside one of them
\end{DoxyItemize}

\`{}\`{}\`{}js // collect all urls in declarations var csso = require(\textquotesingle{}./lib/index.js\textquotesingle{}); var urls = \mbox{[}\mbox{]}; var ast = csso.\+parse(\`{}  url(import.\+css); .foo \{ background\+: url(\textquotesingle{}foo.\+jpg\textquotesingle{}); \} .bar \{ background-\/image\+: url(bar.\+png); \} \`{});

csso.\+walk(ast, function(node) \{ if (this.\+declaration !== null \&\& node.\+type === \textquotesingle{}Url\textquotesingle{}) \{ var value = node.\+value;

if (value.\+type === \textquotesingle{}Raw\textquotesingle{}) \{ urls.\+push(value.\+value); \} else \{ urls.\+push(value.\+value.\+substr(1, value.\+value.\+length -\/ 2)); \} \} \});

console.\+log(urls); // \mbox{[} \textquotesingle{}foo.\+jpg\textquotesingle{}, \textquotesingle{}bar.\+png\textquotesingle{} \mbox{]} \`{}\`{}\`{}

\paragraph*{walk\+Rules(ast, handler)}

Same as {\ttfamily walk()} but visits {\ttfamily Ruleset} and {\ttfamily Atrule} nodes only.

\paragraph*{walk\+Rules\+Right(ast, handler)}

Same as {\ttfamily walk\+Rules()} but visits nodes in reverse order (from last to first).

\subsection*{More reading}


\begin{DoxyItemize}
\item Debugging
\end{DoxyItemize}

\subsection*{License}

M\+IT 