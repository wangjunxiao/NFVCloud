\subsection*{Methods}

\subsubsection*{{\ttfamily get\+Options}}

Recommended way to retrieve the options of a loader invocation\+:


\begin{DoxyCode}
// inside your loader
const options = loaderUtils.getOptions(this);
\end{DoxyCode}



\begin{DoxyEnumerate}
\item If {\ttfamily this.\+query} is a string\+:
\begin{DoxyItemize}
\item Tries to parse the query string and returns a new object
\item Throws if it\textquotesingle{}s not a valid query string
\end{DoxyItemize}
\item If {\ttfamily this.\+query} is object-\/like, it just returns {\ttfamily this.\+query}
\item In any other case, it just returns {\ttfamily null}
\end{DoxyEnumerate}

{\bfseries Please note\+:} The returned {\ttfamily options} object is {\itshape read-\/only}. It may be re-\/used across multiple invocations. If you pass it on to another library, make sure to make a {\itshape deep copy} of it\+:


\begin{DoxyCode}
const options = Object.assign(
    \{\},
    loaderUtils.getOptions(this), // it is safe to pass null to Object.assign()
    defaultOptions
);
// don't forget nested objects or arrays
options.obj = Object.assign(\{\}, options.obj); 
options.arr = options.arr.slice();
someLibrary(options);
\end{DoxyCode}


\href{https://www.npmjs.com/package/clone-deep}{\tt clone-\/deep} is a good library to make a deep copy of the options.

\paragraph*{Options as query strings}

If the loader options have been passed as loader query string ({\ttfamily loader?some\&params}), the string is parsed by using \href{#parsequery}{\tt {\ttfamily parse\+Query}}.

\subsubsection*{{\ttfamily parse\+Query}}

Parses a passed string (e.\+g. {\ttfamily loader\+Context.\+resource\+Query}) as a query string, and returns an object.

\`{}\`{}{\ttfamily javascript const params = loader\+Utils.\+parse\+Query(this.\+resource\+Query); // resource\+:}file?param1=foo\`{} if (params.\+param1 === \char`\"{}foo\char`\"{}) \{ // do something \} 
\begin{DoxyCode}
The string is parsed like this:

``` text
                             -> Error
?                            -> \{\}
?flag                        -> \{ flag: true \}
?+flag                       -> \{ flag: true \}
?-flag                       -> \{ flag: false \}
?xyz=test                    -> \{ xyz: "test" \}
?xyz=1                       -> \{ xyz: "1" \} // numbers are NOT parsed
?xyz[]=a                     -> \{ xyz: ["a"] \}
?flag1&flag2                 -> \{ flag1: true, flag2: true \}
?+flag1,-flag2               -> \{ flag1: true, flag2: false \}
?xyz[]=a,xyz[]=b             -> \{ xyz: ["a", "b"] \}
?a%2C%26b=c%2C%26d           -> \{ "a,&b": "c,&d" \}
?\{data:\{a:1\},isJSON5:true\}   -> \{ data: \{ a: 1 \}, isJSON5: true \}
\end{DoxyCode}


\subsubsection*{{\ttfamily stringify\+Request}}

Turns a request into a string that can be used inside {\ttfamily require()} or {\ttfamily import} while avoiding absolute paths. Use it instead of {\ttfamily J\+S\+O\+N.\+stringify(...)} if you\textquotesingle{}re generating code inside a loader.

{\bfseries Why is this necessary?} Since webpack calculates the hash before module paths are translated into module ids, we must avoid absolute paths to ensure consistent hashes across different compilations.

This function\+:


\begin{DoxyItemize}
\item resolves absolute requests into relative requests if the request and the module are on the same hard drive
\item replaces {\ttfamily \textbackslash{}} with {\ttfamily /} if the request and the module are on the same hard drive
\item won\textquotesingle{}t change the path at all if the request and the module are on different hard drives
\item applies {\ttfamily J\+S\+O\+N.\+stringify} to the result
\end{DoxyItemize}


\begin{DoxyCode}
loaderUtils.stringifyRequest(this, "./test.js");
// "\(\backslash\)"./test.js\(\backslash\)""

loaderUtils.stringifyRequest(this, ".\(\backslash\)\(\backslash\)test.js");
// "\(\backslash\)"./test.js\(\backslash\)""

loaderUtils.stringifyRequest(this, "test");
// "\(\backslash\)"test\(\backslash\)""

loaderUtils.stringifyRequest(this, "test/lib/index.js");
// "\(\backslash\)"test/lib/index.js\(\backslash\)""

loaderUtils.stringifyRequest(this, "otherLoader?andConfig!test?someConfig");
// "\(\backslash\)"otherLoader?andConfig!test?someConfig\(\backslash\)""

loaderUtils.stringifyRequest(this, require.resolve("test"));
// "\(\backslash\)"../node\_modules/some-loader/lib/test.js\(\backslash\)""

loaderUtils.stringifyRequest(this, "C:\(\backslash\)\(\backslash\)module\(\backslash\)\(\backslash\)test.js");
// "\(\backslash\)"../../test.js\(\backslash\)"" (on Windows, in case the module and the request are on the same drive)

loaderUtils.stringifyRequest(this, "C:\(\backslash\)\(\backslash\)module\(\backslash\)\(\backslash\)test.js");
// "\(\backslash\)"C:\(\backslash\)\(\backslash\)module\(\backslash\)\(\backslash\)test.js\(\backslash\)"" (on Windows, in case the module and the request are on different drives)

loaderUtils.stringifyRequest(this, "\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)network-drive\(\backslash\)\(\backslash\)test.js");
// "\(\backslash\)"\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)network-drive\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)test.js\(\backslash\)"" (on Windows, in case the module and the request are on different
       drives)
\end{DoxyCode}


\subsubsection*{{\ttfamily url\+To\+Request}}

Converts some resource \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} to a webpack module request.


\begin{DoxyCode}
const url = "path/to/module.js";
const request = loaderUtils.urlToRequest(url); // "./path/to/module.js"
\end{DoxyCode}


\paragraph*{Module U\+R\+Ls}

Any \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} containing a {\ttfamily $\sim$} will be interpreted as a module request. Anything after the {\ttfamily $\sim$} will be considered the request path.


\begin{DoxyCode}
const url = "~path/to/module.js";
const request = loaderUtils.urlToRequest(url); // "path/to/module.js"
\end{DoxyCode}


\paragraph*{Root-\/relative U\+R\+Ls}

U\+R\+Ls that are root-\/relative (start with {\ttfamily /}) can be resolved relative to some arbitrary path by using the {\ttfamily root} parameter\+:


\begin{DoxyCode}
const url = "/path/to/module.js";
const root = "./root";
const request = loaderUtils.urlToRequest(url, root); // "./root/path/to/module.js"
\end{DoxyCode}


To convert a root-\/relative \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} into a module \mbox{\hyperlink{namespace_u_r_l}{U\+RL}}, specify a {\ttfamily root} value that starts with {\ttfamily $\sim$}\+:


\begin{DoxyCode}
const url = "/path/to/module.js";
const root = "~";
const request = loaderUtils.urlToRequest(url, root); // "path/to/module.js"
\end{DoxyCode}


\subsubsection*{{\ttfamily interpolate\+Name}}

Interpolates a filename template using multiple placeholders and/or a regular expression. The template and regular expression are set as query params called {\ttfamily name} and {\ttfamily reg\+Exp} on the current loader\textquotesingle{}s context.


\begin{DoxyCode}
const interpolatedName = loaderUtils.interpolateName(loaderContext, name, options);
\end{DoxyCode}


The following tokens are replaced in the {\ttfamily name} parameter\+:


\begin{DoxyItemize}
\item {\ttfamily \mbox{[}ext\mbox{]}} the extension of the resource
\item {\ttfamily \mbox{[}name\mbox{]}} the basename of the resource
\item {\ttfamily \mbox{[}path\mbox{]}} the path of the resource relative to the {\ttfamily context} query parameter or option.
\item {\ttfamily \mbox{[}folder\mbox{]}} the folder of the resource is in.
\item {\ttfamily \mbox{[}emoji\mbox{]}} a random emoji representation of {\ttfamily options.\+content}
\item {\ttfamily \mbox{[}emoji\+:$<$length$>$\mbox{]}} same as above, but with a customizable number of emojis
\item {\ttfamily \mbox{[}hash\mbox{]}} the hash of {\ttfamily options.\+content} (Buffer) (by default it\textquotesingle{}s the hex digest of the md5 hash)
\item {\ttfamily \mbox{[}$<$hash\+Type$>$\+:hash\+:$<$digest\+Type$>$\+:$<$length$>$\mbox{]}} optionally one can configure
\begin{DoxyItemize}
\item other {\ttfamily hash\+Type}s, i. e. {\ttfamily sha1}, {\ttfamily md5}, {\ttfamily sha256}, {\ttfamily sha512}
\item other {\ttfamily digest\+Type}s, i. e. {\ttfamily hex}, {\ttfamily base26}, {\ttfamily base32}, {\ttfamily base36}, {\ttfamily base49}, {\ttfamily base52}, {\ttfamily base58}, {\ttfamily base62}, {\ttfamily base64}
\item and {\ttfamily length} the length in chars
\end{DoxyItemize}
\item {\ttfamily \mbox{[}N\mbox{]}} the N-\/th match obtained from matching the current file name against {\ttfamily options.\+reg\+Exp}
\end{DoxyItemize}

Examples


\begin{DoxyCode}
// loaderContext.resourcePath = "/app/js/javascript.js"
loaderUtils.interpolateName(loaderContext, "js/[hash].script.[ext]", \{ content: ... \});
// => js/9473fdd0d880a43c21b7778d34872157.script.js

// loaderContext.resourcePath = "/app/page.html"
loaderUtils.interpolateName(loaderContext, "html-[hash:6].html", \{ content: ... \});
// => html-9473fd.html

// loaderContext.resourcePath = "/app/flash.txt"
loaderUtils.interpolateName(loaderContext, "[hash]", \{ content: ... \});
// => c31e9820c001c9c4a86bce33ce43b679

// loaderContext.resourcePath = "/app/img/image.gif"
loaderUtils.interpolateName(loaderContext, "[emoji]", \{ content: ... \});
// => ðŸ‘

// loaderContext.resourcePath = "/app/img/image.gif"
loaderUtils.interpolateName(loaderContext, "[emoji:4]", \{ content: ... \});
// => ðŸ™ðŸ¢ðŸ“¤ðŸ

// loaderContext.resourcePath = "/app/img/image.png"
loaderUtils.interpolateName(loaderContext, "[sha512:hash:base64:7].[ext]", \{ content: ... \});
// => 2BKDTjl.png
// use sha512 hash instead of md5 and with only 7 chars of base64

// loaderContext.resourcePath = "/app/img/myself.png"
// loaderContext.query.name =
loaderUtils.interpolateName(loaderContext, "picture.png");
// => picture.png

// loaderContext.resourcePath = "/app/dir/file.png"
loaderUtils.interpolateName(loaderContext, "[path][name].[ext]?[hash]", \{ content: ... \});
// => /app/dir/file.png?9473fdd0d880a43c21b7778d34872157

// loaderContext.resourcePath = "/app/js/page-home.js"
loaderUtils.interpolateName(loaderContext, "script-[1].[ext]", \{ regExp: "page-(.*)\(\backslash\)\(\backslash\).js", content: ... \});
// => script-home.js
\end{DoxyCode}


\subsubsection*{{\ttfamily get\+Hash\+Digest}}


\begin{DoxyCode}
const digestString = loaderUtils.getHashDigest(buffer, hashType, digestType, maxLength);
\end{DoxyCode}



\begin{DoxyItemize}
\item {\ttfamily buffer} the content that should be hashed
\item {\ttfamily hash\+Type} one of {\ttfamily sha1}, {\ttfamily md5}, {\ttfamily sha256}, {\ttfamily sha512} or any other node.\+js supported hash type
\item {\ttfamily digest\+Type} one of {\ttfamily hex}, {\ttfamily base26}, {\ttfamily base32}, {\ttfamily base36}, {\ttfamily base49}, {\ttfamily base52}, {\ttfamily base58}, {\ttfamily base62}, {\ttfamily base64}
\item {\ttfamily max\+Length} the maximum length in chars
\end{DoxyItemize}

\subsection*{License}

M\+IT (\href{http://www.opensource.org/licenses/mit-license.php}{\tt http\+://www.\+opensource.\+org/licenses/mit-\/license.\+php}) 