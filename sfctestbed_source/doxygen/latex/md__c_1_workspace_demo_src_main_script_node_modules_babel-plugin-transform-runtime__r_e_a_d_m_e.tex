\begin{quote}
Externalise references to helpers and builtins, automatically polyfilling your code without polluting globals. (This plugin is recommended in a library/tool) \end{quote}


N\+O\+TE\+: Instance methods such as {\ttfamily \char`\"{}foobar\char`\"{}.includes(\char`\"{}foo\char`\"{})} will not work since that would require modification of existing builtins (Use \href{http://babeljs.io/docs/usage/polyfill}{\tt {\ttfamily babel-\/polyfill}} for that).

\subsection*{Why?}

Babel uses very small helpers for common functions such as {\ttfamily \+\_\+extend}. By default this will be added to every file that requires it. This duplication is sometimes unnecessary, especially when your application is spread out over multiple files.

This is where the {\ttfamily transform-\/runtime} plugin comes in\+: all of the helpers will reference the module {\ttfamily babel-\/runtime} to avoid duplication across your compiled output. The runtime will be compiled into your build.

Another purpose of this transformer is to create a sandboxed environment for your code. If you use \href{http://babeljs.io/docs/usage/polyfill/}{\tt babel-\/polyfill} and the built-\/ins it provides such as {\ttfamily Promise}, {\ttfamily Set} and {\ttfamily Map}, those will pollute the global scope. While this might be ok for an app or a command line tool, it becomes a problem if your code is a library which you intend to publish for others to use or if you can\textquotesingle{}t exactly control the environment in which your code will run.

The transformer will alias these built-\/ins to {\ttfamily core-\/js} so you can use them seamlessly without having to require the polyfill.

See the \href{#technical-details}{\tt technical details} section for more information on how this works and the types of transformations that occur.

\subsection*{Installation}

{\bfseries N\+O\+TE -\/ Production vs. development dependencies}

In most cases, you should install {\ttfamily babel-\/plugin-\/transform-\/runtime} as a development dependency (with {\ttfamily -\/-\/save-\/dev}).


\begin{DoxyCode}
npm install --save-dev babel-plugin-transform-runtime
\end{DoxyCode}


and {\ttfamily babel-\/runtime} as a production dependency (with {\ttfamily -\/-\/save}).


\begin{DoxyCode}
npm install --save babel-runtime
\end{DoxyCode}


The transformation plugin is typically used only in development, but the runtime itself will be depended on by your deployed/published code. See the examples below for more details.

\subsection*{Usage}

\subsubsection*{Via {\ttfamily .babelrc} (Recommended)}

Add the following line to your {\ttfamily .babelrc} file\+:


\begin{DoxyCode}
// without options
\{
  "plugins": ["transform-runtime"]
\}

// with options
\{
  "plugins": [
    ["transform-runtime", \{
      "helpers": false, // defaults to true
      "polyfill": false, // defaults to true
      "regenerator": true, // defaults to true
      "moduleName": "babel-runtime" // defaults to "babel-runtime"
    \}]
  ]
\}
\end{DoxyCode}


\subsubsection*{Via C\+LI}


\begin{DoxyCode}
babel --plugins transform-runtime script.js
\end{DoxyCode}


\subsubsection*{Via Node A\+PI}


\begin{DoxyCode}
require("babel-core").transform("code", \{
  plugins: ["transform-runtime"]
\});
\end{DoxyCode}


\subsection*{Technical details}

The {\ttfamily runtime} transformer plugin does three things\+:


\begin{DoxyItemize}
\item Automatically requires {\ttfamily babel-\/runtime/regenerator} when you use generators/async functions.
\item Automatically requires {\ttfamily babel-\/runtime/core-\/js} and maps E\+S6 static methods and built-\/ins.
\item Removes the inline babel helpers and uses the module {\ttfamily babel-\/runtime/helpers} instead.
\end{DoxyItemize}

What does this actually mean though? Basically, you can use built-\/ins such as {\ttfamily Promise}, {\ttfamily Set}, {\ttfamily Symbol} etc as well use all the Babel features that require a polyfill seamlessly, without global pollution, making it extremely suitable for libraries.

Make sure you include {\ttfamily babel-\/runtime} as a dependency.

\subsubsection*{Regenerator aliasing}

Whenever you use a generator function or async function\+:


\begin{DoxyCode}
function* foo() \{

\}
\end{DoxyCode}


the following is generated\+:


\begin{DoxyCode}
"use strict";

var \_marked = [foo].map(regeneratorRuntime.mark);

function foo() \{
  return regeneratorRuntime.wrap(function foo$(\_context) \{
    while (1) switch (\_context.prev = \_context.next) \{
      case 0:
      case "end":
        return \_context.stop();
    \}
  \}, \_marked[0], this);
\}
\end{DoxyCode}


This isn\textquotesingle{}t ideal as then you have to include the regenerator runtime which pollutes the global scope.

Instead what the {\ttfamily runtime} transformer does it compile that to\+:


\begin{DoxyCode}
"use strict";

var \_regenerator = require("babel-runtime/regenerator");

var \_regenerator2 = \_interopRequireDefault(\_regenerator);

function \_interopRequireDefault(obj) \{ return obj && obj.\_\_esModule ? obj : \{ default: obj \}; \}

var \_marked = [foo].map(\_regenerator2.default.mark);

function foo() \{
  return regeneratorRuntime.wrap(function foo$(\_context) \{
    while (1) switch (\_context.prev = \_context.next) \{
      case 0:
      case "end":
        return \_context.stop();
    \}
  \}, \_marked[0], this);
\}
\end{DoxyCode}


This means that you can use the regenerator runtime without polluting your current environment.

\subsubsection*{{\ttfamily core-\/js} aliasing}

Sometimes you may want to use new built-\/ins such as {\ttfamily Map}, {\ttfamily Set}, {\ttfamily Promise} etc. Your only way to use these is usually to include a globally polluting polyfill.

What the {\ttfamily runtime} transformer does is transform the following\+:


\begin{DoxyCode}
var sym = Symbol();

var promise = new Promise;

console.log(arr[Symbol.iterator]());
\end{DoxyCode}


into the following\+:


\begin{DoxyCode}
"use strict";

var \_getIterator2 = require("babel-runtime/core-js/get-iterator");

var \_getIterator3 = \_interopRequireDefault(\_getIterator2);

var \_promise = require("babel-runtime/core-js/promise");

var \_promise2 = \_interopRequireDefault(\_promise);

var \_symbol = require("babel-runtime/core-js/symbol");

var \_symbol2 = \_interopRequireDefault(\_symbol);

function \_interopRequireDefault(obj) \{ return obj && obj.\_\_esModule ? obj : \{ default: obj \}; \}

var sym = (0, \_symbol2.default)();

var promise = new \_promise2.default();

console.log((0, \_getIterator3.default)(arr));
\end{DoxyCode}


This means is that you can seamlessly use these native built-\/ins and static methods without worrying about where they come from.

{\bfseries N\+O\+TE\+:} Instance methods such as {\ttfamily \char`\"{}foobar\char`\"{}.includes(\char`\"{}foo\char`\"{})} will {\bfseries not} work.

\subsubsection*{Helper aliasing}

Usually babel will place helpers at the top of your file to do common tasks to avoid duplicating the code around in the current file. Sometimes these helpers can get a little bulky and add unnecessary duplication across files. The {\ttfamily runtime} transformer replaces all the helper calls to a module.

That means that the following code\+:


\begin{DoxyCode}
class Person \{
\}
\end{DoxyCode}


usually turns into\+:


\begin{DoxyCode}
"use strict";

function \_classCallCheck(instance, Constructor) \{ if (!(instance instanceof Constructor)) \{ throw new
       TypeError("Cannot call a class as a function"); \} \}

var Person = function Person() \{
  \_classCallCheck(this, Person);
\};
\end{DoxyCode}


the {\ttfamily runtime} transformer however turns this into\+:


\begin{DoxyCode}
"use strict";

var \_classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var \_classCallCheck3 = \_interopRequireDefault(\_classCallCheck2);

function \_interopRequireDefault(obj) \{ return obj && obj.\_\_esModule ? obj : \{ default: obj \}; \}

var Person = function Person() \{
  (0, \_classCallCheck3.default)(this, Person);
\};
\end{DoxyCode}
 