
\begin{DoxyItemize}
\item Travis CI build\+: \href{http://travis-ci.org/faye/faye-websocket-node}{\tt }
\item Autobahn tests\+: \href{http://faye.jcoglan.com/autobahn/servers/}{\tt server}, \href{http://faye.jcoglan.com/autobahn/clients/}{\tt client}
\end{DoxyItemize}

This is a general-\/purpose Web\+Socket implementation extracted from the \href{http://faye.jcoglan.com}{\tt Faye} project. It provides classes for easily building Web\+Socket servers and clients in Node. It does not provide a server itself, but rather makes it easy to handle Web\+Socket connections within an existing \href{https://nodejs.org/}{\tt Node} application. It does not provide any abstraction other than the standard \href{https://html.spec.whatwg.org/multipage/comms.html#network}{\tt Web\+Socket A\+PI}.

It also provides an abstraction for handling \href{https://html.spec.whatwg.org/multipage/comms.html#server-sent-events}{\tt Event\+Source} connections, which are one-\/way connections that allow the server to push data to the client. They are based on streaming H\+T\+TP responses and can be easier to access via proxies than Web\+Sockets.

\subsection*{Installation}


\begin{DoxyCode}
$ npm install faye-websocket
\end{DoxyCode}


\subsection*{Handling Web\+Socket connections in Node}

You can handle Web\+Sockets on the server side by listening for H\+T\+TP Upgrade requests, and creating a new socket for the request. This socket object exposes the usual Web\+Socket methods for receiving and sending messages. For example this is how you\textquotesingle{}d implement an echo server\+:


\begin{DoxyCode}
var WebSocket = require('faye-websocket'),
    http      = require('http');

var server = http.createServer();

server.on('upgrade', function(request, socket, body) \{
  if (WebSocket.isWebSocket(request)) \{
    var ws = new WebSocket(request, socket, body);

    ws.on('message', function(event) \{
      ws.send(event.data);
    \});

    ws.on('close', function(event) \{
      console.log('close', event.code, event.reason);
      ws = null;
    \});
  \}
\});

server.listen(8000);
\end{DoxyCode}


{\ttfamily Web\+Socket} objects are also duplex streams, so you could replace the `ws.\+on(\textquotesingle{}message', ...)\`{} line with\+:


\begin{DoxyCode}
ws.pipe(ws);
\end{DoxyCode}


Note that under certain circumstances (notably a draft-\/76 client connecting through an H\+T\+TP proxy), the Web\+Socket handshake will not be complete after you call {\ttfamily new Web\+Socket()} because the server will not have received the entire handshake from the client yet. In this case, calls to {\ttfamily ws.\+send()} will buffer the message in memory until the handshake is complete, at which point any buffered messages will be sent to the client.

If you need to detect when the Web\+Socket handshake is complete, you can use the {\ttfamily onopen} event.

If the connection\textquotesingle{}s protocol version supports it, you can call {\ttfamily ws.\+ping()} to send a ping message and wait for the client\textquotesingle{}s response. This method takes a message string, and an optional callback that fires when a matching pong message is received. It returns {\ttfamily true} if and only if a ping message was sent. If the client does not support ping/pong, this method sends no data and returns {\ttfamily false}.


\begin{DoxyCode}
ws.ping('Mic check, one, two', function() \{
  // fires when pong is received
\});
\end{DoxyCode}


\subsection*{Using the Web\+Socket client}

The client supports both the plain-\/text {\ttfamily ws} protocol and the encrypted {\ttfamily wss} protocol, and has exactly the same interface as a socket you would use in a web browser. On the wire it identifies itself as {\ttfamily hybi-\/13}.


\begin{DoxyCode}
var WebSocket = require('faye-websocket'),
    ws        = new WebSocket.Client('ws://www.example.com/');

ws.on('open', function(event) \{
  console.log('open');
  ws.send('Hello, world!');
\});

ws.on('message', function(event) \{
  console.log('message', event.data);
\});

ws.on('close', function(event) \{
  console.log('close', event.code, event.reason);
  ws = null;
\});
\end{DoxyCode}


The Web\+Socket client also lets you inspect the status and headers of the handshake response via its {\ttfamily status\+Code} and {\ttfamily headers} properties.

To connect via a proxy, set the {\ttfamily proxy} option to the H\+T\+TP origin of the proxy, including any authorization information, custom headers and T\+LS config you require. Only the {\ttfamily origin} setting is required.


\begin{DoxyCode}
var ws = new WebSocket.Client('ws://www.example.com/', [], \{
  proxy: \{
    origin:  'http://username:password@proxy.example.com',
    headers: \{'User-Agent': 'node'\},
    tls:     \{cert: fs.readFileSync('client.crt')\}
  \}
\});
\end{DoxyCode}


The {\ttfamily tls} value is an object that will be passed to \href{https://nodejs.org/api/tls.html#tls_tls_connect_options_callback}{\tt {\ttfamily tls.\+connect()}}.

\subsection*{Subprotocol negotiation}

The Web\+Socket protocol allows peers to select and identify the application protocol to use over the connection. On the client side, you can set which protocols the client accepts by passing a list of protocol names when you construct the socket\+:


\begin{DoxyCode}
var ws = new WebSocket.Client('ws://www.example.com/', ['irc', 'amqp']);
\end{DoxyCode}


On the server side, you can likewise pass in the list of protocols the server supports after the other constructor arguments\+:


\begin{DoxyCode}
var ws = new WebSocket(request, socket, body, ['irc', 'amqp']);
\end{DoxyCode}


If the client and server agree on a protocol, both the client-\/ and server-\/side socket objects expose the selected protocol through the {\ttfamily ws.\+protocol} property.

\subsection*{Protocol extensions}

faye-\/websocket is based on the \href{https://github.com/faye/websocket-extensions-node}{\tt websocket-\/extensions} framework that allows extensions to be negotiated via the {\ttfamily Sec-\/\+Web\+Socket-\/\+Extensions} header. To add extensions to a connection, pass an array of extensions to the {\ttfamily \+:extensions} option. For example, to add \href{https://github.com/faye/permessage-deflate-node}{\tt permessage-\/deflate}\+:


\begin{DoxyCode}
var deflate = require('permessage-deflate');

var ws = new WebSocket(request, socket, body, [], \{extensions: [deflate]\});
\end{DoxyCode}


\subsection*{Initialization options}

Both the server-\/ and client-\/side classes allow an options object to be passed in at initialization time, for example\+:


\begin{DoxyCode}
var ws = new WebSocket(request, socket, body, protocols, options);
var ws = new WebSocket.Client(url, protocols, options);
\end{DoxyCode}


{\ttfamily protocols} is an array of subprotocols as described above, or {\ttfamily null}. {\ttfamily options} is an optional object containing any of these fields\+:


\begin{DoxyItemize}
\item {\ttfamily extensions} -\/ an array of \href{https://github.com/faye/websocket-extensions-node}{\tt websocket-\/extensions} compatible extensions, as described above
\item {\ttfamily headers} -\/ an object containing key-\/value pairs representing H\+T\+TP headers to be sent during the handshake process
\item {\ttfamily max\+Length} -\/ the maximum allowed size of incoming message frames, in bytes. The default value is {\ttfamily 2$^\wedge$26 -\/ 1}, or 1 byte short of 64 MiB.
\item {\ttfamily ping} -\/ an integer that sets how often the Web\+Socket should send ping frames, measured in seconds
\end{DoxyItemize}

The client accepts some additional options\+:


\begin{DoxyItemize}
\item {\ttfamily proxy} -\/ settings for a proxy as described above
\item {\ttfamily net} -\/ an object containing settings for the origin server that will be passed to \href{https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener}{\tt {\ttfamily net.\+connect()}}
\item {\ttfamily tls} -\/ an object containing T\+LS settings for the origin server, this will be passed to \href{https://nodejs.org/api/tls.html#tls_tls_connect_options_callback}{\tt {\ttfamily tls.\+connect()}}
\item {\ttfamily ca} -\/ (legacy) a shorthand for passing {\ttfamily \{tls\+: \{ca\+: value\}\}}
\end{DoxyItemize}

\subsection*{Web\+Socket A\+PI}

Both server-\/ and client-\/side {\ttfamily Web\+Socket} objects support the following A\+PI.


\begin{DoxyItemize}
\item {\bfseries `on(\textquotesingle{}open', function(event) \{\})\`{}} fires when the socket connection is established. Event has no attributes.
\item {\bfseries `on(\textquotesingle{}message', function(event) \{\}){\ttfamily $<$/b$>$ fires when the socket receives a message. Event has one attribute, $<$b$>$}data{\ttfamily $<$/b$>$, which is either a}String{\ttfamily  (for text frames) or a}Buffer$<$tt$>$(for binary frames).}
\item {\bfseries $<$b$>$on(\textquotesingle{}error\textquotesingle{}, function(event) \{\})\`{}} fires when there is a protocol error due to bad data sent by the other peer. This event is purely informational, you do not need to implement error recover.
\item {\bfseries `on(\textquotesingle{}close', function(event) \{\}){\ttfamily $<$/b$>$ fires when either the client or the server closes the connection. Event has two optional attributes, $<$b$>$}code{\ttfamily $<$/b$>$ and $<$b$>$}reason\`{}}, that expose the status code and message sent by the peer that closed the connection.
\item {\bfseries {\ttfamily send(message)}} accepts either a {\ttfamily String} or a {\ttfamily Buffer} and sends a text or binary message over the connection to the other peer.
\item {\bfseries {\ttfamily ping(message, function() \{\})}} sends a ping frame with an optional message and fires the callback when a matching pong is received.
\item {\bfseries {\ttfamily close(code, reason)}} closes the connection, sending the given status code and reason text, both of which are optional.
\item {\bfseries {\ttfamily version}} is a string containing the version of the {\ttfamily Web\+Socket} protocol the connection is using.
\item {\bfseries {\ttfamily protocol}} is a string (which may be empty) identifying the subprotocol the socket is using.
\end{DoxyItemize}

\subsection*{Handling Event\+Source connections in Node}

Event\+Source connections provide a very similar interface, although because they only allow the server to send data to the client, there is no {\ttfamily onmessage} A\+PI. Event\+Source allows the server to push text messages to the client, where each message has an optional event-\/type and ID.


\begin{DoxyCode}
var WebSocket   = require('faye-websocket'),
    EventSource = WebSocket.EventSource,
    http        = require('http');

var server = http.createServer();

server.on('request', function(request, response) \{
  if (EventSource.isEventSource(request)) \{
    var es = new EventSource(request, response);
    console.log('open', es.url, es.lastEventId);

    // Periodically send messages
    var loop = setInterval(function() \{ es.send('Hello') \}, 1000);

    es.on('close', function() \{
      clearInterval(loop);
      es = null;
    \});

  \} else \{
    // Normal HTTP request
    response.writeHead(200, \{'Content-Type': 'text/plain'\});
    response.end('Hello');
  \}
\});

server.listen(8000);
\end{DoxyCode}


The {\ttfamily send} method takes two optional parameters, {\ttfamily event} and {\ttfamily id}. The default event-\/type is `\textquotesingle{}message'{\ttfamily with no ID. For example, to send a}notification{\ttfamily  event with ID}99\`{}\+:


\begin{DoxyCode}
es.send('Breaking News!', \{event: 'notification', id: '99'\});
\end{DoxyCode}


The {\ttfamily Event\+Source} object exposes the following properties\+:


\begin{DoxyItemize}
\item {\bfseries {\ttfamily url}} is a string containing the \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} the client used to create the Event\+Source.
\item {\bfseries {\ttfamily last\+Event\+Id}} is a string containing the last event ID received by the client. You can use this when the client reconnects after a dropped connection to determine which messages need resending.
\end{DoxyItemize}

When you initialize an Event\+Source with {\ttfamily new Event\+Source()}, you can pass configuration options after the {\ttfamily response} parameter. Available options are\+:


\begin{DoxyItemize}
\item {\bfseries {\ttfamily headers}} is an object containing custom headers to be set on the Event\+Source response.
\item {\bfseries {\ttfamily retry}} is a number that tells the client how long (in seconds) it should wait after a dropped connection before attempting to reconnect.
\item {\bfseries {\ttfamily ping}} is a number that tells the server how often (in seconds) to send \textquotesingle{}ping\textquotesingle{} packets to the client to keep the connection open, to defeat timeouts set by proxies. The client will ignore these messages.
\end{DoxyItemize}

For example, this creates a connection that allows access from any origin, pings every 15 seconds and is retryable every 10 seconds if the connection is broken\+:


\begin{DoxyCode}
var es = new EventSource(request, response, \{
  headers: \{'Access-Control-Allow-Origin': '*'\},
  ping:    15,
  retry:   10
\});
\end{DoxyCode}


You can send a ping message at any time by calling {\ttfamily es.\+ping()}. Unlike Web\+Socket, the client does not send a response to this; it is merely to send some data over the wire to keep the connection alive.

\subsection*{License}

(The M\+IT License)

Copyright (c) 2010-\/2017 James Coglan

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \textquotesingle{}Software\textquotesingle{}), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions\+:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

T\+HE S\+O\+F\+T\+W\+A\+RE IS P\+R\+O\+V\+I\+D\+ED \textquotesingle{}AS IS\textquotesingle{}, W\+I\+T\+H\+O\+UT W\+A\+R\+R\+A\+N\+TY OF A\+NY K\+I\+ND, E\+X\+P\+R\+E\+SS OR I\+M\+P\+L\+I\+ED, I\+N\+C\+L\+U\+D\+I\+NG B\+UT N\+OT L\+I\+M\+I\+T\+ED TO T\+HE W\+A\+R\+R\+A\+N\+T\+I\+ES OF M\+E\+R\+C\+H\+A\+N\+T\+A\+B\+I\+L\+I\+TY, F\+I\+T\+N\+E\+SS F\+OR A P\+A\+R\+T\+I\+C\+U\+L\+AR P\+U\+R\+P\+O\+SE A\+ND N\+O\+N\+I\+N\+F\+R\+I\+N\+G\+E\+M\+E\+NT. IN NO E\+V\+E\+NT S\+H\+A\+LL T\+HE A\+U\+T\+H\+O\+RS OR C\+O\+P\+Y\+R\+I\+G\+HT H\+O\+L\+D\+E\+RS BE L\+I\+A\+B\+LE F\+OR A\+NY C\+L\+A\+IM, D\+A\+M\+A\+G\+ES OR O\+T\+H\+ER L\+I\+A\+B\+I\+L\+I\+TY, W\+H\+E\+T\+H\+ER IN AN A\+C\+T\+I\+ON OF C\+O\+N\+T\+R\+A\+CT, T\+O\+RT OR O\+T\+H\+E\+R\+W\+I\+SE, A\+R\+I\+S\+I\+NG F\+R\+OM, O\+UT OF OR IN C\+O\+N\+N\+E\+C\+T\+I\+ON W\+I\+TH T\+HE S\+O\+F\+T\+W\+A\+RE OR T\+HE U\+SE OR O\+T\+H\+ER D\+E\+A\+L\+I\+N\+GS IN T\+HE S\+O\+F\+T\+W\+A\+RE. 