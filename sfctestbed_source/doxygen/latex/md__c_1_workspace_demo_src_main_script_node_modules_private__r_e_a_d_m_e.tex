A general-\/purpose utility for associating truly private state with any Java\+Script object.

\subsection*{Installation }

From N\+PM\+: \begin{DoxyVerb}npm install private
\end{DoxyVerb}


From Git\+Hub\+: \begin{DoxyVerb}cd path/to/node_modules
git clone git://github.com/benjamn/private.git
cd private
npm install .
\end{DoxyVerb}


\subsection*{Usage }

{\bfseries Get or create a secret object associated with any (non-\/frozen) object\+:} 
\begin{DoxyCode}
var getSecret = require("private").makeAccessor();
var obj = Object.create(null); // any kind of object works
getSecret(obj).totallySafeProperty = "p455w0rd";

console.log(Object.keys(obj)); // []
console.log(Object.getOwnPropertyNames(obj)); // []
console.log(getSecret(obj)); // \{ totallySafeProperty: "p455w0rd" \}
\end{DoxyCode}
 Now, only code that has a reference to both {\ttfamily get\+Secret} and {\ttfamily obj} can possibly access {\ttfamily .totally\+Safe\+Property}.

{\itshape Importantly, no global references to the secret object are retained by the {\ttfamily private} package, so as soon as {\ttfamily obj} gets garbage collected, the secret will be reclaimed as well. In other words, you don\textquotesingle{}t have to worry about memory leaks.}

{\bfseries Create a unique property name that cannot be enumerated or guessed\+:} 
\begin{DoxyCode}
var secretKey = require("private").makeUniqueKey();
var obj = Object.create(null); // any kind of object works

Object.defineProperty(obj, secretKey, \{
  value: \{ totallySafeProperty: "p455w0rd" \},
  enumerable: false // optional; non-enumerability is the default
\});

Object.defineProperty(obj, "nonEnumerableProperty", \{
  value: "anyone can guess my name",
  enumerable: false
\});

console.log(obj[secretKey].totallySafeProperty); // p455w0rd
console.log(obj.nonEnumerableProperty); // "anyone can guess my name"
console.log(Object.keys(obj)); // []
console.log(Object.getOwnPropertyNames(obj)); // ["nonEnumerableProperty"]

for (var key in obj) \{
  console.log(key); // never called
\}
\end{DoxyCode}
 Because these keys are non-\/enumerable, you can\textquotesingle{}t discover them using a {\ttfamily for}-\/{\ttfamily in} loop. Because {\ttfamily secret\+Key} is a long string of random characters, you would have a lot of trouble guessing it. And because the {\ttfamily private} module wraps {\ttfamily Object.\+get\+Own\+Property\+Names} to exclude the keys it generates, you can\textquotesingle{}t even use that interface to discover it.

Unless you have access to the value of the {\ttfamily secret\+Key} property name, there is no way to access the value associated with it. So your only responsibility as secret-\/keeper is to avoid handing out the value of {\ttfamily secret\+Key} to untrusted code.

Think of this style as a home-\/grown version of the first style. Note, however, that it requires a full implementation of E\+S5\textquotesingle{}s {\ttfamily Object.\+define\+Property} method in order to make any safety guarantees, whereas the first example will provide safety even in environments that do not support {\ttfamily Object.\+define\+Property}.

\subsection*{Rationale }

In Java\+Script, the only data that are truly private are local variables whose values do not {\itshape leak} from the scope in which they were defined.

This notion of {\itshape closure privacy} is powerful, and it readily provides some of the benefits of traditional data privacy, a la Java or C++\+: 
\begin{DoxyCode}
function MyClass(secret) \{
    this.increment = function() \{
        return ++secret;
    \};
\}

var mc = new MyClass(3);
console.log(mc.increment()); // 4
\end{DoxyCode}
 You can learn something about {\ttfamily secret} by calling {\ttfamily .increment()}, and you can increase its value by one as many times as you like, but you can never decrease its value, because it is completely inaccessible except through the {\ttfamily .increment} method. And if the {\ttfamily .increment} method were not available, it would be as if no {\ttfamily secret} variable had ever been declared, as far as you could tell.

This style breaks down as soon as you want to inherit methods from the prototype of a class\+: 
\begin{DoxyCode}
function MyClass(secret) \{
    this.secret = secret;
\}

MyClass.prototype.increment = function() \{
    return ++this.secret;
\};
\end{DoxyCode}
 The only way to communicate between the {\ttfamily My\+Class} constructor and the {\ttfamily .increment} method in this example is to manipulate shared properties of {\ttfamily this}. Unfortunately {\ttfamily this.\+secret} is now exposed to unlicensed modification\+: 
\begin{DoxyCode}
var mc = new MyClass(6);
console.log(mc.increment()); // 7
mc.secret -= Infinity;
console.log(mc.increment()); // -Infinity
mc.secret = "Go home JavaScript, you're drunk.";
mc.increment(); // NaN
\end{DoxyCode}
 Another problem with closure privacy is that it only lends itself to per-\/instance privacy, whereas the {\ttfamily private} keyword in most object-\/oriented languages indicates that the data member in question is visible to all instances of the same class.

Suppose you have a {\ttfamily Node} class with a notion of parents and children\+: 
\begin{DoxyCode}
function Node() \{
    var parent;
    var children = [];

    this.getParent = function() \{
        return parent;
    \};

    this.appendChild = function(child) \{
        children.push(child);
        child.parent = this; // Can this be made to work?
    \};
\}
\end{DoxyCode}
 The desire here is to allow other {\ttfamily Node} objects to manipulate the value returned by {\ttfamily .get\+Parent()}, but otherwise disallow any modification of the {\ttfamily parent} variable. You could expose a {\ttfamily .set\+Parent} function, but then anyone could call it, and you might as well give up on the getter/setter pattern.

This module solves both of these problems.

\subsection*{Usage }

Let\textquotesingle{}s revisit the {\ttfamily Node} example from above\+: 
\begin{DoxyCode}
var p = require("private").makeAccessor();

function Node() \{
    var privates = p(this);
    var children = [];

    this.getParent = function() \{
        return privates.parent;
    \};

    this.appendChild = function(child) \{
        children.push(child);
        var cp = p(child);
        if (cp.parent)
            cp.parent.removeChild(child);
        cp.parent = this;
        return child;
    \};
\}
\end{DoxyCode}
 Now, in order to access the private data of a {\ttfamily Node} object, you need to have access to the unique {\ttfamily p} function that is being used here. This is already an improvement over the previous example, because it allows restricted access by other {\ttfamily Node} instances, but can it help with the {\ttfamily Node.\+prototype} problem too?

Yes it can! 
\begin{DoxyCode}
var p = require("private").makeAccessor();

function Node() \{
    p(this).children = [];
\}

var Np = Node.prototype;

Np.getParent = function() \{
    return p(this).parent;
\};

Np.appendChild = function(child) \{
    p(this).children.push(child);
    var cp = p(child);
    if (cp.parent)
        cp.parent.removeChild(child);
    cp.parent = this;
    return child;
\};
\end{DoxyCode}
 Because {\ttfamily p} is in scope not only within the {\ttfamily Node} constructor but also within {\ttfamily Node} methods, we can finally avoid redefining methods every time the {\ttfamily Node} constructor is called.

Now, you might be wondering how you can restrict access to {\ttfamily p} so that no untrusted code is able to call it. The answer is to use your favorite module pattern, be it Common\+JS, A\+MD {\ttfamily define}, or even the old Immediately-\/\+Invoked Function Expression\+: 
\begin{DoxyCode}
var Node = (function() \{
    var p = require("private").makeAccessor();

    function Node() \{
        p(this).children = [];
    \}

    var Np = Node.prototype;

    Np.getParent = function() \{
        return p(this).parent;
    \};

    Np.appendChild = function(child) \{
        p(this).children.push(child);
        var cp = p(child);
        if (cp.parent)
            cp.parent.removeChild(child);
        cp.parent = this;
        return child;
    \};

    return Node;
\}());

var parent = new Node;
var child = new Node;
parent.appendChild(child);
assert.strictEqual(child.getParent(), parent);
\end{DoxyCode}
 Because this version of {\ttfamily p} never leaks from the enclosing function scope, only {\ttfamily Node} objects have access to it.

So, you see, the claim I made at the beginning of this R\+E\+A\+D\+ME remains true\+:

\begin{quote}
In Java\+Script, the only data that are truly private are local variables whose values do not {\itshape leak} from the scope in which they were defined. \end{quote}


It just so happens that closure privacy is sufficient to implement a privacy model similar to that provided by other languages. 