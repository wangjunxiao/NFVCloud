\href{http://travis-ci.org/WebReflection/circular-json}{\tt }

Serializes and deserializes otherwise valid J\+S\+ON objects containing circular references into and from a specialized J\+S\+ON format.

\section*{Example }

\subsubsection*{A Working Solution To A Common Problem}

A usage example\+:


\begin{DoxyCode}
var object = \{\};
object.arr = [
  object, object
];
object.arr.push(object.arr);
object.obj = object;

var serialized = CircularJSON.stringify(object);
// '\{"arr":["~","~","~arr"],"obj":"~"\}'
// NOTE: CircularJSON DOES NOT parse JS
// it handles receiver and reviver callbacks

var unserialized = CircularJSON.parse(serialized);
// \{ arr: [ [Circular], [Circular] ],
// obj: [Circular] \}

unserialized.obj === unserialized;
unserialized.arr[0] === unserialized;
unserialized.arr.pop() === unserialized.arr;
\end{DoxyCode}


A quick summary\+:


\begin{DoxyItemize}
\item uses {\ttfamily $\sim$} as a special prefix symbol to denote which parent the reference belongs to (i.\+e. {\ttfamily $\sim$root$\sim$child1$\sim$child2})
\item reasonably fast in both serialization and deserialization
\item compact serialization for easier and slimmer transportation across environments
\item \href{test/circular-json.js}{\tt tested and covered} over nasty structures too
\item compatible with all Java\+Script engines
\end{DoxyItemize}

\section*{Node Installation \& Usage }


\begin{DoxyCode}
npm install --save circular-json
\end{DoxyCode}



\begin{DoxyCode}
'use strict';

var CircularJSON = require('circular-json')
  , obj = \{ foo: 'bar' \}
  , str
  ;

obj.self = obj;
str = CircularJSON.stringify(obj);
\end{DoxyCode}


There are no dependencies.

\section*{Browser Installation \& Usage }


\begin{DoxyItemize}
\item Global\+: $<$build/circular-\/json.\+js$>$
\item A\+MD\+: $<$build/circular-\/json.\+amd.\+js$>$
\item Common\+JS\+: $<$build/circular-\/json.\+node.\+js$>$
\end{DoxyItemize}

(generated via \href{https://github.com/WebReflection/gitstrap}{\tt gitstrap})


\begin{DoxyCode}
<script src="build/circular-json.js"></script>
\end{DoxyCode}



\begin{DoxyCode}
'use strict';

var CircularJSON = window.CircularJSON
  , obj = \{ foo: 'bar' \}
  , str
  ;

obj.self = obj;
str = CircularJSON.stringify(obj);
\end{DoxyCode}


N\+O\+TE\+: Platforms without native J\+S\+ON (i.\+e. M\+S\+IE $<$= 8) requires {\ttfamily json3.\+js} or similar.

It is also {\itshape a bad idea} to {\ttfamily Circular\+J\+S\+O\+N.\+parse(J\+S\+O\+N.\+stringify(object))} because of those manipulation used in {\ttfamily Circular\+J\+S\+O\+N.\+stringify()} able to make parsing safe and secure.

As summary\+: {\ttfamily Circular\+J\+S\+O\+N.\+parse(Circular\+J\+S\+O\+N.\+stringify(object))} is the way to go, same is for {\ttfamily J\+S\+O\+N.\+parse(J\+S\+O\+N.\+stringify(object))}.

\section*{A\+PI }

It\textquotesingle{}s the same as native J\+S\+ON, except the fourth parameter {\ttfamily placeholder}, which circular references to be replaced with {\ttfamily \char`\"{}\mbox{[}\+Circular\mbox{]}\char`\"{}} (i.\+e. for logging).


\begin{DoxyItemize}
\item Circular\+J\+S\+O\+N.\+stringify(object, replacer, spacer, placeholder)
\item Circular\+J\+S\+O\+N.\+parse(string, reviver)
\end{DoxyItemize}

Bear in mind {\ttfamily J\+S\+O\+N.\+parse(Circular\+J\+S\+O\+N.\+stringify(object))} will work but not produce the expected output.

\section*{Similar Libraries }

\subsubsection*{Why Not the \href{https://twitter.com/izs}{\tt } One}

The module \href{https://github.com/isaacs/json-stringify-safe}{\tt json-\/stringify-\/safe} seems to be for {\ttfamily console.\+log()} but it\textquotesingle{}s completely pointless for {\ttfamily J\+S\+O\+N.\+parse()}, being latter one unable to retrieve back the initial structure. Here an example\+:


\begin{DoxyCode}
// a logged object with circular references
\{
  "circularRef": "[Circular]",
  "list": [
    "[Circular]",
    "[Circular]"
  ]
\}
// what do we do with above output ?
\end{DoxyCode}


Just type this in your {\ttfamily node} console\+: {\ttfamily var o = \{\}; o.\+a = o; console.\+log(o);}. The output will be {\ttfamily \{ a\+: \mbox{[}Circular\mbox{]} \}} ... good, but that ain\textquotesingle{}t really solving the problem.

However, if that\textquotesingle{}s all you need, the function used to create that kind of output is probably faster than {\ttfamily Circular\+J\+S\+ON} and surely fits in less lines of code.

\subsubsection*{Why Not \{\{put random name\}\} Solution}

So here the thing\+: circular references can be wrong but, if there is a need for them, any attempt to ignore them or remove them can be considered just a failure.

Not because the method is bad or it\textquotesingle{}s not working, simply because the circular info, the one we needed and used in the first place, is lost!

In this case, {\ttfamily Circular\+J\+S\+ON} does even more than just solve circular and recursions\+: it maps all same objects so that less memory is used as well on deserialization as less bandwidth too! It\textquotesingle{}s able to redefine those references back later on so the way we store is the way we retrieve and in a reasonably performant way, also trusting the snappy and native {\ttfamily J\+S\+ON} methods to iterate. 