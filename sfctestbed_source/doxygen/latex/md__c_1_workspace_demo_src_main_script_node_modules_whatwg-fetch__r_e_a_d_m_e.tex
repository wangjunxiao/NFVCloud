The {\ttfamily fetch()} function is a Promise-\/based mechanism for programmatically making web requests in the browser. This project is a polyfill that implements a subset of the standard \href{https://fetch.spec.whatwg.org}{\tt Fetch specification}, enough to make {\ttfamily fetch} a viable replacement for most uses of X\+M\+L\+Http\+Request in traditional web applications.

This project adheres to the \href{http://todogroup.org/opencodeofconduct/#fetch/opensource@github.com}{\tt Open Code of Conduct}. By participating, you are expected to uphold this code.

\subsection*{Table of Contents}


\begin{DoxyItemize}
\item \href{#read-this-first}{\tt Read this first}
\item \href{#installation}{\tt Installation}
\item \href{#usage}{\tt Usage}
\begin{DoxyItemize}
\item \href{#html}{\tt H\+T\+ML}
\item \href{#json}{\tt J\+S\+ON}
\item \href{#response-metadata}{\tt Response metadata}
\item \href{#post-form}{\tt Post form}
\item \href{#post-json}{\tt Post J\+S\+ON}
\item \href{#file-upload}{\tt File upload}
\item \href{#caveats}{\tt Caveats}
\begin{DoxyItemize}
\item \href{#handling-http-error-statuses}{\tt Handling H\+T\+TP error statuses}
\item \href{#sending-cookies}{\tt Sending cookies}
\item \href{#receiving-cookies}{\tt Receiving cookies}
\item \href{#obtaining-the-response-url}{\tt Obtaining the Response U\+RL}
\end{DoxyItemize}
\end{DoxyItemize}
\item \href{#browser-support}{\tt Browser Support}
\end{DoxyItemize}

\subsection*{Read this first}


\begin{DoxyItemize}
\item If you believe you found a bug with how {\ttfamily fetch} behaves in Chrome or Firefox, please {\bfseries avoid opening an issue in this repository}. This project is a {\itshape polyfill}, and since Chrome and Firefox both implement the {\ttfamily window.\+fetch} function natively, no code from this project actually takes any effect in these browsers. See \href{#browser-support}{\tt Browser support} for detailed information.
\item If you have trouble {\bfseries making a request to another domain} (a different subdomain or port number also constitutes as another domain), please familiarize yourself with all the intricacies and limitations of \href{https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS}{\tt C\+O\+RS} requests. Because C\+O\+RS requires participation of the server by implementing specific H\+T\+TP response headers, it is often nontrivial to set up or debug. C\+O\+RS is exclusively handled by the browser\textquotesingle{}s internal mechanisms which this polyfill cannot influence.
\item If you have trouble {\bfseries maintaining the user\textquotesingle{}s session} or \href{https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet}{\tt C\+S\+RF} protection through {\ttfamily fetch} requests, please ensure that you\textquotesingle{}ve read and understood the \href{#sending-cookies}{\tt Sending cookies} section.
\item If this polyfill {\bfseries doesn\textquotesingle{}t work under Node.\+js environments}, that is expected, because this project is meant for web browsers only. You should ensure that your application doesn\textquotesingle{}t try to package and run this on the server.
\item If you have an idea for a new feature of {\ttfamily fetch}, please understand that we are only ever going to add features and A\+P\+Is that are a part of the \href{https://fetch.spec.whatwg.org}{\tt Fetch specification}. You should {\bfseries submit your feature requests} to the \href{https://github.com/whatwg/fetch/issues}{\tt repository of the specification} itself, rather than this repository.
\end{DoxyItemize}

\subsection*{Installation}


\begin{DoxyItemize}
\item {\ttfamily npm install whatwg-\/fetch -\/-\/save}; or
\item {\ttfamily bower install fetch}.
\end{DoxyItemize}

You will also need a Promise polyfill for \href{http://caniuse.com/#feat=promises}{\tt older browsers}. We recommend \href{https://github.com/taylorhakes/promise-polyfill}{\tt taylorhakes/promise-\/polyfill} for its small size and Promises/\+A+ compatibility.

For use with webpack, add this package in the {\ttfamily entry} configuration option before your application entry point\+:


\begin{DoxyCode}
entry: ['whatwg-fetch', ...]
\end{DoxyCode}


For Babel and E\+S2015+, make sure to import the file\+:


\begin{DoxyCode}
import 'whatwg-fetch'
\end{DoxyCode}


\subsection*{Usage}

For a more comprehensive A\+PI reference that this polyfill supports, refer to \href{https://github.github.io/fetch/}{\tt https\+://github.\+github.\+io/fetch/}.

\subsubsection*{H\+T\+ML}


\begin{DoxyCode}
fetch('/users.html')
  .then(function(response) \{
    return response.text()
  \}).then(function(body) \{
    document.body.innerHTML = body
  \})
\end{DoxyCode}


\subsubsection*{J\+S\+ON}


\begin{DoxyCode}
fetch('/users.json')
  .then(function(response) \{
    return response.json()
  \}).then(function(json) \{
    console.log('parsed json', json)
  \}).catch(function(ex) \{
    console.log('parsing failed', ex)
  \})
\end{DoxyCode}


\subsubsection*{Response metadata}


\begin{DoxyCode}
fetch('/users.json').then(function(response) \{
  console.log(response.headers.get('Content-Type'))
  console.log(response.headers.get('Date'))
  console.log(response.status)
  console.log(response.statusText)
\})
\end{DoxyCode}


\subsubsection*{Post form}


\begin{DoxyCode}
var form = document.querySelector('form')

fetch('/users', \{
  method: 'POST',
  body: new FormData(form)
\})
\end{DoxyCode}


\subsubsection*{Post J\+S\+ON}


\begin{DoxyCode}
fetch('/users', \{
  method: 'POST',
  headers: \{
    'Content-Type': 'application/json'
  \},
  body: JSON.stringify(\{
    name: 'Hubot',
    login: 'hubot',
  \})
\})
\end{DoxyCode}


\subsubsection*{File upload}


\begin{DoxyCode}
var input = document.querySelector('input[type="file"]')

var data = new FormData()
data.append('file', input.files[0])
data.append('user', 'hubot')

fetch('/avatars', \{
  method: 'POST',
  body: data
\})
\end{DoxyCode}


\subsubsection*{Caveats}

The {\ttfamily fetch} specification differs from {\ttfamily j\+Query.\+ajax()} in mainly two ways that bear keeping in mind\+:


\begin{DoxyItemize}
\item The Promise returned from {\ttfamily fetch()} {\bfseries won\textquotesingle{}t reject on H\+T\+TP error status} even if the response is an H\+T\+TP 404 or 500. Instead, it will resolve normally, and it will only reject on network failure or if anything prevented the request from completing.
\item By default, {\ttfamily fetch} {\bfseries won\textquotesingle{}t send or receive any cookies} from the server, resulting in unauthenticated requests if the site relies on maintaining a user session. See \href{#sending-cookies}{\tt Sending cookies} for how to opt into cookie handling.
\end{DoxyItemize}

\paragraph*{Handling H\+T\+TP error statuses}

To have {\ttfamily fetch} Promise reject on H\+T\+TP error statuses, i.\+e. on any non-\/2xx status, define a custom response handler\+:


\begin{DoxyCode}
function checkStatus(response) \{
  if (response.status >= 200 && response.status < 300) \{
    return response
  \} else \{
    var error = new Error(response.statusText)
    error.response = response
    throw error
  \}
\}

function parseJSON(response) \{
  return response.json()
\}

fetch('/users')
  .then(checkStatus)
  .then(parseJSON)
  .then(function(data) \{
    console.log('request succeeded with JSON response', data)
  \}).catch(function(error) \{
    console.log('request failed', error)
  \})
\end{DoxyCode}


\paragraph*{Sending cookies}

To automatically send cookies for the current domain, the {\ttfamily credentials} option must be provided\+:


\begin{DoxyCode}
fetch('/users', \{
  credentials: 'same-origin'
\})
\end{DoxyCode}


The \char`\"{}same-\/origin\char`\"{} value makes {\ttfamily fetch} behave similarly to X\+M\+L\+Http\+Request with regards to cookies. Otherwise, cookies won\textquotesingle{}t get sent, resulting in these requests not preserving the authentication session.

For \href{https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS}{\tt C\+O\+RS} requests, use the \char`\"{}include\char`\"{} value to allow sending credentials to other domains\+:


\begin{DoxyCode}
fetch('https://example.com:1234/users', \{
  credentials: 'include'
\})
\end{DoxyCode}


\paragraph*{Receiving cookies}

As with X\+M\+L\+Http\+Request, the {\ttfamily Set-\/\+Cookie} response header returned from the server is a \href{https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name}{\tt forbidden header name} and therefore can\textquotesingle{}t be programmatically read with {\ttfamily response.\+headers.\+get()}. Instead, it\textquotesingle{}s the browser\textquotesingle{}s responsibility to handle new cookies being set (if applicable to the current \mbox{\hyperlink{namespace_u_r_l}{U\+RL}}). Unless they are H\+T\+T\+P-\/only, new cookies will be available through {\ttfamily document.\+cookie}.

Bear in mind that the default behavior of {\ttfamily fetch} is to ignore the {\ttfamily Set-\/\+Cookie} header completely. To opt into accepting cookies from the server, you must use the {\ttfamily credentials} option.

\paragraph*{Obtaining the Response \mbox{\hyperlink{namespace_u_r_l}{U\+RL}}}

Due to limitations of X\+M\+L\+Http\+Request, the {\ttfamily response.\+url} value might not be reliable after H\+T\+TP redirects on older browsers.

The solution is to configure the server to set the response H\+T\+TP header {\ttfamily X-\/\+Request-\/\+U\+RL} to the current \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} after any redirect that might have happened. It should be safe to set it unconditionally.


\begin{DoxyCode}
# Ruby on Rails controller example
response.headers['X-Request-URL'] = request.url
\end{DoxyCode}


This server workaround is necessary if you need reliable {\ttfamily response.\+url} in Firefox $<$ 32, Chrome $<$ 37, Safari, or IE.

\subsection*{Browser Support}


\begin{DoxyItemize}
\item Chrome
\item Firefox
\item Safari 6.\+1+
\item Internet Explorer 10+
\end{DoxyItemize}

Note\+: modern browsers such as Chrome, Firefox, and Microsoft Edge contain native implementations of {\ttfamily window.\+fetch}, therefore the code from this polyfill doesn\textquotesingle{}t have any effect on those browsers. If you believe you\textquotesingle{}ve encountered an error with how {\ttfamily window.\+fetch} is implemented in any of these browsers, you should file an issue with that browser vendor instead of this project. 