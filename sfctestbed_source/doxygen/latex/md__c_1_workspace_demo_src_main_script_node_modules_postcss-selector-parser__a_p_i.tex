{\itshape Please use only this documented A\+PI when working with the parser. Methods not documented here are subject to change at any point.}

\subsection*{{\ttfamily parser} function}

This is the module\textquotesingle{}s main entry point.


\begin{DoxyCode}
var parser = require('postcss-selector-parser');
\end{DoxyCode}


\subsubsection*{{\ttfamily parser(\mbox{[}transform\mbox{]})}}

Creates a new {\ttfamily processor} instance


\begin{DoxyCode}
var processor = parser();

// or, with optional transform function
var transform = function (selectors) \{
    selectors.eachUniversal(function (selector) \{
        selector.remove();
    \});
\};

var processor = parser(transform)

// Example
var result = processor.process('*.class').result;
// => .class
\end{DoxyCode}


\href{#processor}{\tt See processor documentation}

Arguments\+:


\begin{DoxyItemize}
\item {\ttfamily transform (function)}\+: Provide a function to work with the parsed A\+ST.
\end{DoxyItemize}

\subsubsection*{{\ttfamily parser.\+attribute(\mbox{[}props\mbox{]})}}

Creates a new attribute selector.


\begin{DoxyCode}
parser.attribute(\{attribute: 'href'\});
// => [href]
\end{DoxyCode}


Arguments\+:


\begin{DoxyItemize}
\item {\ttfamily props (object)}\+: The new node\textquotesingle{}s properties.
\end{DoxyItemize}

\subsubsection*{{\ttfamily parser.\+class\+Name(\mbox{[}props\mbox{]})}}

Creates a new class selector.


\begin{DoxyCode}
parser.className(\{value: 'button'\});
// => .button
\end{DoxyCode}


Arguments\+:


\begin{DoxyItemize}
\item {\ttfamily props (object)}\+: The new node\textquotesingle{}s properties.
\end{DoxyItemize}

\subsubsection*{{\ttfamily parser.\+combinator(\mbox{[}props\mbox{]})}}

Creates a new selector combinator.


\begin{DoxyCode}
parser.combinator(\{value: '+'\});
// => +
\end{DoxyCode}


Arguments\+:


\begin{DoxyItemize}
\item {\ttfamily props (object)}\+: The new node\textquotesingle{}s properties.
\end{DoxyItemize}

\subsubsection*{{\ttfamily parser.\+comment(\mbox{[}props\mbox{]})}}

Creates a new comment.


\begin{DoxyCode}
parser.comment(\{value: '/* Affirmative, Dave. I read you. */'\});
// => /* Affirmative, Dave. I read you. */
\end{DoxyCode}


Arguments\+:


\begin{DoxyItemize}
\item {\ttfamily props (object)}\+: The new node\textquotesingle{}s properties.
\end{DoxyItemize}

\subsubsection*{{\ttfamily parser.\+id(\mbox{[}props\mbox{]})}}

Creates a new id selector.


\begin{DoxyCode}
parser.id(\{value: 'search'\});
// => #search
\end{DoxyCode}


Arguments\+:


\begin{DoxyItemize}
\item {\ttfamily props (object)}\+: The new node\textquotesingle{}s properties.
\end{DoxyItemize}

\subsubsection*{{\ttfamily parser.\+nesting(\mbox{[}props\mbox{]})}}

Creates a new nesting selector.


\begin{DoxyCode}
parser.nesting();
// => &
\end{DoxyCode}


Arguments\+:


\begin{DoxyItemize}
\item {\ttfamily props (object)}\+: The new node\textquotesingle{}s properties.
\end{DoxyItemize}

\subsubsection*{{\ttfamily parser.\+pseudo(\mbox{[}props\mbox{]})}}

Creates a new pseudo selector.


\begin{DoxyCode}
parser.pseudo(\{value: '::before'\});
// => ::before
\end{DoxyCode}


Arguments\+:


\begin{DoxyItemize}
\item {\ttfamily props (object)}\+: The new node\textquotesingle{}s properties.
\end{DoxyItemize}

\subsubsection*{{\ttfamily parser.\+root(\mbox{[}props\mbox{]})}}

Creates a new root node.


\begin{DoxyCode}
parser.root();
// => (empty)
\end{DoxyCode}


Arguments\+:


\begin{DoxyItemize}
\item {\ttfamily props (object)}\+: The new node\textquotesingle{}s properties.
\end{DoxyItemize}

\subsubsection*{{\ttfamily parser.\+selector(\mbox{[}props\mbox{]})}}

Creates a new selector node.


\begin{DoxyCode}
parser.selector();
// => (empty)
\end{DoxyCode}


Arguments\+:


\begin{DoxyItemize}
\item {\ttfamily props (object)}\+: The new node\textquotesingle{}s properties.
\end{DoxyItemize}

\subsubsection*{{\ttfamily parser.\+string(\mbox{[}props\mbox{]})}}

Creates a new string node.


\begin{DoxyCode}
parser.string();
// => (empty)
\end{DoxyCode}


Arguments\+:


\begin{DoxyItemize}
\item {\ttfamily props (object)}\+: The new node\textquotesingle{}s properties.
\end{DoxyItemize}

\subsubsection*{{\ttfamily parser.\+tag(\mbox{[}props\mbox{]})}}

Creates a new tag selector.


\begin{DoxyCode}
parser.tag(\{value: 'button'\});
// => button
\end{DoxyCode}


Arguments\+:


\begin{DoxyItemize}
\item {\ttfamily props (object)}\+: The new node\textquotesingle{}s properties.
\end{DoxyItemize}

\subsubsection*{{\ttfamily parser.\+universal(\mbox{[}props\mbox{]})}}

Creates a new universal selector.


\begin{DoxyCode}
parser.universal();
// => *
\end{DoxyCode}


Arguments\+:


\begin{DoxyItemize}
\item {\ttfamily props (object)}\+: The new node\textquotesingle{}s properties.
\end{DoxyItemize}

\subsection*{Node types}

\subsubsection*{{\ttfamily node.\+type}}

A string representation of the selector type. It can be one of the following; {\ttfamily attribute}, {\ttfamily class}, {\ttfamily combinator}, {\ttfamily comment}, {\ttfamily id}, {\ttfamily nesting}, {\ttfamily pseudo}, {\ttfamily root}, {\ttfamily selector}, {\ttfamily string}, {\ttfamily tag}, or {\ttfamily universal}. Note that for convenience, these constants are exposed on the main {\ttfamily parser} as uppercased keys. So for example you can get {\ttfamily id} by querying {\ttfamily parser.\+ID}.


\begin{DoxyCode}
parser.attribute(\{attribute: 'href'\}).type;
// => 'attribute'
\end{DoxyCode}


\subsubsection*{{\ttfamily node.\+parent}}

Returns the parent node.


\begin{DoxyCode}
root.nodes[0].parent === root;
\end{DoxyCode}


\subsubsection*{{\ttfamily node.\+to\+String()}, {\ttfamily String(node)}, or `'\textquotesingle{} + node\`{}}

Returns a string representation of the node.


\begin{DoxyCode}
var id = parser.id(\{value: 'search'\});
console.log(String(id));
// => #search
\end{DoxyCode}


\subsubsection*{{\ttfamily node.\+next()} \& {\ttfamily node.\+prev()}}

Returns the next/previous child of the parent node.


\begin{DoxyCode}
var next = id.next();
if (next && next.type !== 'combinator') \{
    throw new Error('Qualified IDs are not allowed!');
\}
\end{DoxyCode}


\subsubsection*{{\ttfamily node.\+replace\+With(node)}}

Replace a node with another.


\begin{DoxyCode}
var attr = selectors.first.first;
var className = parser.className(\{value: 'test'\});
attr.replaceWith(className);
\end{DoxyCode}


Arguments\+:


\begin{DoxyItemize}
\item {\ttfamily node}\+: The node to substitute the original with.
\end{DoxyItemize}

\subsubsection*{{\ttfamily node.\+remove()}}

Removes the node from its parent node.


\begin{DoxyCode}
if (node.type === 'id') \{
    node.remove();
\}
\end{DoxyCode}


\subsubsection*{{\ttfamily node.\+clone()}}

Returns a copy of a node, detached from any parent containers that the original might have had.


\begin{DoxyCode}
var cloned = parser.id(\{value: 'search'\});
String(cloned);

// => #search
\end{DoxyCode}


\subsubsection*{{\ttfamily node.\+spaces}}

Extra whitespaces around the node will be moved into {\ttfamily node.\+spaces.\+before} and {\ttfamily node.\+spaces.\+after}. So for example, these spaces will be moved as they have no semantic meaning\+:


\begin{DoxyCode}
h1     ,     h2   \{\}
\end{DoxyCode}


However, {\itshape combinating} spaces will form a {\ttfamily combinator} node\+:


\begin{DoxyCode}
h1        h2 \{\}
\end{DoxyCode}


A {\ttfamily combinator} node may only have the {\ttfamily spaces} property set if the combinator value is a non-\/whitespace character, such as {\ttfamily +}, {\ttfamily $\sim$} or {\ttfamily $>$}. Otherwise, the combinator value will contain all of the spaces between selectors.

\subsubsection*{{\ttfamily node.\+source}}

An object describing the node\textquotesingle{}s start/end, line/column source position.

Within the following C\+SS, the {\ttfamily .bar} class node ...


\begin{DoxyCode}
.foo,
  .bar \{\}
\end{DoxyCode}


... will contain the following {\ttfamily source} object.


\begin{DoxyCode}
source: \{
    start: \{
        line: 2,
        column: 3
    \},
    end: \{
        line: 2,
        column: 6
    \}
\}
\end{DoxyCode}


\subsubsection*{{\ttfamily node.\+source\+Index}}

The zero-\/based index of the node within the original source string.

Within the following C\+SS, the {\ttfamily .baz} class node will have a {\ttfamily source\+Index} of {\ttfamily 12}.


\begin{DoxyCode}
.foo, .bar, .baz \{\}
\end{DoxyCode}


\subsection*{Container types}

The {\ttfamily root}, {\ttfamily selector}, and {\ttfamily pseudo} nodes have some helper methods for working with their children.

\subsubsection*{{\ttfamily container.\+nodes}}

An array of the container\textquotesingle{}s children.


\begin{DoxyCode}
// Input: h1 h2
selectors.at(0).nodes.length   // => 3
selectors.at(0).nodes[0].value // => 'h1'
selectors.at(0).nodes[1].value // => ' '
\end{DoxyCode}


\subsubsection*{{\ttfamily container.\+first} \& {\ttfamily container.\+last}}

The first/last child of the container.


\begin{DoxyCode}
selector.first === selector.nodes[0];
selector.last === selector.nodes[selector.nodes.length - 1];
\end{DoxyCode}


\subsubsection*{{\ttfamily container.\+at(index)}}

Returns the node at position {\ttfamily index}.


\begin{DoxyCode}
selector.at(0) === selector.first;
selector.at(0) === selector.nodes[0];
\end{DoxyCode}


Arguments\+:


\begin{DoxyItemize}
\item {\ttfamily index}\+: The index of the node to return.
\end{DoxyItemize}

\subsubsection*{{\ttfamily container.\+index(node)}}

Return the index of the node within its container.


\begin{DoxyCode}
selector.index(selector.nodes[2]) // => 2
\end{DoxyCode}


Arguments\+:


\begin{DoxyItemize}
\item {\ttfamily node}\+: A node within the current container.
\end{DoxyItemize}

\subsubsection*{{\ttfamily container.\+length}}

Proxy to the length of the container\textquotesingle{}s nodes.


\begin{DoxyCode}
container.length === container.nodes.length
\end{DoxyCode}


\subsubsection*{{\ttfamily container} Array iterators}

The container class provides proxies to certain Array methods; these are\+:


\begin{DoxyItemize}
\item {\ttfamily container.\+map === container.\+nodes.\+map}
\item {\ttfamily container.\+reduce === container.\+nodes.\+reduce}
\item {\ttfamily container.\+every === container.\+nodes.\+every}
\item {\ttfamily container.\+some === container.\+nodes.\+some}
\item {\ttfamily container.\+filter === container.\+nodes.\+filter}
\item {\ttfamily container.\+sort === container.\+nodes.\+sort}
\end{DoxyItemize}

Note that these methods only work on a container\textquotesingle{}s immediate children; recursive iteration is provided by {\ttfamily container.\+walk}.

\subsubsection*{{\ttfamily container.\+each(callback)}}

Iterate the container\textquotesingle{}s immediate children, calling {\ttfamily callback} for each child. You may return {\ttfamily false} within the callback to break the iteration.


\begin{DoxyCode}
var className;
selectors.each(function (selector, index) \{
    if (selector.type === 'class') \{
        className = selector.value;
        return false;
    \}
\});
\end{DoxyCode}


Note that unlike {\ttfamily Array\+::for\+Each()}, this iterator is safe to use whilst adding or removing nodes from the container.

Arguments\+:


\begin{DoxyItemize}
\item {\ttfamily callback (function)}\+: A function to call for each node, which receives {\ttfamily node} and {\ttfamily index} arguments.
\end{DoxyItemize}

\subsubsection*{{\ttfamily container.\+walk(callback)}}

Like {\ttfamily container\+::each}, but will also iterate child nodes as long as they are {\ttfamily container} types.


\begin{DoxyCode}
selectors.walk(function (selector, index) \{
    // all nodes
\});
\end{DoxyCode}


Arguments\+:


\begin{DoxyItemize}
\item {\ttfamily callback (function)}\+: A function to call for each node, which receives {\ttfamily node} and {\ttfamily index} arguments.
\end{DoxyItemize}

This iterator is safe to use whilst mutating {\ttfamily container.\+nodes}, like {\ttfamily container\+::each}.

\subsubsection*{{\ttfamily container.\+walk} proxies}

The container class provides proxy methods for iterating over types of nodes, so that it is easier to write modules that target specific selectors. Those methods are\+:


\begin{DoxyItemize}
\item {\ttfamily container.\+walk\+Attributes}
\item {\ttfamily container.\+walk\+Classes}
\item {\ttfamily container.\+walk\+Combinators}
\item {\ttfamily container.\+walk\+Comments}
\item {\ttfamily container.\+walk\+Ids}
\item {\ttfamily container.\+walk\+Nesting}
\item {\ttfamily container.\+walk\+Pseudos}
\item {\ttfamily container.\+walk\+Tags}
\item {\ttfamily container.\+walk\+Universals}
\end{DoxyItemize}

\subsubsection*{{\ttfamily container.\+split(callback)}}

This method allows you to split a group of nodes by returning {\ttfamily true} from a callback. It returns an array of arrays, where each inner array corresponds to the groups that you created via the callback.


\begin{DoxyCode}
// (input) => h1 h2>>h3
var list = selectors.first.split((selector) => \{
    return selector.type === 'combinator';
\});

// (node values) => [['h1', ' '], ['h2', '>>'], ['h3']]
\end{DoxyCode}


Arguments\+:


\begin{DoxyItemize}
\item {\ttfamily callback (function)}\+: A function to call for each node, which receives {\ttfamily node} as an argument.
\end{DoxyItemize}

\subsubsection*{{\ttfamily container.\+prepend(node)} \& {\ttfamily container.\+append(node)}}

Add a node to the start/end of the container. Note that doing so will set the parent property of the node to this container.


\begin{DoxyCode}
var id = parser.id(\{value: 'search'\});
selector.append(id);
\end{DoxyCode}


Arguments\+:


\begin{DoxyItemize}
\item {\ttfamily node}\+: The node to add.
\end{DoxyItemize}

\subsubsection*{{\ttfamily container.\+insert\+Before(old, new)} \& {\ttfamily container.\+insert\+After(old, new)}}

Add a node before or after an existing node in a container\+:


\begin{DoxyCode}
selectors.walk(function (selector) \{
    if (selector.type !== 'class') \{
        var className = parser.className(\{value: 'theme-name'\});
        selector.parent.insertAfter(selector, className);
    \}
\});
\end{DoxyCode}


Arguments\+:


\begin{DoxyItemize}
\item {\ttfamily old}\+: The existing node in the container.
\item {\ttfamily new}\+: The new node to add before/after the existing node.
\end{DoxyItemize}

\subsubsection*{{\ttfamily container.\+remove\+Child(node)}}

Remove the node from the container. Note that you can also use {\ttfamily node.\+remove()} if you would like to remove just a single node.


\begin{DoxyCode}
selector.length // => 2
selector.remove(id)
selector.length // => 1;
id.parent       // undefined
\end{DoxyCode}


Arguments\+:


\begin{DoxyItemize}
\item {\ttfamily node}\+: The node to remove.
\end{DoxyItemize}

\subsubsection*{{\ttfamily container.\+remove\+All()} or {\ttfamily container.\+empty()}}

Remove all children from the container.


\begin{DoxyCode}
selector.removeAll();
selector.length // => 0
\end{DoxyCode}


\subsection*{Root nodes}

A root node represents a comma separated list of selectors. Indeed, all a root\textquotesingle{}s {\ttfamily to\+String()} method does is join its selector children with a \textquotesingle{},\textquotesingle{}. Other than this, it has no special functionality and acts like a container.

\subsubsection*{{\ttfamily root.\+trailing\+Comma}}

This will be set to {\ttfamily true} if the input has a trailing comma, in order to support parsing of legacy C\+SS hacks.

\subsection*{Selector nodes}

A selector node represents a single compound selector. For example, this selector string {\ttfamily h1 h2 h3, \mbox{[}href\mbox{]} $>$ p}, is represented as two selector nodes. It has no special functionality of its own.

\subsection*{Pseudo nodes}

A pseudo selector extends a container node; if it has any parameters of its own (such as {\ttfamily h1\+:not(h2, h3)}), they will be its children. Note that the pseudo {\ttfamily value} will always contain the colons preceding the pseudo identifier. This is so that both {\ttfamily \+:before} and {\ttfamily \+::before} are properly represented in the A\+ST.

\subsection*{Attribute nodes}

\subsubsection*{{\ttfamily attribute.\+quoted}}

Returns {\ttfamily true} if the attribute\textquotesingle{}s value is wrapped in quotation marks, false if it is not. Remains {\ttfamily undefined} if there is no attribute value.


\begin{DoxyCode}
[href=foo] /* false */
[href='foo'] /* true */
[href="foo"] /* true */
[href] /* undefined */
\end{DoxyCode}


\subsubsection*{{\ttfamily attribute.\+raws.\+unquoted}}

Returns the unquoted content of the attribute\textquotesingle{}s value. Remains {\ttfamily undefined} if there is no attribute value.


\begin{DoxyCode}
[href=foo] /* foo */
[href='foo'] /* foo */
[href="foo"] /* foo */
[href] /* undefined */
\end{DoxyCode}


\subsubsection*{{\ttfamily attribute.\+raws.\+insensitive}}

If there is an {\ttfamily i} specifying case insensitivity, returns that {\ttfamily i} along with the whitespace around it.


\begin{DoxyCode}
[id=Bar i ] /* " i " */
[id=Bar   i  ] /* "   i  " */
\end{DoxyCode}


\subsection*{{\ttfamily processor}}

\subsubsection*{{\ttfamily process(css\+Text, \mbox{[}options\mbox{]})}}

Processes the {\ttfamily css\+Text}, returning the parsed output


\begin{DoxyCode}
var processor = parser();

var result = processor.process(' .class').result;
// =>  .class

// To have the parser normalize whitespace values, utilize the options
var result = processor.process('  .class  ', \{lossless: false\}).result;
// => .class
\end{DoxyCode}


Arguments\+:


\begin{DoxyItemize}
\item {\ttfamily css\+Text (string)}\+: The css to be parsed.
\item {\ttfamily \mbox{[}options\mbox{]} (object)}\+: Process options
\end{DoxyItemize}

Options\+:


\begin{DoxyItemize}
\item {\ttfamily lossless (boolean)}\+: false to normalize the selector whitespace, defaults to true 
\end{DoxyItemize}