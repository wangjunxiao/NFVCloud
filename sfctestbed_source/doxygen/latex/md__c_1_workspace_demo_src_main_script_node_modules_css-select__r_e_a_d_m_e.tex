a C\+SS selector compiler/engine

\subsection*{What?}

css-\/select turns C\+SS selectors into functions that tests if elements match them. When searching for elements, testing is executed \char`\"{}from the top\char`\"{}, similar to how browsers execute C\+SS selectors.

In its default configuration, css-\/select queries the D\+OM structure of the \href{https://github.com/fb55/domhandler}{\tt {\ttfamily domhandler}} module (also known as htmlparser2 D\+OM).

{\bfseries Features\+:}


\begin{DoxyItemize}
\item Full implementation of C\+S\+S3 selectors
\item Partial implementation of j\+Query/\+Sizzle extensions
\item Very high test coverage
\item Pretty good performance
\end{DoxyItemize}

\subsection*{Why?}

The traditional approach of executing C\+SS selectors, named left-\/to-\/right execution, is to execute every component of the selector in order, from left to right \+\_\+(duh)\+\_\+. The execution of the selector {\ttfamily a b} for example will first query for {\ttfamily a} elements, then search these for {\ttfamily b} elements. (That\textquotesingle{}s the approach of eg. \href{https://github.com/jquery/sizzle}{\tt {\ttfamily Sizzle}}, \href{https://github.com/dperini/nwmatcher/}{\tt {\ttfamily nwmatcher}} and \href{https://github.com/ded/qwery}{\tt {\ttfamily qwery}}.)

While this works, it has some downsides\+: Children of {\ttfamily a}s will be checked multiple times; first, to check if they are also {\ttfamily a}s, then, for every superior {\ttfamily a} once, if they are {\ttfamily b}s. Using \href{http://en.wikipedia.org/wiki/Big_O_notation}{\tt Big O notation}, that would be {\ttfamily O(n$^\wedge$(k+1))}, where {\ttfamily k} is the number of descendant selectors (that\textquotesingle{}s the space in the example above).

The far more efficient approach is to first look for {\ttfamily b} elements, then check if they have superior {\ttfamily a} elements\+: Using big O notation again, that would be {\ttfamily O(n)}. That\textquotesingle{}s called right-\/to-\/left execution.

And that\textquotesingle{}s what css-\/select does â€“ and why it\textquotesingle{}s quite performant.

\subsection*{How does it work?}

By building a stack of functions.

{\itshape Wait, what?}

Okay, so let\textquotesingle{}s suppose we want to compile the selector {\ttfamily a b} again, for right-\/to-\/left execution. We start by {\itshape parsing} the selector, which means we turn the selector into an array of the building-\/blocks of the selector, so we can distinguish them easily. That\textquotesingle{}s what the \href{https://github.com/fb55/css-what}{\tt {\ttfamily css-\/what}} module is for, if you want to have a look.

Anyway, after parsing, we end up with an array like this one\+:


\begin{DoxyCode}
[
  \{ type: 'tag', name: 'a' \},
  \{ type: 'descendant' \},
  \{ type: 'tag', name: 'b' \}
]
\end{DoxyCode}


Actually, this array is wrapped in another array, but that\textquotesingle{}s another story (involving commas in selectors).

Now that we know the meaning of every part of the selector, we can compile it. That\textquotesingle{}s where it becomes interesting.

The basic idea is to turn every part of the selector into a function, which takes an element as its only argument. The function checks whether a passed element matches its part of the selector\+: If it does, the element is passed to the next turned-\/into-\/a-\/function part of the selector, which does the same. If an element is accepted by all parts of the selector, it {\itshape matches} the selector and double rainbow A\+LL T\+HE W\+AY.

As said before, we want to do right-\/to-\/left execution with all the big O improvements nonsense, so elements are passed from the rightmost part of the selector ({\ttfamily b} in our example) to the leftmost ($\sim$$\sim$which would be {\ttfamily c}$\sim$$\sim$ of course {\ttfamily a}).

\+\_\+//\+T\+O\+DO\+: More in-\/depth description. Implementation details. Build a spaceship.\+\_\+

\subsection*{A\+PI}


\begin{DoxyCode}
var CSSselect = require("css-select");
\end{DoxyCode}


\paragraph*{{\ttfamily C\+S\+Sselect(query, elems, options)}}

Queries {\ttfamily elems}, returns an array containing all matches.


\begin{DoxyItemize}
\item {\ttfamily query} can be either a C\+SS selector or a function.
\item {\ttfamily elems} can be either an array of elements, or a single element. If it is an element, its children will be queried.
\item {\ttfamily options} is described below.
\end{DoxyItemize}

Aliases\+: {\ttfamily C\+S\+Sselect.\+select\+All(query, elems)}, {\ttfamily C\+S\+Sselect.\+iterate(query, elems)}.

\paragraph*{{\ttfamily C\+S\+Sselect.\+compile(query)}}

Compiles the query, returns a function.

\paragraph*{{\ttfamily C\+S\+Sselect.\+is(elem, query, options)}}

Tests whether or not an element is matched by {\ttfamily query}. {\ttfamily query} can be either a C\+SS selector or a function.

\paragraph*{{\ttfamily C\+S\+Sselect.\+select\+One(query, elems, options)}}

Arguments are the same as for {\ttfamily C\+S\+Sselect(query, elems)}. Only returns the first match, or {\ttfamily null} if there was no match.

\subsubsection*{Options}


\begin{DoxyItemize}
\item {\ttfamily xml\+Mode}\+: When enabled, tag names will be case-\/sensitive. Default\+: {\ttfamily false}.
\item {\ttfamily strict}\+: Limits the module to only use C\+S\+S3 selectors. Default\+: {\ttfamily false}.
\item {\ttfamily root\+Func}\+: The last function in the stack, will be called with the last element that\textquotesingle{}s looked at. Should return {\ttfamily true}.
\end{DoxyItemize}

\subsection*{Supported selectors}

{\itshape As defined by C\+SS 4 and / or j\+Query.}


\begin{DoxyItemize}
\item Universal ({\ttfamily $\ast$})
\item Tag ({\ttfamily $<$tagname$>$})
\item Descendant ()
\item Child ({\ttfamily $>$})
\item Parent ({\ttfamily $<$}) $\ast$
\item Sibling ({\ttfamily +})
\item Adjacent ({\ttfamily $\sim$})
\item Attribute ({\ttfamily \mbox{[}attr=foo\mbox{]}}), with supported comparisons\+:
\begin{DoxyItemize}
\item {\ttfamily \mbox{[}attr\mbox{]}} (existential)
\item {\ttfamily =}
\item {\ttfamily $\sim$=}
\item {\ttfamily $\vert$=}
\item {\ttfamily $\ast$=}
\item {\ttfamily $^\wedge$=}
\item {\ttfamily \$=}
\item {\ttfamily !=} $\ast$
\item Also, {\ttfamily i} can be added after the comparison to make the comparison case-\/insensitive (eg. {\ttfamily \mbox{[}attr=foo i\mbox{]}}) $\ast$
\end{DoxyItemize}
\item Pseudos\+:
\begin{DoxyItemize}
\item {\ttfamily \+:not}
\item {\ttfamily \+:contains} $\ast$
\item {\ttfamily \+:icontains} $\ast$ (case-\/insensitive version of {\ttfamily \+:contains})
\item {\ttfamily \+:has} $\ast$
\item {\ttfamily \+:root}
\item {\ttfamily \+:empty}
\item {\ttfamily \+:parent} $\ast$
\item {\ttfamily \+:\mbox{[}first$\vert$last\mbox{]}-\/child\mbox{[}-\/of-\/type\mbox{]}}
\item {\ttfamily \+:only-\/of-\/type}, {\ttfamily \+:only-\/child}
\item {\ttfamily \+:nth-\/\mbox{[}last-\/\mbox{]}child\mbox{[}-\/of-\/type\mbox{]}}
\item {\ttfamily \+:link}, {\ttfamily \+:visited} (the latter doesn\textquotesingle{}t match any elements)
\item {\ttfamily \+:selected} $\ast$, {\ttfamily \+:checked}
\item {\ttfamily \+:enabled}, {\ttfamily \+:disabled}
\item {\ttfamily \+:required}, {\ttfamily \+:optional}
\item {\ttfamily \+:header}, {\ttfamily \+:button}, {\ttfamily \+:input}, {\ttfamily \+:text}, {\ttfamily \+:checkbox}, {\ttfamily \+:file}, {\ttfamily \+:password}, {\ttfamily \+:reset}, {\ttfamily \+:radio} etc. $\ast$
\item {\ttfamily \+:matches} $\ast$
\end{DoxyItemize}
\end{DoxyItemize}

{\bfseries $\ast$}\+: Not part of C\+S\+S3 



License\+: B\+S\+D-\/like 