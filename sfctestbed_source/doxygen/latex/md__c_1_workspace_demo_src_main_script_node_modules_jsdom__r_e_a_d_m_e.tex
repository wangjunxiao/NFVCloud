A Java\+Script implementation of the W\+H\+A\+T\+WG D\+OM and H\+T\+ML standards, for use with \href{https://nodejs.org/}{\tt Node.\+js}.

\subsection*{Install}


\begin{DoxyCode}
$ npm install jsdom
\end{DoxyCode}


Note that as of our 7.\+0.\+0 release, jsdom requires Node.\+js 4 or newer (\href{https://github.com/tmpvar/jsdom/blob/master/Changelog.md#700}{\tt why?}). In the meantime you are still welcome to install a release in \href{https://github.com/tmpvar/jsdom/tree/3.x}{\tt the 3.\+x series} if you use legacy Node.\+js versions like 0.\+10 or 0.\+12. There are also various releases between 3.\+x and 7.\+0.\+0 that work with various io.\+js versions.

\subsection*{Human contact}


\begin{DoxyItemize}
\item \href{http://groups.google.com/group/jsdom}{\tt Mailing list}
\item I\+RC channel\+: \href{irc://irc.freenode.net/jsdom}{\tt \#jsdom on freenode}
\end{DoxyItemize}

\subsection*{Easymode\+: {\ttfamily jsdom.\+env}}

{\ttfamily jsdom.\+env} is an A\+PI that allows you to throw a bunch of stuff at it, and it will generally do the right thing.

You can use it with a \mbox{\hyperlink{namespace_u_r_l}{U\+RL}}


\begin{DoxyCode}
// Count all of the links from the io.js build page
var jsdom = require("jsdom");

jsdom.env(
  "https://iojs.org/dist/",
  ["http://code.jquery.com/jquery.js"],
  function (err, window) \{
    console.log("there have been", window.$("a").length - 4, "io.js releases!");
  \}
);
\end{DoxyCode}


or with raw H\+T\+ML


\begin{DoxyCode}
// Run some jQuery on a html fragment
var jsdom = require("jsdom");

jsdom.env(
  '<p><a class="the-link" href="https://github.com/tmpvar/jsdom">jsdom!</a></p>',
  ["http://code.jquery.com/jquery.js"],
  function (err, window) \{
    console.log("contents of a.the-link:", window.$("a.the-link").text());
  \}
);
\end{DoxyCode}


or with a configuration object


\begin{DoxyCode}
// Print all of the news items on Hacker News
var jsdom = require("jsdom");

jsdom.env(\{
  url: "http://news.ycombinator.com/",
  scripts: ["http://code.jquery.com/jquery.js"],
  done: function (err, window) \{
    var $ = window.$;
    console.log("HN Links");
    $("td.title:not(:last) a").each(function() \{
      console.log(" -", $(this).text());
    \});
  \}
\});
\end{DoxyCode}


or with raw Java\+Script source


\begin{DoxyCode}
// Print all of the news items on Hacker News
var jsdom = require("jsdom");
var fs = require("fs");
var jquery = fs.readFileSync("./path/to/jquery.js", "utf-8");

jsdom.env(\{
  url: "http://news.ycombinator.com/",
  src: [jquery],
  done: function (err, window) \{
    var $ = window.$;
    console.log("HN Links");
    $("td.title:not(:last) a").each(function () \{
      console.log(" -", $(this).text());
    \});
  \}
\});
\end{DoxyCode}


\subsubsection*{How it works}

The do-\/what-\/\+I-\/mean A\+PI is used like so\+:


\begin{DoxyCode}
jsdom.env(string, [scripts], [config], callback);
\end{DoxyCode}



\begin{DoxyItemize}
\item {\ttfamily string}\+: may be a \mbox{\hyperlink{namespace_u_r_l}{U\+RL}}, file name, or H\+T\+ML fragment
\item {\ttfamily scripts}\+: a string or array of strings, containing file names or U\+R\+Ls that will be inserted as {\ttfamily $<$script$>$} tags
\item {\ttfamily config}\+: see below
\item {\ttfamily callback}\+: takes two arguments
\begin{DoxyItemize}
\item {\ttfamily err}\+: either {\ttfamily null}, if nothing goes wrong, or an error, if the window could not be created
\item {\ttfamily window}\+: a brand new {\ttfamily window}, if there wasn\textquotesingle{}t an error
\end{DoxyItemize}
\end{DoxyItemize}

{\itshape Example\+:}


\begin{DoxyCode}
jsdom.env(html, function (err, window) \{
  // free memory associated with the window
  window.close();
\});
\end{DoxyCode}


If you would like to specify a configuration object only\+:


\begin{DoxyCode}
jsdom.env(config);
\end{DoxyCode}



\begin{DoxyItemize}
\item {\ttfamily config.\+html}\+: a H\+T\+ML fragment
\item {\ttfamily config.\+file}\+: a file which jsdom will load H\+T\+ML from; the resulting document\textquotesingle{}s \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} will be a {\ttfamily \href{file://}{\tt file\+://}} \mbox{\hyperlink{namespace_u_r_l}{U\+RL}}.
\item {\ttfamily config.\+url}\+: sets the resulting document\textquotesingle{}s \mbox{\hyperlink{namespace_u_r_l}{U\+RL}}, which is reflected in various properties like {\ttfamily document.\+U\+RL} and {\ttfamily location.\+href}, and is also used for cross-\/origin request restrictions. If {\ttfamily config.\+html} and {\ttfamily config.\+file} are not provided, jsdom will load H\+T\+ML from this \mbox{\hyperlink{namespace_u_r_l}{U\+RL}}.
\item {\ttfamily config.\+scripts}\+: see {\ttfamily scripts} above.
\item {\ttfamily config.\+src}\+: an array of Java\+Script strings that will be evaluated against the resulting document. Similar to {\ttfamily scripts}, but it accepts Java\+Script instead of paths/\+U\+R\+Ls.
\item {\ttfamily config.\+cookie\+Jar}\+: cookie jar which will be used by document and related resource requests. Can be created by {\ttfamily jsdom.\+create\+Cookie\+Jar()} method. Useful to share cookie state among different documents as browsers does.
\item {\ttfamily config.\+parsing\+Mode}\+: either {\ttfamily \char`\"{}auto\char`\"{}}, {\ttfamily \char`\"{}html\char`\"{}}, or {\ttfamily \char`\"{}xml\char`\"{}}. The default is {\ttfamily \char`\"{}auto\char`\"{}}, which uses H\+T\+ML behavior unless {\ttfamily config.\+url} responds with an X\+ML {\ttfamily Content-\/\+Type}, or {\ttfamily config.\+file} contains a filename ending in {\ttfamily .xml} or {\ttfamily .xhtml}. Setting to {\ttfamily \char`\"{}xml\char`\"{}} will attempt to parse the document as an X\+H\+T\+ML document. (jsdom is \href{https://github.com/tmpvar/jsdom/labels/x%28ht%29ml}{\tt currently only OK at doing that}.)
\item {\ttfamily config.\+referrer}\+: the new document will have this referrer.
\item {\ttfamily config.\+cookie}\+: manually set a cookie value, e.\+g. `\textquotesingle{}key=value; expires=Wed, Sep 21 2011 12\+:00\+:00 G\+MT; path=/'{\ttfamily . Accepts cookie string or array of cookie strings. -\/}config.\+headers$<$tt$>$\+: an object giving any headers that will be used while loading the H\+T\+ML fromconfig.\+url$<$tt$>$, if applicable. -\/config.\+user\+Agent$<$tt$>$\+: the user agent string used in requests; defaults toNode.\+js (\#process.\+platform\#; U; rv\+:\#process.\+version\#){\ttfamily  -\/}config.\+features$<$tt$>$\+: see Flexibility section below. $\ast$$\ast$\+Note$\ast$$\ast$\+: the default feature set forjsdom.\+env$<$tt$>$does \+\_\+not\+\_\+ include fetching remote Java\+Script and executing it. This is something that you will need to \+\_\+carefully\+\_\+ enable yourself. -\/config.\+resource\+Loader$<$tt$>$\+: a function that intercepts subresource requests and allows you to re-\/route them, modify, or outright replace them with your own content. More below. -\/config.\+done$<$tt$>$,config.\+onload$<$tt$>$,config.\+created$<$tt$>$\+: see below. -\/config.\+concurrent\+Node\+Iterators$<$tt$>$\+: the maximum amount ofNode\+Iterator{\ttfamily s that you can use at the same time. The default is}10{\ttfamily ; setting this to a high value will hurt performance. -\/}config.\+virtual\+Console$<$tt$>$\+: a virtual console instance that can capture the windowâ€™s console output; see the \char`\"{}\+Capturing Console Output\char`\"{} examples. -\/config.\+pool$<$tt$>$\+: an object describing which agents to use for the requests; defaults to\{ max\+Sockets\+: 6 \}{\ttfamily , see \mbox{[}request module\mbox{]}(\href{https://github.com/request/request#requestoptions-callback}{\tt https\+://github.\+com/request/request\#requestoptions-\/callback}) for more details. -\/}config.\+agent$<$tt$>$\+:http(s).Agent{\ttfamily instance to use -\/}config.\+agent\+Class$<$tt$>$\+: alternatively specify your agent\textquotesingle{}s class name -\/config.\+agent\+Options$<$tt$>$\+: the agent options; defaults to\{ keep\+Alive\+: true, keep\+Alive\+Msecs\+: 115000 \}{\ttfamily , see \mbox{[}http api\mbox{]}(\href{https://nodejs.org/api/http.html}{\tt https\+://nodejs.\+org/api/http.\+html}) for more details. -\/}config.\+strict\+S\+S\+L$<$tt$>$\+: iftrue{\ttfamily , requires S\+SL certificates be valid; defaults to}true{\ttfamily , see \mbox{[}request module\mbox{]}(\href{https://github.com/request/request#requestoptions-callback}{\tt https\+://github.\+com/request/request\#requestoptions-\/callback}) for more details. -\/}config.\+proxy\`{}\+: a \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} for a H\+T\+TP proxy to use for the requests.
\end{DoxyItemize}

Note that at least one of the callbacks ({\ttfamily done}, {\ttfamily onload}, or {\ttfamily created}) is required, as is one of {\ttfamily html}, {\ttfamily file}, or {\ttfamily url}.

\subsubsection*{Initialization lifecycle}

If you just want to load the document and execute it, the {\ttfamily done} callback shown above is the simplest. If anything goes wrong while loading the document and creating the window, the problem will show up in the {\ttfamily error} passed as the first argument.

However, if you want more control over or insight into the initialization lifecycle, you\textquotesingle{}ll want to use the {\ttfamily created} and/or {\ttfamily onload} callbacks\+:

\paragraph*{{\ttfamily created(error, window)}}

The {\ttfamily created} callback is called as soon as the window is created, or if that process fails. You may access all {\ttfamily window} properties here; however, {\ttfamily window.\+document} is not ready for use yet, as the H\+T\+ML has not been parsed.

The primary use-\/case for {\ttfamily created} is to modify the window object (e.\+g. add new functions on built-\/in prototypes) before any scripts execute.

You can also set an event handler for `\textquotesingle{}load'\`{} or other events on the window if you wish.

If the {\ttfamily error} argument is non-\/{\ttfamily null}, it will contain whatever loading or initialization error caused the window creation to fail; in that case {\ttfamily window} will not be passed.

\paragraph*{{\ttfamily onload(window)}}

The {\ttfamily onload} callback is called along with the window\textquotesingle{}s `\textquotesingle{}load'{\ttfamily event. This means it will only be called if creation succeeds without error. Note that by the time it has called, any external resources will have been downloaded, and any}$<$script$>$\`{}s will have finished executing.

\paragraph*{{\ttfamily done(error, window)}}

Now that you know about {\ttfamily created} and {\ttfamily onload}, you can see that {\ttfamily done} is essentially both of them smashed together\+:


\begin{DoxyItemize}
\item If window creation fails, then {\ttfamily error} will be the creation error.
\item Otherwise, {\ttfamily window} will be a fully-\/loaded window, with all external resources downloaded and {\ttfamily $<$script$>$}s executed.
\end{DoxyItemize}

\paragraph*{Dealing with asynchronous script loading}

If you load scripts asynchronously, e.\+g. with a module loader like Require\+JS, none of the above hooks will really give you what you want. There\textquotesingle{}s nothing, either in jsdom or in browsers, to say \char`\"{}notify me after all asynchronous loads have completed.\char`\"{} The solution is to use the mechanisms of the framework you are using to notify about this finishing up. E.\+g., with Require\+JS, you could do


\begin{DoxyCode}
// On the Node.js side:
var window = jsdom.jsdom(...).defaultView;
window.onModulesLoaded = function () \{
  console.log("ready to roll!");
\};
\end{DoxyCode}



\begin{DoxyCode}
<script>
requirejs(["entry-module"], function () \{
  window.onModulesLoaded();
\});
</script>
\end{DoxyCode}


For more details, see the discussion in \href{https://github.com/tmpvar/jsdom/issues/640}{\tt \#640}, especially \href{https://github.com/matthewkastor}{\tt }\textquotesingle{}s \href{https://github.com/tmpvar/jsdom/issues/640#issuecomment-22216965}{\tt insightful comment}.

\paragraph*{Listening for script errors during initialization}

Although it is easy to listen for script errors after initialization, via code like


\begin{DoxyCode}
var window = jsdom.jsdom(...).defaultView;
window.addEventListener("error", function (event) \{
  console.error("script error!!", event.error);
\});
\end{DoxyCode}


it is often also desirable to listen for any script errors during initialization, or errors loading scripts passed to {\ttfamily jsdom.\+env}. To do this, use the virtual console feature, described in more detail later\+:


\begin{DoxyCode}
var virtualConsole = jsdom.createVirtualConsole();
virtualConsole.on("jsdomError", function (error) \{
  console.error(error.stack, error.detail);
\});

var window = jsdom.jsdom(..., \{ virtualConsole \}).defaultView;
\end{DoxyCode}


You also get this functionality for free by default if you use {\ttfamily virtual\+Console.\+send\+To}; again, see more below\+:


\begin{DoxyCode}
var virtualConsole = jsdom.createVirtualConsole().sendTo(console);
var window = jsdom.jsdom(..., \{ virtualConsole \}).defaultView;
\end{DoxyCode}


\subsubsection*{On running scripts and being safe}

By default, {\ttfamily jsdom.\+env} will not process and run external Java\+Script, since our sandbox is not foolproof. That is, code running inside the D\+OM\textquotesingle{}s {\ttfamily $<$script$>$}s can, if it tries hard enough, get access to the Node environment, and thus to your machine. If you want to (carefully!) enable running Java\+Script, you can use {\ttfamily jsdom.\+jsdom}, {\ttfamily jsdom.\+j\+Queryify}, or modify the defaults passed to {\ttfamily jsdom.\+env}.

\subsubsection*{On timers and process lifetime}

Timers in the page (set by {\ttfamily window.\+set\+Timeout} or {\ttfamily window.\+set\+Interval}) will, by definition, execute code in the future in the context of the {\ttfamily window}. Since there is no way to execute code in the future without keeping the process alive, note that outstanding jsdom timers will keep your Node.\+js process alive. Similarly, since there is no way to execute code in the context of an object without keeping that object alive, outstanding jsdom timers will prevent garbage collection of the {\ttfamily window} on which they are scheduled. If you want to be sure to shut down a jsdom window, use {\ttfamily window.\+close()}, which will terminate all running timers (and also remove any event listeners on the {\ttfamily window} and {\ttfamily document}).

\subsection*{For the hardcore\+: {\ttfamily jsdom.\+jsdom}}

The {\ttfamily jsdom.\+jsdom} method does fewer things automatically; it takes in only H\+T\+ML source, and it does not allow you to separately supply scripts that it will inject and execute. It just gives you back a {\ttfamily document} object, with usable {\ttfamily document.\+default\+View}, and starts asynchronously executing any {\ttfamily $<$script$>$}s included in the H\+T\+ML source. You can listen for the `\textquotesingle{}load'\`{} event to wait until scripts are done loading and executing, just like you would in a normal H\+T\+ML page.

Usage of the A\+PI generally looks like this\+:


\begin{DoxyCode}
var jsdom = require("jsdom").jsdom;
var doc = jsdom(markup, options);
var window = doc.defaultView;
\end{DoxyCode}



\begin{DoxyItemize}
\item {\ttfamily markup} is a H\+T\+ML document to be parsed. You can also pass {\ttfamily undefined} to get the basic document, equivalent to what a browser will give if you open up an empty {\ttfamily .html} file.
\item {\ttfamily options}\+: see the explanation of the {\ttfamily config} object above.
\end{DoxyItemize}

\subsubsection*{Flexibility}

One of the goals of jsdom is to be as minimal and light as possible. This section details how someone can change the behavior of {\ttfamily Document}s before they are created. These features are baked into the {\ttfamily D\+O\+M\+Implementation} that every {\ttfamily Document} has, and may be tweaked in two ways\+:


\begin{DoxyEnumerate}
\item When you create a new {\ttfamily Document}, by overriding the configuration\+:
\end{DoxyEnumerate}


\begin{DoxyCode}
var jsdom = require("jsdom").jsdom;
var doc = jsdom("<html><body></body></html>", \{
    features: \{
      FetchExternalResources : ["link"]
    \}
\});
\end{DoxyCode}


Do note, that this will only affect the document that is currently being created. All other documents will use the defaults specified below (see\+: Default Features).


\begin{DoxyEnumerate}
\item Before creating any documents, you can modify the defaults for all future documents\+:
\end{DoxyEnumerate}


\begin{DoxyCode}
require("jsdom").defaultDocumentFeatures = \{
    FetchExternalResources: ["script"],
    ProcessExternalResources: false
\};
\end{DoxyCode}


\paragraph*{External Resources}

Default features are extremely important for jsdom as they lower the configuration requirement and present developers a set of consistent default behaviors. The following sections detail the available features, their defaults, and the values that jsdom uses.

{\ttfamily Fetch\+External\+Resources}


\begin{DoxyItemize}
\item {\itshape Default}\+: {\ttfamily \mbox{[}\char`\"{}script\char`\"{}, \char`\"{}link\char`\"{}\mbox{]}}
\item {\itshape Allowed}\+: {\ttfamily \mbox{[}\char`\"{}script\char`\"{}, \char`\"{}frame\char`\"{}, \char`\"{}iframe\char`\"{}, \char`\"{}link\char`\"{}, \char`\"{}img\char`\"{}\mbox{]}} or {\ttfamily false}
\item {\itshape Default for {\ttfamily jsdom.\+env}}\+: {\ttfamily false}
\end{DoxyItemize}

Enables/disables fetching files over the file system/\+H\+T\+TP

{\ttfamily Process\+External\+Resources}


\begin{DoxyItemize}
\item {\itshape Default}\+: {\ttfamily \mbox{[}\char`\"{}script\char`\"{}\mbox{]}}
\item {\itshape Allowed}\+: {\ttfamily \mbox{[}\char`\"{}script\char`\"{}\mbox{]}} or {\ttfamily false}
\item {\itshape Default for {\ttfamily jsdom.\+env}}\+: {\ttfamily false}
\end{DoxyItemize}

Enables/disables Java\+Script execution

{\ttfamily Skip\+External\+Resources}


\begin{DoxyItemize}
\item {\itshape Default}\+: {\ttfamily false} (allow all)
\item {\itshape Allowed}\+: {\ttfamily /url to be skipped/} or {\ttfamily false}
\item {\itshape Example}\+: {\ttfamily /http\+:\textbackslash{}/\textbackslash{}/example.org/js/bad\textbackslash{}.js/}
\end{DoxyItemize}

Filters resource downloading and processing to disallow those matching the given regular expression

\paragraph*{Custom External Resource Loader}

jsdom lets you intercept subresource requests using {\ttfamily config.\+resource\+Loader}. {\ttfamily config.\+resource\+Loader} expects a function which is called for each subresource request with the following arguments\+:


\begin{DoxyItemize}
\item {\ttfamily resource}\+: a vanilla Java\+Script object with the following properties
\begin{DoxyItemize}
\item {\ttfamily element}\+: the element that requested the resource.
\item {\ttfamily url}\+: a parsed \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} object.
\item {\ttfamily cookie}\+: the content of the H\+T\+TP cookie header ({\ttfamily key=value} pairs separated by semicolons).
\item {\ttfamily base\+Url}\+: the base \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} used to resolve relative U\+R\+Ls.
\item {\ttfamily default\+Fetch(callback)}\+: a convenience method to fetch the resource online.
\end{DoxyItemize}
\item {\ttfamily callback}\+: a function to be called with two arguments
\begin{DoxyItemize}
\item {\ttfamily error}\+: either {\ttfamily null}, if nothing goes wrong, or an {\ttfamily Error} object.
\item {\ttfamily body}\+: a string representing the body of the resource.
\end{DoxyItemize}
\end{DoxyItemize}

For example, fetching all JS files from a different directory and running them in strict mode\+:


\begin{DoxyCode}
var jsdom = require("jsdom");

jsdom.env(\{
  url: "http://example.com/",
  resourceLoader: function (resource, callback) \{
    var pathname = resource.url.pathname;
    if (/\(\backslash\).js$/.test(pathname)) \{
      resource.url.pathname = pathname.replace("/js/", "/js/raw/");
      return resource.defaultFetch(function (err, body) \{
        if (err) return callback(err);
        callback(null, '"use strict";\(\backslash\)n' + body);
      \});
    \} else \{
      return resource.defaultFetch(callback);
    \}
  \},
  features: \{
    FetchExternalResources: ["script"],
    ProcessExternalResources: ["script"],
    SkipExternalResources: false
  \}
\});
\end{DoxyCode}


You can return an object containing an {\ttfamily abort()} function which will be called if the window is closed or stopped before the request ends. The {\ttfamily abort()} function should stop the request and call the callback with an error.

For example, simulating a long request\+:


\begin{DoxyCode}
var jsdom = require("jsdom");

jsdom.env(\{
  url: "http://example.com/",
  resourceLoader: function (resource, callback) \{
    var pathname = resource.url.pathname;
    if (/\(\backslash\).json$/.test(pathname)) \{
      var timeout = setTimeout(function() \{
        callback(null, "\{\(\backslash\)"test\(\backslash\)":\(\backslash\)"test\(\backslash\)"\}");
      \}, 10000);
      return \{
        abort: function() \{
          clearTimeout(timeout);
          callback(new Error("request canceled by user"));
        \}
      \};
    \} else \{
      return resource.defaultFetch(callback);
    \}
  \},
  features: \{
    FetchExternalResources: ["script"],
    ProcessExternalResources: ["script"],
    SkipExternalResources: false
  \}
\});
\end{DoxyCode}


\subsection*{Canvas}

jsdom includes support for using the \href{https://npmjs.org/package/canvas}{\tt canvas} or \href{https://npmjs.org/package/canvas-prebuilt}{\tt canvas-\/prebuilt} package to extend any {\ttfamily $<$canvas$>$} elements with the canvas A\+PI. To make this work, you need to include canvas as a dependency in your project, as a peer of jsdom. If jsdom can find the canvas package, it will use it, but if it\textquotesingle{}s not present, then {\ttfamily $<$canvas$>$} elements will behave like {\ttfamily $<$div$>$}s.

\subsection*{More Examples}

\subsubsection*{Creating a browser-\/like window object}


\begin{DoxyCode}
var jsdom = require("jsdom").jsdom;
var document = jsdom("hello world");
var window = document.defaultView;

console.log(window.document.documentElement.outerHTML);
// output: "<html><head></head><body>hello world</body></html>"

console.log(window.innerWidth);
// output: 1024

console.log(typeof window.document.getElementsByClassName);
// outputs: function
\end{DoxyCode}


\subsubsection*{j\+Queryify}


\begin{DoxyCode}
var jsdom = require("jsdom");
var window = jsdom.jsdom().defaultView;

jsdom.jQueryify(window, "http://code.jquery.com/jquery-2.1.1.js", function () \{
  window.$("body").append('<div class="testing">Hello World, It works</div>');

  console.log(window.$(".testing").text());
\});
\end{DoxyCode}


\subsubsection*{Passing objects to scripts inside the page}


\begin{DoxyCode}
var jsdom = require("jsdom").jsdom;
var window = jsdom().defaultView;

window.\_\_myObject = \{ foo: "bar" \};

var scriptEl = window.document.createElement("script");
scriptEl.src = "anotherScript.js";
window.document.body.appendChild(scriptEl);

// anotherScript.js will have the ability to read `window.\_\_myObject`, even
// though it originated in Node.js!
\end{DoxyCode}


\subsubsection*{Shimming unimplemented A\+P\+Is}


\begin{DoxyCode}
var jsdom = require("jsdom");
var document = jsdom("", \{
  created(err, window) \{
    window.alert = () => \{
      // Do something different than jsdom's default "not implemented" virtual console error
    \};

    Object.defineProperty(window, "outerWidth", \{
      get() \{ return 400; \},
      enumerable: true,
      configurable: true
    \});
  \}
\});
\end{DoxyCode}


\subsubsection*{Serializing a document}


\begin{DoxyCode}
var jsdom = require("jsdom").jsdom;
var serializeDocument = require("jsdom").serializeDocument;

var doc = jsdom("<!DOCTYPE html>hello");

serializeDocument(doc) === "<!DOCTYPE html><html><head></head><body>hello</body></html>";
doc.documentElement.outerHTML === "<html><head></head><body>hello</body></html>";
\end{DoxyCode}


\subsubsection*{Sharing cookie state among pages}


\begin{DoxyCode}
var jsdom = require("jsdom");
var cookieJar = jsdom.createCookieJar();

jsdom.env(\{
    url: 'http://google.com',
    cookieJar: cookieJar,
    done: function (err1, window1) \{
        //...

        jsdom.env(\{
            url: 'http://code.google.com',
            cookieJar: cookieJar,
            done: function (err2, window2) \{
                //...
            \}
        \});
    \}
\});
\end{DoxyCode}


\subsubsection*{Capturing Console Output}

\paragraph*{Forward a window\textquotesingle{}s console output to the Node.\+js console}


\begin{DoxyCode}
var jsdom = require("jsdom");

var document = jsdom.jsdom(undefined, \{
  virtualConsole: jsdom.createVirtualConsole().sendTo(console)
\});
\end{DoxyCode}


By default this will forward all {\ttfamily \char`\"{}jsdom\+Error\char`\"{}} events to {\ttfamily console.\+error}. If you want to maintain only a strict one-\/to-\/one mapping of events to method calls, and perhaps handle {\ttfamily \char`\"{}jsdom\+Errors\char`\"{}} yourself, then you can do {\ttfamily send\+To(console, \{ omit\+Jsdom\+Errors\+: true \})}.

\paragraph*{Create an event emitter for a window\textquotesingle{}s console}


\begin{DoxyCode}
var jsdom = require("jsdom");

var virtualConsole = jsdom.createVirtualConsole();

virtualConsole.on("log", function (message) \{
  console.log("console.log called ->", message);
\});

var document = jsdom.jsdom(undefined, \{
  virtualConsole: virtualConsole
\});
\end{DoxyCode}


Post-\/initialization, if you didn\textquotesingle{}t pass in a {\ttfamily virtual\+Console} or no longer have a reference to it, you can retrieve the {\ttfamily virtual\+Console} by using\+:


\begin{DoxyCode}
var virtualConsole = jsdom.getVirtualConsole(window);
\end{DoxyCode}


\paragraph*{Virtual console {\ttfamily jsdom\+Error} error reporting}

Besides the usual events, corresponding to {\ttfamily console} methods, the virtual console is also used for reporting errors from jsdom itself. This is similar to how error messages often show up in web browser consoles, even if they are not initiated by {\ttfamily console.\+error}. So far, the following errors are output this way\+:


\begin{DoxyItemize}
\item Errors loading or parsing external resources (scripts, stylesheets, frames, and iframes)
\item Script execution errors that are not handled by a window {\ttfamily onerror} event handler that returns {\ttfamily true} or calls {\ttfamily event.\+prevent\+Default()}
\item Calls to methods, like {\ttfamily window.\+alert}, which jsdom does not implement, but installs anyway for web compatibility
\end{DoxyItemize}

\subsubsection*{Getting a node\textquotesingle{}s location within the source}

To find where a D\+OM node is within the source document, we provide the {\ttfamily jsdom.\+node\+Location} function\+:


\begin{DoxyCode}
var jsdom = require("jsdom");

var document = jsdom.jsdom(`<p>Hello
    <img src="foo.jpg">
  </p>`);

var bodyEl = document.body; // implicitly created
var pEl = document.querySelector("p");
var textNode = pEl.firstChild;
var imgEl = document.querySelector("img");

console.log(jsdom.nodeLocation(bodyEl));   // null; it's not in the source
console.log(jsdom.nodeLocation(pEl));      // \{ start: 0, end: 39, startTag: ..., endTag: ... \}
console.log(jsdom.nodeLocation(textNode)); // \{ start: 3, end: 13 \}
console.log(jsdom.nodeLocation(imgEl));    // \{ start: 13, end: 32 \}
\end{DoxyCode}


This returns the \href{https://www.npmjs.com/package/parse5#options-locationinfo}{\tt parse5 location info} for the node.

\paragraph*{Overriding {\ttfamily window.\+top}}

The {\ttfamily top} property on {\ttfamily window} is marked {\ttfamily \mbox{[}Unforgeable\mbox{]}} in the spec, meaning it is a non-\/configurable own property and thus cannot be overridden or shadowed by normal code running inside the jsdom window, even using {\ttfamily Object.\+define\+Property}. However, if you\textquotesingle{}re acting from outside the window, e.\+g. in some test framework that creates jsdom instances, you can override it using the special {\ttfamily jsdom.\+reconfigure\+Window} function\+:


\begin{DoxyCode}
jsdom.reconfigureWindow(window, \{ top: myFakeTopForTesting \});
\end{DoxyCode}


In the future we may expand {\ttfamily reconfigure\+Window} to allow overriding other {\ttfamily \mbox{[}Unforgeable\mbox{]}} properties. Let us know if you need this capability.

\paragraph*{Changing the \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} of an existing jsdom {\ttfamily Window} instance}

At present jsdom does not handle navigation (such as setting {\ttfamily window.\+location.\+href === \char`\"{}https\+://example.\+com/\char`\"{}}). However, if you\textquotesingle{}d like to change the \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} of an existing {\ttfamily Window} instance (such as for testing purposes), you can use the {\ttfamily jsdom.\+change\+U\+RL} method\+:


\begin{DoxyCode}
jsdom.changeURL(window, "https://example.com/");
\end{DoxyCode}


\paragraph*{Running vm scripts}

Although in most cases it\textquotesingle{}s simplest to just insert a {\ttfamily $<$script$>$} element or call {\ttfamily window.\+eval}, in some cases you want access to the raw \href{https://nodejs.org/api/vm.html}{\tt vm context} underlying jsdom to run scripts. You can do that like so\+:


\begin{DoxyCode}
const script = new vm.Script("globalVariable = 5;", \{ filename: "test.js" \});
jsdom.evalVMScript(window, script);
\end{DoxyCode}


\subsection*{jsdom vs. Phantom\+JS}

Some people wonder what the differences are between jsdom and \href{http://phantomjs.org/}{\tt Phantom\+JS}, and when you would use one over the other. Here we attempt to explain some of the differences, and why we find jsdom to be a pleasure to use for testing and scraping use cases.

Phantom\+JS is a complete browser (although it uses a very old and rare rendering engine). It even performs layout and rendering, allowing you to query element positions or take a screenshot. jsdom is not a full browser\+: it does not perform layout or rendering, and it does not support navigation between pages. It {\itshape does} support the D\+OM, H\+T\+ML, canvas, many other web platform A\+P\+Is, and running scripts.

So you could use jsdom to fetch the H\+T\+ML of your web application (while also executing the Java\+Script code within that H\+T\+ML). And then you could examine and modify the resulting D\+OM tree. Or you could trigger event listeners to test how the web application reacts. You could also use jsdom to build up your own D\+OM tree from scratch, and then serialize it to a H\+T\+ML string.

You need an executable to run Phantom\+JS. It is written in native code, and has to be compiled for each platform. jsdom is pure Java\+Script, and runs wherever Node.\+js runs. It even has experimental support for running within browsers, giving you the ability to create a whole D\+OM Document inside a web worker.

One of the reasons jsdom is used a lot for testing is that creating a new document instance has very little overhead in jsdom. Opening a new page in Phantom\+JS takes a lot of time, so running a lot of small tests in fresh documents could take minutes in Phantom\+JS, but only seconds in jsdom.

Another important benefit jsdom has for testing is a bit more complicated\+: it is easy to suffer race conditions using an external process like Phantom\+JS (or Selenium). For example if you create a script to test something using Phantom\+JS, that script will live in a different process than the web application. If you perform multiple steps in your test that are dependent on each other (for example, step 1\+: find the element; step 2\+: click on the element), the application might change the D\+OM during those steps (step 1.\+5\+: the page\textquotesingle{}s Java\+Script removes the element). This is not an issue in jsdom, since your tests live in exactly the same thread and event loop as the web application, so if your test is executing Java\+Script code, the web application cannot run its code until your test releases control of the event loop.

In general the same reasons that make jsdom pleasant for testing also make it pleasant for web scraping. In both cases, the extra power of a full browser is not as important as getting things done easily and quickly.

\subsection*{What Standards Does jsdom Support, Exactly?}

Our mission is to get something very close to a headless browser, with emphasis more on the D\+O\+M/\+H\+T\+ML side of things than the C\+SS side. As such, our primary goals are supporting \href{http://dom.spec.whatwg.org/}{\tt The D\+OM Standard} and \href{http://www.whatwg.org/specs/web-apps/current-work/multipage/}{\tt The H\+T\+ML Standard}. We only support some subset of these so far; in particular we have the subset covered by the outdated D\+OM 2 spec family down pretty well. We\textquotesingle{}re slowly including more and more from the modern D\+OM and H\+T\+ML specs, including some {\ttfamily Node} A\+P\+Is, {\ttfamily query\+Selector(\+All)}, attribute semantics, the history and \mbox{\hyperlink{namespace_u_r_l}{U\+RL}} A\+P\+Is, and the H\+T\+ML parsing algorithm.

We also support some subset of the \href{http://dev.w3.org/csswg/cssom/}{\tt C\+S\+S\+OM}, largely via \href{https://github.com/chad3814}{\tt }\textquotesingle{}s excellent \href{https://www.npmjs.org/package/cssstyle}{\tt cssstyle} package. In general we want to make webpages run headlessly as best we can, and if there are other specs we should be incorporating, let us know.

\subsubsection*{Supported encodings}

The supported encodings are the ones listed \href{https://encoding.spec.whatwg.org/#names-and-labels}{\tt in the Encoding Standard} excluding these\+:


\begin{DoxyItemize}
\item I\+S\+O-\/8859-\/8-\/I
\item x-\/mac-\/cyrillic
\item I\+S\+O-\/2022-\/\+JP
\item replacement
\item x-\/user-\/defined 
\end{DoxyItemize}