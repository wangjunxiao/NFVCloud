Yet Another Linked List

There are many doubly-\/linked list implementations like it, but this one is mine.

For when an array would be too big, and a Map can\textquotesingle{}t be iterated in reverse order.

\href{https://travis-ci.org/isaacs/yallist}{\tt } \href{https://coveralls.io/github/isaacs/yallist}{\tt }

\subsection*{basic usage}


\begin{DoxyCode}
var yallist = require('yallist')
var myList = yallist.create([1, 2, 3])
myList.push('foo')
myList.unshift('bar')
// of course pop() and shift() are there, too
console.log(myList.toArray()) // ['bar', 1, 2, 3, 'foo']
myList.forEach(function (k) \{
  // walk the list head to tail
\})
myList.forEachReverse(function (k, index, list) \{
  // walk the list tail to head
\})
var myDoubledList = myList.map(function (k) \{
  return k + k
\})
// now myDoubledList contains ['barbar', 2, 4, 6, 'foofoo']
// mapReverse is also a thing
var myDoubledListReverse = myList.mapReverse(function (k) \{
  return k + k
\}) // ['foofoo', 6, 4, 2, 'barbar']

var reduced = myList.reduce(function (set, entry) \{
  set += entry
  return set
\}, 'start')
console.log(reduced) // 'startfoo123bar'
\end{DoxyCode}


\subsection*{api}

The whole A\+PI is considered \char`\"{}public\char`\"{}.

Functions with the same name as an Array method work more or less the same way.

There\textquotesingle{}s reverse versions of most things because that\textquotesingle{}s the point.

\subsubsection*{Yallist}

Default export, the class that holds and manages a list.

Call it with either a for\+Each-\/able (like an array) or a set of arguments, to initialize the list.

The Array-\/ish methods all act like you\textquotesingle{}d expect. No magic length, though, so if you change that it won\textquotesingle{}t automatically prune or add empty spots.

\subsubsection*{Yallist.\+create(..)}

Alias for Yallist function. Some people like factories.

\paragraph*{yallist.\+head}

The first node in the list

\paragraph*{yallist.\+tail}

The last node in the list

\paragraph*{yallist.\+length}

The number of nodes in the list. (Change this at your peril. It is not magic like Array length.)

\paragraph*{yallist.\+to\+Array()}

Convert the list to an array.

\paragraph*{yallist.\+for\+Each(fn, \mbox{[}thisp\mbox{]})}

Call a function on each item in the list.

\paragraph*{yallist.\+for\+Each\+Reverse(fn, \mbox{[}thisp\mbox{]})}

Call a function on each item in the list, in reverse order.

\paragraph*{yallist.\+get(n)}

Get the data at position {\ttfamily n} in the list. If you use this a lot, probably better off just using an Array.

\paragraph*{yallist.\+get\+Reverse(n)}

Get the data at position {\ttfamily n}, counting from the tail.

\paragraph*{yallist.\+map(fn, thisp)}

Create a new Yallist with the result of calling the function on each item.

\paragraph*{yallist.\+map\+Reverse(fn, thisp)}

Same as {\ttfamily map}, but in reverse.

\paragraph*{yallist.\+pop()}

Get the data from the list tail, and remove the tail from the list.

\paragraph*{yallist.\+push(item, ...)}

Insert one or more items to the tail of the list.

\paragraph*{yallist.\+reduce(fn, initial\+Value)}

Like Array.\+reduce.

\paragraph*{yallist.\+reduce\+Reverse}

Like Array.\+reduce, but in reverse.

\paragraph*{yallist.\+reverse}

Reverse the list in place.

\paragraph*{yallist.\+shift()}

Get the data from the list head, and remove the head from the list.

\paragraph*{yallist.\+slice(\mbox{[}from\mbox{]}, \mbox{[}to\mbox{]})}

Just like Array.\+slice, but returns a new Yallist.

\paragraph*{yallist.\+slice\+Reverse(\mbox{[}from\mbox{]}, \mbox{[}to\mbox{]})}

Just like yallist.\+slice, but the result is returned in reverse.

\paragraph*{yallist.\+to\+Array()}

Create an array representation of the list.

\paragraph*{yallist.\+to\+Array\+Reverse()}

Create a reversed array representation of the list.

\paragraph*{yallist.\+unshift(item, ...)}

Insert one or more items to the head of the list.

\paragraph*{yallist.\+unshift\+Node(node)}

Move a Node object to the front of the list. (That is, pull it out of wherever it lives, and make it the new head.)

If the node belongs to a different list, then that list will remove it first.

\paragraph*{yallist.\+push\+Node(node)}

Move a Node object to the end of the list. (That is, pull it out of wherever it lives, and make it the new tail.)

If the node belongs to a list already, then that list will remove it first.

\paragraph*{yallist.\+remove\+Node(node)}

Remove a node from the list, preserving referential integrity of head and tail and other nodes.

Will throw an error if you try to have a list remove a node that doesn\textquotesingle{}t belong to it.

\subsubsection*{Yallist.\+Node}

The class that holds the data and is actually the list.

Call with {\ttfamily var n = new Node(value, previous\+Node, next\+Node)}

Note that if you do direct operations on Nodes themselves, it\textquotesingle{}s very easy to get into weird states where the list is broken. Be careful \+:)

\paragraph*{node.\+next}

The next node in the list.

\paragraph*{node.\+prev}

The previous node in the list.

\paragraph*{node.\+value}

The data the node contains.

\paragraph*{node.\+list}

The list to which this node belongs. (Null if it does not belong to any list.) 